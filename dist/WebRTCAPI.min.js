/******/ (function(modules) { // webpackBootstrap
/******/ 	// The module cache
/******/ 	var installedModules = {};
/******/
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/
/******/ 		// Check if module is in cache
/******/ 		if(installedModules[moduleId]) {
/******/ 			return installedModules[moduleId].exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = installedModules[moduleId] = {
/******/ 			i: moduleId,
/******/ 			l: false,
/******/ 			exports: {}
/******/ 		};
/******/
/******/ 		// Execute the module function
/******/ 		modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);
/******/
/******/ 		// Flag the module as loaded
/******/ 		module.l = true;
/******/
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/
/******/
/******/ 	// expose the modules object (__webpack_modules__)
/******/ 	__webpack_require__.m = modules;
/******/
/******/ 	// expose the module cache
/******/ 	__webpack_require__.c = installedModules;
/******/
/******/ 	// define getter function for harmony exports
/******/ 	__webpack_require__.d = function(exports, name, getter) {
/******/ 		if(!__webpack_require__.o(exports, name)) {
/******/ 			Object.defineProperty(exports, name, {
/******/ 				configurable: false,
/******/ 				enumerable: true,
/******/ 				get: getter
/******/ 			});
/******/ 		}
/******/ 	};
/******/
/******/ 	// getDefaultExport function for compatibility with non-harmony modules
/******/ 	__webpack_require__.n = function(module) {
/******/ 		var getter = module && module.__esModule ?
/******/ 			function getDefault() { return module['default']; } :
/******/ 			function getModuleExports() { return module; };
/******/ 		__webpack_require__.d(getter, 'a', getter);
/******/ 		return getter;
/******/ 	};
/******/
/******/ 	// Object.prototype.hasOwnProperty.call
/******/ 	__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };
/******/
/******/ 	// __webpack_public_path__
/******/ 	__webpack_require__.p = "";
/******/
/******/ 	// Load entry module and return exports
/******/ 	return __webpack_require__(__webpack_require__.s = 29);
/******/ })
/************************************************************************/
/******/ ([
/* 0 */
/***/ (function(module, exports) {

var g;

// This works in non-strict mode
g = (function() {
	return this;
})();

try {
	// This works if eval is allowed (see CSP)
	g = g || Function("return this")() || (1,eval)("this");
} catch(e) {
	// This works if the window reference is available
	if(typeof window === "object")
		g = window;
}

// g can still be undefined, but nothing to do about it...
// We return undefined, instead of nothing here, so it's
// easier to handle this case. if(!global) { ...}

module.exports = g;


/***/ }),
/* 1 */
/***/ (function(module, exports) {

var Constants = {
    HOST_NAME: 'qcloud.rtc.qq.com',
    WS_URL: "wss://qcloud.rtc.qq.com:8687",
    WEBRTC_CGI_URL: "https://qcloud.rtc.qq.com:8687/api/uploadlog",
    BACKUP_WEBRTC_CGI_URL: "https://ilivelog.qcloud.com/",
    WEBRTC_STUN_SERVER: "",
    ConstraintsMode: 0,
    ICE_BUILD_STATE: {
        SUC: 0,
        SDP_FAILED: 1,
        CANDIDATE_FAILED: 2,
        H264_NOT_SUPPORT: 3,
        GET_STUN_IP_FAILED: 4
    },
    Version: "2.6.2",
    InternalVersion: "0",
    // InternalVersion : "1001",
    RTC_EVENT: {
        ON_PEER_SDP: "on_peer_sdp",
        ON_UPDATE_PEER_SDP: "on_update_peer_sdp",
        ON_PEER_CANDIDATE: "on_peer_candidate",
        ON_BIND_SESSION: "on_bind_session",
        ON_MEDIA_CHANGE: "on_media_change",
        ON_START_CHAT: "on_start_chat",
        ON_QUIT_CHAT: "on_quit_chat",
        ON_CREATE_ROOM: "on_create_room",
        ON_CREATE_PEER: "on_create_peer",
        ON_CLOSE_PEER: "on_close_peer",
        ON_QUALITY_REPORT: "on_quality_report",
        ON_GET_USER_MEDIA_FAILED: "on_get_user_media_failed",
        ON_GET_LOACL_SDP_FAILED: "on_get_local_sdp_failed",
        ON_SET_REMOTE_SDP_FAILED: "on_set_remote_sdp_failed",
        ON_GET_LOCAL_CANDIDATE_FAILED: "on_get_local_candidate_failed",
        ON_SET_REMOTE_CANDIDATE_FAILED: "on_set_remote_candidate_failed",
        ON_GET_SRC_PEER_CONNECTION_FAILED: "on_get_srctinyid_peerconnection_failed",
        ON_SET_REMOTE_CANDIDATE_SUC: "on_set_remote_candidate_suc",
        ON_SET_REMOTE_SDP_SUC: "on_set_remote_sdp_suc",
        ON_ICE_COMPLETE: "on_ice_complete",
        ON_ICE_BROKEN: "on_ice_broken",
        ON_START_WEBRTC_FAILED_WITHOUT_CALLBACK: "on_start_webrtc_failed_without_callback",
        ON_CREATE_PEERCONNECTION_FAILED: "on_create_peerconnection_failed",
        ON_END_REPORT: "on_end_report",
        ON_SPEAR_ROLE_CHANGE: "on_spear_role_change",
        ON_REBUILD_SESSION: "on_rebuild_session",
        ON_GET_USER_MEDIA_OK: "on_get_user_media_ok",
        ON_START_WEBRTC: "on_start_webrtc",
        ON_GET_USER_MEDIA: "on_get_user_media",
        ON_UPLOAD_WEB_LOG: "on_upload_web_log",
        INIT_END_REPORT: "init_end_report",
        ON_GET_MAX_TIMEMS: "on_get_max_timems",
        ON_NOT_SUPPORT_H264: "on_not_support_h264",
        ON_STUN_FAILED: "on_stun_failed",
        ON_STREAM_NOTIFY: "on_stream_notify",
    },

    KEY_TAG: {
        WEBSOCKET_TAG: "websocket_tag",
        SDP_TAG: "sdp_tag",
        CANDIDATE_TAG: "candidate_tag",
        USER_MEDIA_TAG: "user_media_tag",
        UPDATE_VIDEO_SSRC_TAG: "update_video_ssrc_tag",
        UPDATE_AUDIO_SSRC_TAG: "update_audio_ssrc_tag",
        UPDATE_LOCAL_MEDIA_STREAM_TAG: "update_local_media_stream_tag",
        UPDATE_SUB_VIDEO_TAG: "update_sub_video_tag",
        RTC_LOG_TAG: "rtc_log_tag",
        WEBSOCKET_BUILD_FAILED_TAG: "websocket_build_failed_tag",
        WEBSOCKET_REBUILD_TAG: "websocket_rebuild_tag",
        REPORT_TIME_OUT_TAG: "report_timeout"
    },

    MEDIA_CHANGE: {
        OPEN_VIDEO: 1,
        CLOSE_VIDEO: 2,
        OPEN_AUDIO: 3,
        CLOSE_AUDIO: 4
    },
    WS_MAX_RETRY_COUNT: 3,
    WS_RETRY_DIST: 3000,

    WS_CMD: {
        SDP: 0x2,
        CANDIDATE: 0x4,
        MEDIA_CHANGE: 0x0d,
        START_CHAT: 0x06,
        QUIT_CHAT: 0x08,
        CLOSE_PEER: 0x09,
        CLOSE_PEER_RES: 0x0a,
        ON_STAGE: 0x0c,
        WS_INIT_OK: 0x13,
        WS_INIT_FAILED: 0x50,
        CREATE_ROOM_RESULT: 0x14,
        NOTIFY_CREATE_PEER_CONNECTION: 0x10, //通知建立新peerconnection
        NOTIFY_CREATE_PEER_CONNECTION_RES: 0x11, //通知建立新peerconnection
        NOTIFY_CLOSE_PEER_CONNECTION: 0x12, //通知关闭peerconnection
        NOTIFY_CHANGE_CONSTRAINTS: 0x20, //通知改变上行视频分辨率、帧率
        NOTIFY_SUB_VIDEO_STATE: 0x30, //通知增加辅路
        NOTIFY_UPDATE_AUDIO_SSRC: 0x32, //通知更新音频ssrc
        NOTIFY_UPDATE_VIDEO_SSRC: 0x34, //通知更新主路视频ssrc
        NOTIFY_MAX_TIMEMS: 0x302, //通知当前上行音频、视频数据的最大时间戳
        NOTIFY_RECONNECT_DC: 0x211
    },

    STREAM_TYPE: {
        NONE: 0,
        AUDIO: 1, //音频
        MAIN: 2, //主路
        AID: 7 //辅路
    },

    STREAM_MISD: {
        MAIN: '5Y2wZK8nANNAoVw6dSAHVjNxrD1ObBM2kBPV',
        AID: '224d130c-7b5c-415b-aaa2-79c2eb5a6df2'
    },

    USER_DEFINED_EVENT: {
        WEBSOCKET_INIT: "websocket_init",
        WEBSOCKET_INIT_OK: "websocket_init_ok",
        RECEIVE_CREATE_PEER: "receive_create_pc",
        BEGIN_CREATE_PEER: "begin_create_pc",
        CREATE_PC_SUC: "create_pc_suc",
        CREATE_PC_FAILED: "create_pc_failed",
        BEGIN_START_WEBRTC: "begin_start_webrtc",
        GET_LOCAL_SDP_SUC: "get_local_sdp_suc",
        GET_LOCAL_SDP_FAILED: "get_local_sdp_failed",
        RECEIVE_REMOTE_SDP: "receive_remote_sdp",
        SET_REMOTE_SDP_SUC: "set_remote_sdp_suc",
        SET_REMOTE_SDP_FAILED: "set_remote_sdp_failed",
        GET_LOCAL_CANDIDATE_SUC: "get_local_candidate_suc",
        GET_LOCAL_STUN_IP_FAILED: "get_local_stun_ip_failed",
        RECEIVE_REMOTE_CANDIDATE: "receive_remote_candidate",
        SET_REMOTE_CANDIDATE_SUC: "set_remote_candidate_suc",
        SET_REMOTE_CANDIDATE_FAILED: "set_remote_candidate_failed",
        ON_ICE_STATE_CHANGE: "on_ice_state_change",
        ON_ICE_GATHERING_STATE_CHANGE: "on_ice_gathering_state_change",
        ON_WEBSOCKET_CLOSE_BY_NETWORK_BROKEN: "on_websocket_close_by_network_broken",
        NOTICE_PEERCONNECTION: "notice_pc",
        NOTIFY_NO_SIG_AFTER_PRECONNECTION: "notice_no_sig_after_preconnection"
    },
    OPTIONAL: {
        optional: [{
            DtlsSrtpKeyAgreement: true
        }]
    },

    ERROR_CODE: {
        SUCC: 0, // 
        PARAM_MISSING: 10001, // 参数缺失
        NOT_SUPPORT: 10002, // 
        INIT_WS_FAILED: 10005, // 初始化ws失败
        ENTER_ROOM_ERROR: 10006, //进房失败 
        CREATE_PEERCONNECTION_FAILED: 10007, // PeerConnection 创建失败
        GET_USERMEDIA_FAILED: 10008, // getUserMedia 失败
        GET_LOCALSDP_FAILED: 10009, // getLocalSdp 失败
        GET_LOCAL_CANDIDATE_FAILED: 10011,
        GET_ANSWER_SDP_FAILED: 10013, // getLocalSdp 失败
        ON_ICE_BROKEN: 10014,
        ON_ICE_CLOSE: 10015,
        INIT_SDK_FAILED: 11000,
        SET_REMOTE_SDP_FAILED: 10012,
        NOT_FOUND: 10031, // NOT_FOUND
        NOT_INITED: 10032, // 尚未初始化
        START_RTC_FAILED: 10033,
        STOP_RTC_FAILED: 10034, //STOP RTC FAILED
        WS_CLOSE: 10035,
        WS_ERROR: 10036,
        UPDATE_VIDEO_SSRC_FAILED: 10037,
        UPDATE_AUDIO_SSRC_FAILED: 10038,
        NOT_FOUND_PEER: 10039,
        CHOOSE_SPEARK_FAILED: 10040,
        TLS_VERIFY_ERROR: 70236
    },
    GET_STUN: function () {
        var stun = {
            iceServers: [],
            bundlePolicy: "max-bundle",
            rtcpMuxPolicy: "require",
            tcpCandidatePolicy: "disable",
            IceTransportsType: "nohost"
        };
        if (Constants.WEBRTC_STUN_SERVER) {
            stun.iceServers = [{
                urls: Constants.WEBRTC_STUN_SERVER
            }]
        }
        return stun;
    },

    setHostname: function (domain) {
        this.HOST_NAME = domain
        this.WS_URL = "wss://" + domain + ":8687"
        this.WEBRTC_CGI_URL = "https://" + domain + ":8687/api/uploadlog"
    }
};

module.exports = Constants

/***/ }),
/* 2 */,
/* 3 */
/***/ (function(module, exports, __webpack_require__) {


var Util = __webpack_require__(4)
var Constants = __webpack_require__(1)
var fly=__webpack_require__(5)
var debugout=__webpack_require__(37)
var debugout = new debugout();
    debugout.realTimeLoggingOn = false;
    /* 
var BJ_WEBRTC = require('@tencent/im-badjs-webrtc/dist/bj-report');
if (BJ_WEBRTC) {
    return;
    var ignores = [
        '"isTrigger":true,"namespace":"","namespace_re":null', // 腾讯视频使用jquery处理已移除元素事件的错误
        '58mingtian.cn', // 已知的外部js爬虫脚本，量比较大
        'Unexpected identifier after numeric literal', // badjs中存在1e3，会被低版本Edge浏览器解析为变量报错
        "Expected ';'", // IE浏览器已做跳转处理
    ];
    BJ_WEBRTC.init({
        id: 1429,
        ignore: [
            function(error){
                var str = JSON.stringify(error.msg);
                if (error.level === 4) {
                for (var i = 0; i < ignores.length; i++) {
                    if (str.indexOf(ignores[i]) > -1 || str.indexOf(encodeURIComponent(ignores[i])) > -1) {
                    BJ_WEBRTC.info(error);
                    return true;
                    }
                }
                }
                return false;
            },
        ],
        url: "//badjs2.qq.com/badjs",
        repeat: 1,
        jsErrorMSID: 3233841,
        debugMSID: 3234595,
        infoMSID: 3234596,
        errorMSID: 3234597,
    });
    // BJ_REPORT.tryJs().spyAll();
}
 */
var debugMode = false;
var uploadlogSwitcher = true;
var vConsole = null;
var uploadLogRetry = 0;
var uploadLogMaxRetryTimes = 5;
var LogCGI = Constants.BACKUP_WEBRTC_CGI_URL
var SDKAPPID = null;

function badjsReport(_msid, _msg, level, delay) {
    return
    level = level || 2;
    if (BJ_WEBRTC) {
        var data = {
            ext: { msid: _msid },
            href: location.href,
            level: level,
            msg:_msg +  '[sdkappid | '+ SDKAPPID + ']' 
        }
        if( !delay ){
            BJ_WEBRTC.report( data );
        }else{
            // BJ_WEBRTC.push( data );
        }
    }
};

function badjsInit( sdkappid ) {
    SDKAPPID = sdkappid
};

var RTCLog = new function() {
    var TAG = "WEBRTC_API : ";
    this._uploadLogOpen = Util.query('uploadlog') || false;
    if(Util.query("debug")){
        createVConsole();
    }
    this.LOG_LEVEL = {
        RTC_LOG_DEBUG : "RTC_LOG_DEBUG",
        RTC_LOG_INFO : "RTC_LOG_INFO",
        RTC_LOG_WARN : "RTC_LOG_WARN",
        RTC_LOG_ERROR : "RTC_LOG_ERROR"
    };
    this.error = function(msg, obj) {
        if( uploadlogSwitcher ){
            badjsReport(null, msg, 4); 
        }
        debugout.log("[ERROR]"+msg + (obj ? JSON.stringify(obj) : "" ));
        if (!debugMode) {
            return;
        }
        if (!obj) {
            console.error(TAG + msg);
        } else {
            console.error(TAG + msg, obj);
        }
    };
    this.debug = function(msg, obj) {
        if (!debugMode) {
            return;
        } 
        debugout.log("[DEBUG]"+msg + (obj ? JSON.stringify(obj) : "" ));
        if( uploadlogSwitcher ){
            badjsReport(null, msg, 1 , true); 
        }
        if (!obj) {
            console.log(TAG + msg);
        } else {
            console.log(TAG + msg, obj);
        }
    };
    this.info = function (msg, obj) {
        debugout.log("[INFO]"+msg + (obj ? JSON.stringify(obj) : "" ));
        if (!debugMode) {
            return;
        }
        if( uploadlogSwitcher ){
            badjsReport(null, msg, 2 , true); 
        }
        if (!obj) {
            console.info(TAG + msg);
        } else {
            console.info(TAG + msg, obj);
        }
    };
    this.warn = function (msg, obj) {
        debugout.log("[WARN]"+msg + (obj ? JSON.stringify(obj) : "" ));
        if (!debugMode) {
            return;
        }
        if (!obj) {
            console.warn(TAG + msg);
        } else {
            console.warn(TAG + msg, obj);
        }
    };
};


function uploadWebLog(global, msg, obj, tag) {
    try {
        if (!Constants.WEBRTC_CGI_URL) {
            console.warn("CGI URL not ready!");
            return;
        }
        var sendData = JSON.stringify({
            index:"webrtc",
            type:"websdk",
            localip : global.localip,
            relayip : global.relayip,
            signalip : global.signalip,
            tinyid : global.config && global.config.tinyid,
            userId : global.config &&  global.config.userId,
            appid : global.config &&  global.config.sdkAppId,
            roomId: global.roomid || 0,
            sdkappid : global.config &&  global.config.sdkAppId,
            tag : tag,
            log : msg
        });

        if( !uploadlogSwitcher ) return
        fly.post( LogCGI , sendData, {parseJson:false} ).catch(function (error) { 
            if( uploadLogRetry < uploadLogMaxRetryTimes){
                uploadLogRetry ++
                // console.warn("upload log error, but dont't worry , it won't affect your business.  ", error);
            }else{
                LogCGI =  LogCGI === Constants.WEBRTC_CGI_URL ? Constants.BACKUP_WEBRTC_CGI_URL : Constants.WEBRTC_CGI_URL;
                uploadLogRetry = 0;
            }
        });
    } catch (e) {
        if( uploadLogRetry < uploadLogMaxRetryTimes){
            uploadLogRetry ++
            console.error("upload log error : ", e);
        }else{
            LogCGI =  LogCGI === Constants.WEBRTC_CGI_URL ? Constants.BACKUP_WEBRTC_CGI_URL : Constants.WEBRTC_CGI_URL;
            uploadLogRetry = 0;
        }
    }
}
function debug( info ){

    debugMode = info.log || false;
    uploadlogSwitcher = typeof info.uploadLog === 'undefined' ? true : info.uploadLog
    if( debugMode ){
        console.log("-------------调试模式----------------")
        debugout.recordLogs = true;
    }else{        
        debugout.recordLogs = false;
    }
    if( !uploadlogSwitcher ){
        console.log("-------------不上报----------------")
    }

    if( info.vconsole ){
        createVConsole();
    }else if( !info.vconsole && vConsole){
        vConsole.destroy();
        vConsole = null;
    }
}


function createVConsole() {
    var scriptEle = document.createElement("script");
    scriptEle.src = '//sqimg.qq.com/expert_qq/vConsole/vconsole.min.js';
    document.body.appendChild(scriptEle)
    scriptEle.onload = function(){
        window.vConsole = new VConsole();
    }
};

function printEnvironmentInfo(global){
    var css = "color:#00a4ff;font-family:Microsoft Yahei";
    var str = [' domain:' , Constants.HOST_NAME , " sdkappid:" , global.config.sdkAppId]
    console.log("%c %s", css, str.join(" "));
}
(function(){
    try{
        var css = "color:#00a4ff;font-family:Microsoft Yahei";
        var str = [
        'Version:'+ Constants.Version + ' | InnerVersion: ' + Constants.InternalVersion,
        ' ',
        '感谢您选择腾讯视频云',
        '我们为您准备了辅助开发的快捷访问地址，访问你在开发中定位问题：',
        ' ',
        '错误码：https://cloud.tencent.com/document/product/647/17016',
        ' ',
        '常见问题：https://cloud.tencent.com/document/product/647/17017',
        ]
        console.log("%c %s", css, str.join("\n"));
    }catch(e){}
})();

module.exports = {
    printEnvironmentInfo: printEnvironmentInfo,
    uploadWebLog : uploadWebLog,
    debug : debug,
    RTCLog: RTCLog,
    badjsReport: badjsReport,
    badjsInit:badjsInit,
    debugout:debugout
};

/***/ }),
/* 4 */
/***/ (function(module, exports) {

/*判断是否是内网IP*/  
function isInnerIPFn( ipAddress ){

    var isInnerIp = false;//默认给定IP不是内网IP      
    var ipNum = getIpNum(ipAddress);      
    /** 
     * 私有IP：A类  10.0.0.0    -10.255.255.255 
     *       B类  172.16.0.0  -172.31.255.255    
     *       C类  192.168.0.0 -192.168.255.255   
     *       D类   127.0.0.0   -127.255.255.255(环回地址)  
     **/     
    var aBegin = getIpNum("10.0.0.0");      
    var aEnd = getIpNum("10.255.255.255");      
    var bBegin = getIpNum("172.16.0.0");      
    var bEnd = getIpNum("172.31.255.255");      
    var cBegin = getIpNum("192.168.0.0");      
    var cEnd = getIpNum("192.168.255.255");   
    var dBegin = getIpNum("127.0.0.0");      
    var dEnd = getIpNum("127.255.255.255");  
    isInnerIp = isInner(ipNum,aBegin,aEnd) || isInner(ipNum,bBegin,bEnd) || isInner(ipNum,cBegin,cEnd) || isInner(ipNum,dBegin,dEnd);  
    return isInnerIp;  
}  
function getIpNum(ipAddress) {/*获取IP数*/      
    var ip = ipAddress.split(".");      
    var a = parseInt(ip[0]);      
    var b = parseInt(ip[1]);      
    var c = parseInt(ip[2]);      
    var d = parseInt(ip[3]);  
    var ipNum = a * 256 * 256 * 256 + b * 256 * 256 + c * 256 + d;      
    return ipNum;      
}     

function isInner(userIp,begin,end){      
    return (userIp>=begin) && (userIp<=end);      
} 


var Util = {
    query: function(n){
        var m = window.location.search.match(new RegExp( "(\\?|&)"+n+"=([^&]*)(&|$)"));
        return !m ? "":decodeURIComponent(m[2]);
    },
    getHash: function(n){
        var m = window.location.hash.match(new RegExp( "(#|&)"+n+"=([^&]*)(&|$)"));
        return !m ? "":decodeURIComponent(m[2]);
    },
    cloneObj: function(obj){
        var str, newobj = obj.constructor === Array ? [] : {};
        if(typeof obj !== 'object'){
            return;
        } else if(window.JSON){
            str = JSON.stringify(obj),
                newobj = JSON.parse(str);
        } else {
            for(var i in obj){
                newobj[i] = typeof obj[i] === 'object' ?
                    cloneObj(obj[i]) : obj[i];
            }
        }
        return newobj;
    },
    takeSnapshot: function (succ , fail) {
        function _takeSnapshot(video) {
            var canvas = document.createElement('canvas');
            canvas.width = video.videoWidth || video.clientWidth;
            canvas.height = video.videoHeight || video.clientHeight;
            
            var context = canvas.getContext('2d');
            context.drawImage(video, 0, 0, canvas.width, canvas.height);
            succ && succ( canvas.toDataURL('image/png') );
        }
        var media = this;
        return _takeSnapshot(media);
    },
    isInnerIPFn: isInnerIPFn
};
HTMLVideoElement.prototype.takeSnapshot = Util.takeSnapshot 
module.exports = Util;

/***/ }),
/* 5 */
/***/ (function(module, exports, __webpack_require__) {

//For browser entry
var Fly= __webpack_require__(6)
var fly= new Fly;
module.exports = fly;


/***/ }),
/* 6 */
/***/ (function(module, exports, __webpack_require__) {

(function webpackUniversalModuleDefinition(root, factory) {
	if(true)
		module.exports = factory();
	else if(typeof define === 'function' && define.amd)
		define([], factory);
	else {
		var a = factory();
		for(var i in a) (typeof exports === 'object' ? exports : root)[i] = a[i];
	}
})(this, function() {
return /******/ (function(modules) { // webpackBootstrap
/******/ 	// The module cache
/******/ 	var installedModules = {};
/******/
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/
/******/ 		// Check if module is in cache
/******/ 		if(installedModules[moduleId]) {
/******/ 			return installedModules[moduleId].exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = installedModules[moduleId] = {
/******/ 			i: moduleId,
/******/ 			l: false,
/******/ 			exports: {}
/******/ 		};
/******/
/******/ 		// Execute the module function
/******/ 		modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);
/******/
/******/ 		// Flag the module as loaded
/******/ 		module.l = true;
/******/
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/
/******/
/******/ 	// expose the modules object (__webpack_modules__)
/******/ 	__webpack_require__.m = modules;
/******/
/******/ 	// expose the module cache
/******/ 	__webpack_require__.c = installedModules;
/******/
/******/ 	// identity function for calling harmony imports with the correct context
/******/ 	__webpack_require__.i = function(value) { return value; };
/******/
/******/ 	// define getter function for harmony exports
/******/ 	__webpack_require__.d = function(exports, name, getter) {
/******/ 		if(!__webpack_require__.o(exports, name)) {
/******/ 			Object.defineProperty(exports, name, {
/******/ 				configurable: false,
/******/ 				enumerable: true,
/******/ 				get: getter
/******/ 			});
/******/ 		}
/******/ 	};
/******/
/******/ 	// getDefaultExport function for compatibility with non-harmony modules
/******/ 	__webpack_require__.n = function(module) {
/******/ 		var getter = module && module.__esModule ?
/******/ 			function getDefault() { return module['default']; } :
/******/ 			function getModuleExports() { return module; };
/******/ 		__webpack_require__.d(getter, 'a', getter);
/******/ 		return getter;
/******/ 	};
/******/
/******/ 	// Object.prototype.hasOwnProperty.call
/******/ 	__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };
/******/
/******/ 	// __webpack_public_path__
/******/ 	__webpack_require__.p = "";
/******/
/******/ 	// Load entry module and return exports
    /******/
    return __webpack_require__(__webpack_require__.s = 2);
/******/ })
/************************************************************************/
/******/ ([
/* 0 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };

module.exports = {
    type: function type(ob) {
        return Object.prototype.toString.call(ob).slice(8, -1).toLowerCase();
    },
    isObject: function isObject(ob, real) {
        if (real) {
            return this.type(ob) === "object";
        } else {
            return ob && (typeof ob === 'undefined' ? 'undefined' : _typeof(ob)) === 'object';
        }
    },
    isFormData: function isFormData(val) {
        return typeof FormData !== 'undefined' && val instanceof FormData;
    },
    trim: function trim(str) {
        return str.replace(/(^\s*)|(\s*$)/g, '');
    },
    encode: function encode(val) {
        return encodeURIComponent(val).replace(/%40/gi, '@').replace(/%3A/gi, ':').replace(/%24/g, '$').replace(/%2C/gi, ',').replace(/%20/g, '+').replace(/%5B/gi, '[').replace(/%5D/gi, ']');
    },
    formatParams: function formatParams(data) {
        var str = "";
        var first = true;
        var that = this;
        if ((typeof data === 'undefined' ? 'undefined' : _typeof(data)) != "object") {
            return data;
        }
        function _encode(sub, path) {
            var encode = that.encode;
            var type = that.type(sub);
            if (type == "array") {
                sub.forEach(function (e, i) {
                    _encode(e, path + "%5B%5D");
                });
            } else if (type == "object") {
                for (var key in sub) {
                    if (path) {
                        _encode(sub[key], path + "%5B" + encode(key) + "%5D");
                    } else {
                        _encode(sub[key], encode(key));
                    }
                }
            } else {
                if (!first) {
                    str += "&";
                }
                first = false;
                str += path + "=" + encode(sub);
            }
        }

        _encode(data, "");
        return str;
    },

    // Do not overwrite existing attributes
    merge: function merge(a, b) {
        for (var key in b) {
            if (!a.hasOwnProperty(key)) {
                a[key] = b[key];
            } else if (this.isObject(b[key], 1) && this.isObject(a[key], 1)) {
                this.merge(a[key], b[key]);
            }
        }
        return a;
    }
};

/***/ }),
/* 1 */,
    /* 2 */
/***/ (function(module, exports, __webpack_require__) {

function KEEP(_,cb){cb();}
"use strict";

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

var utils = __webpack_require__(0);
var isBrowser = typeof document !== "undefined";

var Fly = function () {
    function Fly(engine) {
        _classCallCheck(this, Fly);

        this.engine = engine || XMLHttpRequest;

        this.default = this; //For typeScript

        /**
         * Add  lock/unlock API for interceptor.
         *
         * Once an request/response interceptor is locked, the incoming request/response
         * will be added to a queue before they enter the interceptor, they will not be
         * continued  until the interceptor is unlocked.
         *
         * @param [interceptor] either is interceptors.request or interceptors.response
         */
        function wrap(interceptor) {
            var completer;
            utils.merge(interceptor, {
                lock: function lock() {
                    if (!completer) {
                        interceptor.p = new Promise(function (resolve) {
                            completer = resolve;
                        });
                    }
                },
                unlock: function unlock() {
                    if (completer) {
                        completer();
                        interceptor.p = completer = null;
                    }
                }
            });
        }

        var interceptors = this.interceptors = {
            response: {
                use: function use(handler, onerror) {
                    this.handler = handler;
                    this.onerror = onerror;
                }
            },
            request: {
                use: function use(handler) {
                    this.handler = handler;
                }
            }
        };

        var irq = interceptors.request;
        var irp = interceptors.response;
        wrap(irp);
        wrap(irq);

        this.config = {
            method: "GET",
            baseURL: "",
            headers: {},
            timeout: 0,
            parseJson: true, // Convert response data to JSON object automatically.
            withCredentials: false
        };
    }

    _createClass(Fly, [{
        key: "request",
        value: function request(url, data, options) {
            var _this = this;

            var engine = new this.engine();
            var contentType = "Content-Type";
            var contentTypeLowerCase = contentType.toLowerCase();
            var interceptors = this.interceptors;
            var requestInterceptor = interceptors.request;
            var responseInterceptor = interceptors.response;
            var requestInterceptorHandler = requestInterceptor.handler;
            var promise = new Promise(function (resolve, reject) {
                if (utils.isObject(url)) {
                    options = url;
                    url = options.url;
                }
                options = options || {};
                options.headers = options.headers || {};

                function isPromise(p) {
                    // some  polyfill implementation of Promise may be not standard,
                    // so, we test by duck-typing
                    return p && p.then && p.catch;
                }

                /**
                 * If the request/response interceptor has been locked，
                 * the new request/response will enter a queue. otherwise, it will be performed directly.
                 * @param [promise] if the promise exist, means the interceptor is  locked.
                 * @param [callback]
                 */
                function enqueueIfLocked(promise, callback) {
                    if (promise) {
                        promise.then(function () {
                            callback();
                        });
                    } else {
                        callback();
                    }
                }

                // make the http request
                function makeRequest(options) {
                    data = options.body;
                    // Normalize the request url
                    url = utils.trim(options.url);
                    var baseUrl = utils.trim(options.baseURL || "");
                    if (!url && isBrowser && !baseUrl) url = location.href;
                    if (url.indexOf("http") !== 0) {
                        var isAbsolute = url[0] === "/";
                        if (!baseUrl && isBrowser) {
                            var arr = location.pathname.split("/");
                            arr.pop();
                            baseUrl = location.protocol + "//" + location.host + (isAbsolute ? "" : arr.join("/"));
                        }
                        if (baseUrl[baseUrl.length - 1] !== "/") {
                            baseUrl += "/";
                        }
                        url = baseUrl + (isAbsolute ? url.substr(1) : url);
                        if (isBrowser) {

                            // Normalize the url which contains the ".." or ".", such as
                            // "http://xx.com/aa/bb/../../xx" to "http://xx.com/xx" .
                            var t = document.createElement("a");
                            t.href = url;
                            url = t.href;
                        }
                    }

                    var responseType = utils.trim(options.responseType || "");
                    engine.withCredentials = !!options.withCredentials;
                    var isGet = options.method === "GET";
                    if (isGet) {
                        if (data) {
                            if (utils.type(data) !== "string") {
                                data = utils.formatParams(data);
                            }
                            url += (url.indexOf("?") === -1 ? "?" : "&") + data;
                        }
                    }
                    engine.open(options.method, url);

                    // try catch for ie >=9
                    try {
                        engine.timeout = options.timeout || 0;
                        if (responseType !== "stream") {
                            engine.responseType = responseType;
                        }
                    } catch (e) {
                    }

                    if (!isGet) {
                        // default content type
                        var _contentType = "application/x-www-form-urlencoded";
                        // If the request data is json object, transforming it  to json string,
                        // and set request content-type to "json". In browser,  the data will
                        // be sent as RequestBody instead of FormData
                        if (utils.trim((options.headers[contentType] || "").toLowerCase()) === _contentType) {
                            data = utils.formatParams(data);
                        } else if (!utils.isFormData(data) && ["object", "array"].indexOf(utils.type(data)) !== -1) {
                            _contentType = 'application/json;charset=utf-8';
                            data = JSON.stringify(data);
                        }
                        options.headers[contentType] = _contentType;
                    }

                    for (var k in options.headers) {
                        if (k === contentType && (utils.isFormData(data) || !data || isGet)) {
                            // Delete the content-type, Let the browser set it
                            delete options.headers[k];
                        } else {
                            try {
                                // In browser environment, some header fields are readonly,
                                // write will cause the exception .
                                engine.setRequestHeader(k, options.headers[k]);
                            } catch (e) {
                            }
                        }
                    }

                    function onresult(handler, data, type) {
                        enqueueIfLocked(responseInterceptor.p, function () {
                            if (handler) {
                                //如果失败，添加请求信息
                                if (type) {
                                    data.request = options;
                                }
                                var ret = handler.call(responseInterceptor, data, Promise);
                                data = ret === undefined ? data : ret;
                            }
                            if (!isPromise(data)) {
                                data = Promise[type === 0 ? "resolve" : "reject"](data);
                            }
                            data.then(function (d) {
                                resolve(d);
                            }).catch(function (e) {
                                reject(e);
                            });
                        });
                    }

                    function onerror(e) {
                        e.engine = engine;
                        onresult(responseInterceptor.onerror, e, -1);
                    }

                    function Err(msg, status) {
                        this.message = msg;
                        this.status = status;
                    }

                    engine.onload = function () {
                        // The xhr of IE9 has not response filed
                        var response = engine.response || engine.responseText;
                        if (options.parseJson && (engine.getResponseHeader(contentType) || "").indexOf("json") !== -1
                        // Some third engine implementation may transform the response text to json object automatically,
                        // so we should test the type of response before transforming it
                        && !utils.isObject(response)) {
                            response = JSON.parse(response);
                        }
                        var headers = {};
                        var items = (engine.getAllResponseHeaders() || "").split("\r\n");
                        items.pop();
                        items.forEach(function (e) {
                            var key = e.split(":")[0];
                            headers[key] = engine.getResponseHeader(key);
                        });
                        var status = engine.status;
                        var statusText = engine.statusText;
                        var data = {data: response, headers: headers, status: status, statusText: statusText};
                        // The _response filed of engine is set in  adapter which be called in engine-wrapper.js
                        utils.merge(data, engine._response);
                        if (status >= 200 && status < 300 || status === 304) {
                            data.engine = engine;
                            data.request = options;
                            onresult(responseInterceptor.handler, data, 0);
                        } else {
                            var e = new Err(statusText, status);
                            e.response = data;
                            onerror(e);
                        }
                    };

                    engine.onerror = function (e) {
                        onerror(new Err(e.msg || "Network Error", 0));
                    };

                    engine.ontimeout = function () {
                        onerror(new Err("timeout [ " + engine.timeout + "ms ]", 1));
                    };
                    engine._options = options;
                    setTimeout(function () {
                        engine.send(isGet ? null : data);
                    }, 0);
                }

                enqueueIfLocked(requestInterceptor.p, function () {
                    utils.merge(options, _this.config);
                    var headers = options.headers;
                    headers[contentType] = headers[contentType] || headers[contentTypeLowerCase] || "";
                    delete headers[contentTypeLowerCase];
                    options.body = data || options.body;
                    url = utils.trim(url || "");
                    options.method = options.method.toUpperCase();
                    options.url = url;
                    var ret = options;
                    if (requestInterceptorHandler) {
                        ret = requestInterceptorHandler.call(requestInterceptor, options, Promise) || options;
                    }
                    if (!isPromise(ret)) {
                        ret = Promise.resolve(ret);
                    }
                    ret.then(function (d) {
                        //if options continue
                        if (d === options) {
                            makeRequest(d);
                        } else {
                            resolve(d);
                        }
                    }, function (err) {
                        reject(err);
                    });
                });
            });
            promise.engine = engine;
            return promise;
        }
    }, {
        key: "all",
        value: function all(promises) {
            return Promise.all(promises);
        }
    }, {
        key: "spread",
        value: function spread(callback) {
            return function (arr) {
                return callback.apply(null, arr);
            };
        }
    }, {
        key: "lock",
        value: function lock() {
            this.interceptors.request.lock();
        }
    }, {
        key: "unlock",
        value: function unlock() {
            this.interceptors.request.unlock();
        }
    }]);

    return Fly;
}();

//For typeScript


        Fly.default = Fly;

["get", "post", "put", "patch", "head", "delete"].forEach(function (e) {
    Fly.prototype[e] = function (url, data, option) {
        return this.request(url, data, utils.merge({ method: e }, option));
    };
});
// Learn more about keep-loader: https://github.com/wendux/keep-loader
;
module.exports = Fly;

/***/ })
/******/ ]);
});

/***/ }),
/* 7 */
/***/ (function(module, exports, __webpack_require__) {

/* WEBPACK VAR INJECTION */(function(global) {var require;var require;(function(f){if(true){module.exports=f()}else if(typeof define==="function"&&define.amd){define([],f)}else{var g;if(typeof window!=="undefined"){g=window}else if(typeof global!=="undefined"){g=global}else if(typeof self!=="undefined"){g=self}else{g=this}g.adapter = f()}})(function(){var define,module,exports;return (function e(t,n,r){function s(o,u){if(!n[o]){if(!t[o]){var a=typeof require=="function"&&require;if(!u&&a)return require(o,!0);if(i)return i(o,!0);var f=new Error("Cannot find module '"+o+"'");throw f.code="MODULE_NOT_FOUND",f}var l=n[o]={exports:{}};t[o][0].call(l.exports,function(e){var n=t[o][1][e];return s(n?n:e)},l,l.exports,e,t,n,r)}return n[o].exports}var i=typeof require=="function"&&require;for(var o=0;o<r.length;o++)s(r[o]);return s})({1:[function(require,module,exports){
/*
 *  Copyright (c) 2017 The WebRTC project authors. All Rights Reserved.
 *
 *  Use of this source code is governed by a BSD-style license
 *  that can be found in the LICENSE file in the root of the source
 *  tree.
 */
 /* eslint-env node */
'use strict';

var SDPUtils = require('sdp');

function fixStatsType(stat) {
  return {
    inboundrtp: 'inbound-rtp',
    outboundrtp: 'outbound-rtp',
    candidatepair: 'candidate-pair',
    localcandidate: 'local-candidate',
    remotecandidate: 'remote-candidate'
  }[stat.type] || stat.type;
}

function writeMediaSection(transceiver, caps, type, stream, dtlsRole) {
  var sdp = SDPUtils.writeRtpDescription(transceiver.kind, caps);

  // Map ICE parameters (ufrag, pwd) to SDP.
  sdp += SDPUtils.writeIceParameters(
      transceiver.iceGatherer.getLocalParameters());

  // Map DTLS parameters to SDP.
  sdp += SDPUtils.writeDtlsParameters(
      transceiver.dtlsTransport.getLocalParameters(),
      type === 'offer' ? 'actpass' : dtlsRole || 'active');

  sdp += 'a=mid:' + transceiver.mid + '\r\n';

  if (transceiver.rtpSender && transceiver.rtpReceiver) {
    sdp += 'a=sendrecv\r\n';
  } else if (transceiver.rtpSender) {
    sdp += 'a=sendonly\r\n';
  } else if (transceiver.rtpReceiver) {
    sdp += 'a=recvonly\r\n';
  } else {
    sdp += 'a=inactive\r\n';
  }

  if (transceiver.rtpSender) {
    var trackId = transceiver.rtpSender._initialTrackId ||
        transceiver.rtpSender.track.id;
    transceiver.rtpSender._initialTrackId = trackId;
    // spec.
    var msid = 'msid:' + (stream ? stream.id : '-') + ' ' +
        trackId + '\r\n';
    sdp += 'a=' + msid;
    // for Chrome. Legacy should no longer be required.
    sdp += 'a=ssrc:' + transceiver.sendEncodingParameters[0].ssrc +
        ' ' + msid;

    // RTX
    if (transceiver.sendEncodingParameters[0].rtx) {
      sdp += 'a=ssrc:' + transceiver.sendEncodingParameters[0].rtx.ssrc +
          ' ' + msid;
      sdp += 'a=ssrc-group:FID ' +
          transceiver.sendEncodingParameters[0].ssrc + ' ' +
          transceiver.sendEncodingParameters[0].rtx.ssrc +
          '\r\n';
    }
  }
  // FIXME: this should be written by writeRtpDescription.
  sdp += 'a=ssrc:' + transceiver.sendEncodingParameters[0].ssrc +
      ' cname:' + SDPUtils.localCName + '\r\n';
  if (transceiver.rtpSender && transceiver.sendEncodingParameters[0].rtx) {
    sdp += 'a=ssrc:' + transceiver.sendEncodingParameters[0].rtx.ssrc +
        ' cname:' + SDPUtils.localCName + '\r\n';
  }
  return sdp;
}

// Edge does not like
// 1) stun: filtered after 14393 unless ?transport=udp is present
// 2) turn: that does not have all of turn:host:port?transport=udp
// 3) turn: with ipv6 addresses
// 4) turn: occurring muliple times
function filterIceServers(iceServers, edgeVersion) {
  var hasTurn = false;
  iceServers = JSON.parse(JSON.stringify(iceServers));
  return iceServers.filter(function(server) {
    if (server && (server.urls || server.url)) {
      var urls = server.urls || server.url;
      if (server.url && !server.urls) {
        console.warn('RTCIceServer.url is deprecated! Use urls instead.');
      }
      var isString = typeof urls === 'string';
      if (isString) {
        urls = [urls];
      }
      urls = urls.filter(function(url) {
        var validTurn = url.indexOf('turn:') === 0 &&
            url.indexOf('transport=udp') !== -1 &&
            url.indexOf('turn:[') === -1 &&
            !hasTurn;

        if (validTurn) {
          hasTurn = true;
          return true;
        }
        return url.indexOf('stun:') === 0 && edgeVersion >= 14393 &&
            url.indexOf('?transport=udp') === -1;
      });

      delete server.url;
      server.urls = isString ? urls[0] : urls;
      return !!urls.length;
    }
  });
}

// Determines the intersection of local and remote capabilities.
function getCommonCapabilities(localCapabilities, remoteCapabilities) {
  var commonCapabilities = {
    codecs: [],
    headerExtensions: [],
    fecMechanisms: []
  };

  var findCodecByPayloadType = function(pt, codecs) {
    pt = parseInt(pt, 10);
    for (var i = 0; i < codecs.length; i++) {
      if (codecs[i].payloadType === pt ||
          codecs[i].preferredPayloadType === pt) {
        return codecs[i];
      }
    }
  };

  var rtxCapabilityMatches = function(lRtx, rRtx, lCodecs, rCodecs) {
    var lCodec = findCodecByPayloadType(lRtx.parameters.apt, lCodecs);
    var rCodec = findCodecByPayloadType(rRtx.parameters.apt, rCodecs);
    return lCodec && rCodec &&
        lCodec.name.toLowerCase() === rCodec.name.toLowerCase();
  };

  localCapabilities.codecs.forEach(function(lCodec) {
    for (var i = 0; i < remoteCapabilities.codecs.length; i++) {
      var rCodec = remoteCapabilities.codecs[i];
      if (lCodec.name.toLowerCase() === rCodec.name.toLowerCase() &&
          lCodec.clockRate === rCodec.clockRate) {
        if (lCodec.name.toLowerCase() === 'rtx' &&
            lCodec.parameters && rCodec.parameters.apt) {
          // for RTX we need to find the local rtx that has a apt
          // which points to the same local codec as the remote one.
          if (!rtxCapabilityMatches(lCodec, rCodec,
              localCapabilities.codecs, remoteCapabilities.codecs)) {
            continue;
          }
        }
        rCodec = JSON.parse(JSON.stringify(rCodec)); // deepcopy
        // number of channels is the highest common number of channels
        rCodec.numChannels = Math.min(lCodec.numChannels,
            rCodec.numChannels);
        // push rCodec so we reply with offerer payload type
        commonCapabilities.codecs.push(rCodec);

        // determine common feedback mechanisms
        rCodec.rtcpFeedback = rCodec.rtcpFeedback.filter(function(fb) {
          for (var j = 0; j < lCodec.rtcpFeedback.length; j++) {
            if (lCodec.rtcpFeedback[j].type === fb.type &&
                lCodec.rtcpFeedback[j].parameter === fb.parameter) {
              return true;
            }
          }
          return false;
        });
        // FIXME: also need to determine .parameters
        //  see https://github.com/openpeer/ortc/issues/569
        break;
      }
    }
  });

  localCapabilities.headerExtensions.forEach(function(lHeaderExtension) {
    for (var i = 0; i < remoteCapabilities.headerExtensions.length;
         i++) {
      var rHeaderExtension = remoteCapabilities.headerExtensions[i];
      if (lHeaderExtension.uri === rHeaderExtension.uri) {
        commonCapabilities.headerExtensions.push(rHeaderExtension);
        break;
      }
    }
  });

  // FIXME: fecMechanisms
  return commonCapabilities;
}

// is action=setLocalDescription with type allowed in signalingState
function isActionAllowedInSignalingState(action, type, signalingState) {
  return {
    offer: {
      setLocalDescription: ['stable', 'have-local-offer'],
      setRemoteDescription: ['stable', 'have-remote-offer']
    },
    answer: {
      setLocalDescription: ['have-remote-offer', 'have-local-pranswer'],
      setRemoteDescription: ['have-local-offer', 'have-remote-pranswer']
    }
  }[type][action].indexOf(signalingState) !== -1;
}

function maybeAddCandidate(iceTransport, candidate) {
  // Edge's internal representation adds some fields therefore
  // not all fieldѕ are taken into account.
  var alreadyAdded = iceTransport.getRemoteCandidates()
      .find(function(remoteCandidate) {
        return candidate.foundation === remoteCandidate.foundation &&
            candidate.ip === remoteCandidate.ip &&
            candidate.port === remoteCandidate.port &&
            candidate.priority === remoteCandidate.priority &&
            candidate.protocol === remoteCandidate.protocol &&
            candidate.type === remoteCandidate.type;
      });
  if (!alreadyAdded) {
    iceTransport.addRemoteCandidate(candidate);
  }
  return !alreadyAdded;
}


function makeError(name, description) {
  var e = new Error(description);
  e.name = name;
  // legacy error codes from https://heycam.github.io/webidl/#idl-DOMException-error-names
  e.code = {
    NotSupportedError: 9,
    InvalidStateError: 11,
    InvalidAccessError: 15,
    TypeError: undefined,
    OperationError: undefined
  }[name];
  return e;
}

module.exports = function(window, edgeVersion) {
  // https://w3c.github.io/mediacapture-main/#mediastream
  // Helper function to add the track to the stream and
  // dispatch the event ourselves.
  function addTrackToStreamAndFireEvent(track, stream) {
    stream.addTrack(track);
    stream.dispatchEvent(new window.MediaStreamTrackEvent('addtrack',
        {track: track}));
  }

  function removeTrackFromStreamAndFireEvent(track, stream) {
    stream.removeTrack(track);
    stream.dispatchEvent(new window.MediaStreamTrackEvent('removetrack',
        {track: track}));
  }

  function fireAddTrack(pc, track, receiver, streams) {
    var trackEvent = new Event('track');
    trackEvent.track = track;
    trackEvent.receiver = receiver;
    trackEvent.transceiver = {receiver: receiver};
    trackEvent.streams = streams;
    window.setTimeout(function() {
      pc._dispatchEvent('track', trackEvent);
    });
  }

  var RTCPeerConnection = function(config) {
    var pc = this;

    var _eventTarget = document.createDocumentFragment();
    ['addEventListener', 'removeEventListener', 'dispatchEvent']
        .forEach(function(method) {
          pc[method] = _eventTarget[method].bind(_eventTarget);
        });

    this.canTrickleIceCandidates = null;

    this.needNegotiation = false;

    this.localStreams = [];
    this.remoteStreams = [];

    this._localDescription = null;
    this._remoteDescription = null;

    this.signalingState = 'stable';
    this.iceConnectionState = 'new';
    this.connectionState = 'new';
    this.iceGatheringState = 'new';

    config = JSON.parse(JSON.stringify(config || {}));

    this.usingBundle = config.bundlePolicy === 'max-bundle';
    if (config.rtcpMuxPolicy === 'negotiate') {
      throw(makeError('NotSupportedError',
          'rtcpMuxPolicy \'negotiate\' is not supported'));
    } else if (!config.rtcpMuxPolicy) {
      config.rtcpMuxPolicy = 'require';
    }

    switch (config.iceTransportPolicy) {
      case 'all':
      case 'relay':
        break;
      default:
        config.iceTransportPolicy = 'all';
        break;
    }

    switch (config.bundlePolicy) {
      case 'balanced':
      case 'max-compat':
      case 'max-bundle':
        break;
      default:
        config.bundlePolicy = 'balanced';
        break;
    }

    config.iceServers = filterIceServers(config.iceServers || [], edgeVersion);

    this._iceGatherers = [];
    if (config.iceCandidatePoolSize) {
      for (var i = config.iceCandidatePoolSize; i > 0; i--) {
        this._iceGatherers.push(new window.RTCIceGatherer({
          iceServers: config.iceServers,
          gatherPolicy: config.iceTransportPolicy
        }));
      }
    } else {
      config.iceCandidatePoolSize = 0;
    }

    this._config = config;

    // per-track iceGathers, iceTransports, dtlsTransports, rtpSenders, ...
    // everything that is needed to describe a SDP m-line.
    this.transceivers = [];

    this._sdpSessionId = SDPUtils.generateSessionId();
    this._sdpSessionVersion = 0;

    this._dtlsRole = undefined; // role for a=setup to use in answers.

    this._isClosed = false;
  };

  Object.defineProperty(RTCPeerConnection.prototype, 'localDescription', {
    configurable: true,
    get: function() {
      return this._localDescription;
    }
  });
  Object.defineProperty(RTCPeerConnection.prototype, 'remoteDescription', {
    configurable: true,
    get: function() {
      return this._remoteDescription;
    }
  });

  // set up event handlers on prototype
  RTCPeerConnection.prototype.onicecandidate = null;
  RTCPeerConnection.prototype.onaddstream = null;
  RTCPeerConnection.prototype.ontrack = null;
  RTCPeerConnection.prototype.onremovestream = null;
  RTCPeerConnection.prototype.onsignalingstatechange = null;
  RTCPeerConnection.prototype.oniceconnectionstatechange = null;
  RTCPeerConnection.prototype.onconnectionstatechange = null;
  RTCPeerConnection.prototype.onicegatheringstatechange = null;
  RTCPeerConnection.prototype.onnegotiationneeded = null;
  RTCPeerConnection.prototype.ondatachannel = null;

  RTCPeerConnection.prototype._dispatchEvent = function(name, event) {
    if (this._isClosed) {
      return;
    }
    this.dispatchEvent(event);
    if (typeof this['on' + name] === 'function') {
      this['on' + name](event);
    }
  };

  RTCPeerConnection.prototype._emitGatheringStateChange = function() {
    var event = new Event('icegatheringstatechange');
    this._dispatchEvent('icegatheringstatechange', event);
  };

  RTCPeerConnection.prototype.getConfiguration = function() {
    return this._config;
  };

  RTCPeerConnection.prototype.getLocalStreams = function() {
    return this.localStreams;
  };

  RTCPeerConnection.prototype.getRemoteStreams = function() {
    return this.remoteStreams;
  };

  // internal helper to create a transceiver object.
  // (which is not yet the same as the WebRTC 1.0 transceiver)
  RTCPeerConnection.prototype._createTransceiver = function(kind, doNotAdd) {
    var hasBundleTransport = this.transceivers.length > 0;
    var transceiver = {
      track: null,
      iceGatherer: null,
      iceTransport: null,
      dtlsTransport: null,
      localCapabilities: null,
      remoteCapabilities: null,
      rtpSender: null,
      rtpReceiver: null,
      kind: kind,
      mid: null,
      sendEncodingParameters: null,
      recvEncodingParameters: null,
      stream: null,
      associatedRemoteMediaStreams: [],
      wantReceive: true
    };
    if (this.usingBundle && hasBundleTransport) {
      transceiver.iceTransport = this.transceivers[0].iceTransport;
      transceiver.dtlsTransport = this.transceivers[0].dtlsTransport;
    } else {
      var transports = this._createIceAndDtlsTransports();
      transceiver.iceTransport = transports.iceTransport;
      transceiver.dtlsTransport = transports.dtlsTransport;
    }
    if (!doNotAdd) {
      this.transceivers.push(transceiver);
    }
    return transceiver;
  };

  RTCPeerConnection.prototype.addTrack = function(track, stream) {
    if (this._isClosed) {
      throw makeError('InvalidStateError',
          'Attempted to call addTrack on a closed peerconnection.');
    }

    var alreadyExists = this.transceivers.find(function(s) {
      return s.track === track;
    });

    if (alreadyExists) {
      throw makeError('InvalidAccessError', 'Track already exists.');
    }

    var transceiver;
    for (var i = 0; i < this.transceivers.length; i++) {
      if (!this.transceivers[i].track &&
          this.transceivers[i].kind === track.kind) {
        transceiver = this.transceivers[i];
      }
    }
    if (!transceiver) {
      transceiver = this._createTransceiver(track.kind);
    }

    this._maybeFireNegotiationNeeded();

    if (this.localStreams.indexOf(stream) === -1) {
      this.localStreams.push(stream);
    }

    transceiver.track = track;
    transceiver.stream = stream;
    transceiver.rtpSender = new window.RTCRtpSender(track,
        transceiver.dtlsTransport);
    return transceiver.rtpSender;
  };

  RTCPeerConnection.prototype.addStream = function(stream) {
    var pc = this;
    if (edgeVersion >= 15025) {
      stream.getTracks().forEach(function(track) {
        pc.addTrack(track, stream);
      });
    } else {
      // Clone is necessary for local demos mostly, attaching directly
      // to two different senders does not work (build 10547).
      // Fixed in 15025 (or earlier)
      var clonedStream = stream.clone();
      stream.getTracks().forEach(function(track, idx) {
        var clonedTrack = clonedStream.getTracks()[idx];
        track.addEventListener('enabled', function(event) {
          clonedTrack.enabled = event.enabled;
        });
      });
      clonedStream.getTracks().forEach(function(track) {
        pc.addTrack(track, clonedStream);
      });
    }
  };

  RTCPeerConnection.prototype.removeTrack = function(sender) {
    if (this._isClosed) {
      throw makeError('InvalidStateError',
          'Attempted to call removeTrack on a closed peerconnection.');
    }

    if (!(sender instanceof window.RTCRtpSender)) {
      throw new TypeError('Argument 1 of RTCPeerConnection.removeTrack ' +
          'does not implement interface RTCRtpSender.');
    }

    var transceiver = this.transceivers.find(function(t) {
      return t.rtpSender === sender;
    });

    if (!transceiver) {
      throw makeError('InvalidAccessError',
          'Sender was not created by this connection.');
    }
    var stream = transceiver.stream;

    transceiver.rtpSender.stop();
    transceiver.rtpSender = null;
    transceiver.track = null;
    transceiver.stream = null;

    // remove the stream from the set of local streams
    var localStreams = this.transceivers.map(function(t) {
      return t.stream;
    });
    if (localStreams.indexOf(stream) === -1 &&
        this.localStreams.indexOf(stream) > -1) {
      this.localStreams.splice(this.localStreams.indexOf(stream), 1);
    }

    this._maybeFireNegotiationNeeded();
  };

  RTCPeerConnection.prototype.removeStream = function(stream) {
    var pc = this;
    stream.getTracks().forEach(function(track) {
      var sender = pc.getSenders().find(function(s) {
        return s.track === track;
      });
      if (sender) {
        pc.removeTrack(sender);
      }
    });
  };

  RTCPeerConnection.prototype.getSenders = function() {
    return this.transceivers.filter(function(transceiver) {
      return !!transceiver.rtpSender;
    })
    .map(function(transceiver) {
      return transceiver.rtpSender;
    });
  };

  RTCPeerConnection.prototype.getReceivers = function() {
    return this.transceivers.filter(function(transceiver) {
      return !!transceiver.rtpReceiver;
    })
    .map(function(transceiver) {
      return transceiver.rtpReceiver;
    });
  };


  RTCPeerConnection.prototype._createIceGatherer = function(sdpMLineIndex,
      usingBundle) {
    var pc = this;
    if (usingBundle && sdpMLineIndex > 0) {
      return this.transceivers[0].iceGatherer;
    } else if (this._iceGatherers.length) {
      return this._iceGatherers.shift();
    }
    var iceGatherer = new window.RTCIceGatherer({
      iceServers: this._config.iceServers,
      gatherPolicy: this._config.iceTransportPolicy
    });
    Object.defineProperty(iceGatherer, 'state',
        {value: 'new', writable: true}
    );

    this.transceivers[sdpMLineIndex].bufferedCandidateEvents = [];
    this.transceivers[sdpMLineIndex].bufferCandidates = function(event) {
      var end = !event.candidate || Object.keys(event.candidate).length === 0;
      // polyfill since RTCIceGatherer.state is not implemented in
      // Edge 10547 yet.
      iceGatherer.state = end ? 'completed' : 'gathering';
      if (pc.transceivers[sdpMLineIndex].bufferedCandidateEvents !== null) {
        pc.transceivers[sdpMLineIndex].bufferedCandidateEvents.push(event);
      }
    };
    iceGatherer.addEventListener('localcandidate',
      this.transceivers[sdpMLineIndex].bufferCandidates);
    return iceGatherer;
  };

  // start gathering from an RTCIceGatherer.
  RTCPeerConnection.prototype._gather = function(mid, sdpMLineIndex) {
    var pc = this;
    var iceGatherer = this.transceivers[sdpMLineIndex].iceGatherer;
    if (iceGatherer.onlocalcandidate) {
      return;
    }
    var bufferedCandidateEvents =
      this.transceivers[sdpMLineIndex].bufferedCandidateEvents;
    this.transceivers[sdpMLineIndex].bufferedCandidateEvents = null;
    iceGatherer.removeEventListener('localcandidate',
      this.transceivers[sdpMLineIndex].bufferCandidates);
    iceGatherer.onlocalcandidate = function(evt) {
      if (pc.usingBundle && sdpMLineIndex > 0) {
        // if we know that we use bundle we can drop candidates with
        // ѕdpMLineIndex > 0. If we don't do this then our state gets
        // confused since we dispose the extra ice gatherer.
        return;
      }
      var event = new Event('icecandidate');
      event.candidate = {sdpMid: mid, sdpMLineIndex: sdpMLineIndex};

      var cand = evt.candidate;
      // Edge emits an empty object for RTCIceCandidateComplete‥
      var end = !cand || Object.keys(cand).length === 0;
      if (end) {
        // polyfill since RTCIceGatherer.state is not implemented in
        // Edge 10547 yet.
        if (iceGatherer.state === 'new' || iceGatherer.state === 'gathering') {
          iceGatherer.state = 'completed';
        }
      } else {
        if (iceGatherer.state === 'new') {
          iceGatherer.state = 'gathering';
        }
        // RTCIceCandidate doesn't have a component, needs to be added
        cand.component = 1;
        // also the usernameFragment. TODO: update SDP to take both variants.
        cand.ufrag = iceGatherer.getLocalParameters().usernameFragment;

        var serializedCandidate = SDPUtils.writeCandidate(cand);
        event.candidate = Object.assign(event.candidate,
            SDPUtils.parseCandidate(serializedCandidate));

        event.candidate.candidate = serializedCandidate;
        event.candidate.toJSON = function() {
          return {
            candidate: event.candidate.candidate,
            sdpMid: event.candidate.sdpMid,
            sdpMLineIndex: event.candidate.sdpMLineIndex,
            usernameFragment: event.candidate.usernameFragment
          };
        };
      }

      // update local description.
      var sections = SDPUtils.getMediaSections(pc._localDescription.sdp);
      if (!end) {
        sections[event.candidate.sdpMLineIndex] +=
            'a=' + event.candidate.candidate + '\r\n';
      } else {
        sections[event.candidate.sdpMLineIndex] +=
            'a=end-of-candidates\r\n';
      }
      pc._localDescription.sdp =
          SDPUtils.getDescription(pc._localDescription.sdp) +
          sections.join('');
      var complete = pc.transceivers.every(function(transceiver) {
        return transceiver.iceGatherer &&
            transceiver.iceGatherer.state === 'completed';
      });

      if (pc.iceGatheringState !== 'gathering') {
        pc.iceGatheringState = 'gathering';
        pc._emitGatheringStateChange();
      }

      // Emit candidate. Also emit null candidate when all gatherers are
      // complete.
      if (!end) {
        pc._dispatchEvent('icecandidate', event);
      }
      if (complete) {
        pc._dispatchEvent('icecandidate', new Event('icecandidate'));
        pc.iceGatheringState = 'complete';
        pc._emitGatheringStateChange();
      }
    };

    // emit already gathered candidates.
    window.setTimeout(function() {
      bufferedCandidateEvents.forEach(function(e) {
        iceGatherer.onlocalcandidate(e);
      });
    }, 0);
  };

  // Create ICE transport and DTLS transport.
  RTCPeerConnection.prototype._createIceAndDtlsTransports = function() {
    var pc = this;
    var iceTransport = new window.RTCIceTransport(null);
    iceTransport.onicestatechange = function() {
      pc._updateIceConnectionState();
      pc._updateConnectionState();
    };

    var dtlsTransport = new window.RTCDtlsTransport(iceTransport);
    dtlsTransport.ondtlsstatechange = function() {
      pc._updateConnectionState();
    };
    dtlsTransport.onerror = function() {
      // onerror does not set state to failed by itself.
      Object.defineProperty(dtlsTransport, 'state',
          {value: 'failed', writable: true});
      pc._updateConnectionState();
    };

    return {
      iceTransport: iceTransport,
      dtlsTransport: dtlsTransport
    };
  };

  // Destroy ICE gatherer, ICE transport and DTLS transport.
  // Without triggering the callbacks.
  RTCPeerConnection.prototype._disposeIceAndDtlsTransports = function(
      sdpMLineIndex) {
    var iceGatherer = this.transceivers[sdpMLineIndex].iceGatherer;
    if (iceGatherer) {
      delete iceGatherer.onlocalcandidate;
      delete this.transceivers[sdpMLineIndex].iceGatherer;
    }
    var iceTransport = this.transceivers[sdpMLineIndex].iceTransport;
    if (iceTransport) {
      delete iceTransport.onicestatechange;
      delete this.transceivers[sdpMLineIndex].iceTransport;
    }
    var dtlsTransport = this.transceivers[sdpMLineIndex].dtlsTransport;
    if (dtlsTransport) {
      delete dtlsTransport.ondtlsstatechange;
      delete dtlsTransport.onerror;
      delete this.transceivers[sdpMLineIndex].dtlsTransport;
    }
  };

  // Start the RTP Sender and Receiver for a transceiver.
  RTCPeerConnection.prototype._transceive = function(transceiver,
      send, recv) {
    var params = getCommonCapabilities(transceiver.localCapabilities,
        transceiver.remoteCapabilities);
    if (send && transceiver.rtpSender) {
      params.encodings = transceiver.sendEncodingParameters;
      params.rtcp = {
        cname: SDPUtils.localCName,
        compound: transceiver.rtcpParameters.compound
      };
      if (transceiver.recvEncodingParameters.length) {
        params.rtcp.ssrc = transceiver.recvEncodingParameters[0].ssrc;
      }
      transceiver.rtpSender.send(params);
    }
    if (recv && transceiver.rtpReceiver && params.codecs.length > 0) {
      // remove RTX field in Edge 14942
      if (transceiver.kind === 'video'
          && transceiver.recvEncodingParameters
          && edgeVersion < 15019) {
        transceiver.recvEncodingParameters.forEach(function(p) {
          delete p.rtx;
        });
      }
      if (transceiver.recvEncodingParameters.length) {
        params.encodings = transceiver.recvEncodingParameters;
      } else {
        params.encodings = [{}];
      }
      params.rtcp = {
        compound: transceiver.rtcpParameters.compound
      };
      if (transceiver.rtcpParameters.cname) {
        params.rtcp.cname = transceiver.rtcpParameters.cname;
      }
      if (transceiver.sendEncodingParameters.length) {
        params.rtcp.ssrc = transceiver.sendEncodingParameters[0].ssrc;
      }
      transceiver.rtpReceiver.receive(params);
    }
  };

  RTCPeerConnection.prototype.setLocalDescription = function(description) {
    var pc = this;

    // Note: pranswer is not supported.
    if (['offer', 'answer'].indexOf(description.type) === -1) {
      return Promise.reject(makeError('TypeError',
          'Unsupported type "' + description.type + '"'));
    }

    if (!isActionAllowedInSignalingState('setLocalDescription',
        description.type, pc.signalingState) || pc._isClosed) {
      return Promise.reject(makeError('InvalidStateError',
          'Can not set local ' + description.type +
          ' in state ' + pc.signalingState));
    }

    var sections;
    var sessionpart;
    if (description.type === 'offer') {
      // VERY limited support for SDP munging. Limited to:
      // * changing the order of codecs
      sections = SDPUtils.splitSections(description.sdp);
      sessionpart = sections.shift();
      sections.forEach(function(mediaSection, sdpMLineIndex) {
        var caps = SDPUtils.parseRtpParameters(mediaSection);
        pc.transceivers[sdpMLineIndex].localCapabilities = caps;
      });

      pc.transceivers.forEach(function(transceiver, sdpMLineIndex) {
        pc._gather(transceiver.mid, sdpMLineIndex);
      });
    } else if (description.type === 'answer') {
      sections = SDPUtils.splitSections(pc._remoteDescription.sdp);
      sessionpart = sections.shift();
      var isIceLite = SDPUtils.matchPrefix(sessionpart,
          'a=ice-lite').length > 0;
      sections.forEach(function(mediaSection, sdpMLineIndex) {
        var transceiver = pc.transceivers[sdpMLineIndex];
        var iceGatherer = transceiver.iceGatherer;
        var iceTransport = transceiver.iceTransport;
        var dtlsTransport = transceiver.dtlsTransport;
        var localCapabilities = transceiver.localCapabilities;
        var remoteCapabilities = transceiver.remoteCapabilities;

        // treat bundle-only as not-rejected.
        var rejected = SDPUtils.isRejected(mediaSection) &&
            SDPUtils.matchPrefix(mediaSection, 'a=bundle-only').length === 0;

        if (!rejected && !transceiver.rejected) {
          var remoteIceParameters = SDPUtils.getIceParameters(
              mediaSection, sessionpart);
          var remoteDtlsParameters = SDPUtils.getDtlsParameters(
              mediaSection, sessionpart);
          if (isIceLite) {
            remoteDtlsParameters.role = 'server';
          }

          if (!pc.usingBundle || sdpMLineIndex === 0) {
            pc._gather(transceiver.mid, sdpMLineIndex);
            if (iceTransport.state === 'new') {
              iceTransport.start(iceGatherer, remoteIceParameters,
                  isIceLite ? 'controlling' : 'controlled');
            }
            if (dtlsTransport.state === 'new') {
              dtlsTransport.start(remoteDtlsParameters);
            }
          }

          // Calculate intersection of capabilities.
          var params = getCommonCapabilities(localCapabilities,
              remoteCapabilities);

          // Start the RTCRtpSender. The RTCRtpReceiver for this
          // transceiver has already been started in setRemoteDescription.
          pc._transceive(transceiver,
              params.codecs.length > 0,
              false);
        }
      });
    }

    pc._localDescription = {
      type: description.type,
      sdp: description.sdp
    };
    if (description.type === 'offer') {
      pc._updateSignalingState('have-local-offer');
    } else {
      pc._updateSignalingState('stable');
    }

    return Promise.resolve();
  };

  RTCPeerConnection.prototype.setRemoteDescription = function(description) {
    var pc = this;

    // Note: pranswer is not supported.
    if (['offer', 'answer'].indexOf(description.type) === -1) {
      return Promise.reject(makeError('TypeError',
          'Unsupported type "' + description.type + '"'));
    }

    if (!isActionAllowedInSignalingState('setRemoteDescription',
        description.type, pc.signalingState) || pc._isClosed) {
      return Promise.reject(makeError('InvalidStateError',
          'Can not set remote ' + description.type +
          ' in state ' + pc.signalingState));
    }

    var streams = {};
    pc.remoteStreams.forEach(function(stream) {
      streams[stream.id] = stream;
    });
    var receiverList = [];
    var sections = SDPUtils.splitSections(description.sdp);
    var sessionpart = sections.shift();
    var isIceLite = SDPUtils.matchPrefix(sessionpart,
        'a=ice-lite').length > 0;
    var usingBundle = SDPUtils.matchPrefix(sessionpart,
        'a=group:BUNDLE ').length > 0;
    pc.usingBundle = usingBundle;
    var iceOptions = SDPUtils.matchPrefix(sessionpart,
        'a=ice-options:')[0];
    if (iceOptions) {
      pc.canTrickleIceCandidates = iceOptions.substr(14).split(' ')
          .indexOf('trickle') >= 0;
    } else {
      pc.canTrickleIceCandidates = false;
    }

    sections.forEach(function(mediaSection, sdpMLineIndex) {
      var lines = SDPUtils.splitLines(mediaSection);
      var kind = SDPUtils.getKind(mediaSection);
      // treat bundle-only as not-rejected.
      var rejected = SDPUtils.isRejected(mediaSection) &&
          SDPUtils.matchPrefix(mediaSection, 'a=bundle-only').length === 0;
      var protocol = lines[0].substr(2).split(' ')[2];

      var direction = SDPUtils.getDirection(mediaSection, sessionpart);
      var remoteMsid = SDPUtils.parseMsid(mediaSection);

      var mid = SDPUtils.getMid(mediaSection) || SDPUtils.generateIdentifier();

      // Reject datachannels which are not implemented yet.
      if (rejected || (kind === 'application' && (protocol === 'DTLS/SCTP' ||
          protocol === 'UDP/DTLS/SCTP'))) {
        // TODO: this is dangerous in the case where a non-rejected m-line
        //     becomes rejected.
        pc.transceivers[sdpMLineIndex] = {
          mid: mid,
          kind: kind,
          protocol: protocol,
          rejected: true
        };
        return;
      }

      if (!rejected && pc.transceivers[sdpMLineIndex] &&
          pc.transceivers[sdpMLineIndex].rejected) {
        // recycle a rejected transceiver.
        pc.transceivers[sdpMLineIndex] = pc._createTransceiver(kind, true);
      }

      var transceiver;
      var iceGatherer;
      var iceTransport;
      var dtlsTransport;
      var rtpReceiver;
      var sendEncodingParameters;
      var recvEncodingParameters;
      var localCapabilities;

      var track;
      // FIXME: ensure the mediaSection has rtcp-mux set.
      var remoteCapabilities = SDPUtils.parseRtpParameters(mediaSection);
      var remoteIceParameters;
      var remoteDtlsParameters;
      if (!rejected) {
        remoteIceParameters = SDPUtils.getIceParameters(mediaSection,
            sessionpart);
        remoteDtlsParameters = SDPUtils.getDtlsParameters(mediaSection,
            sessionpart);
        remoteDtlsParameters.role = 'client';
      }
      recvEncodingParameters =
          SDPUtils.parseRtpEncodingParameters(mediaSection);

      var rtcpParameters = SDPUtils.parseRtcpParameters(mediaSection);

      var isComplete = SDPUtils.matchPrefix(mediaSection,
          'a=end-of-candidates', sessionpart).length > 0;
      var cands = SDPUtils.matchPrefix(mediaSection, 'a=candidate:')
          .map(function(cand) {
            return SDPUtils.parseCandidate(cand);
          })
          .filter(function(cand) {
            return cand.component === 1;
          });

      // Check if we can use BUNDLE and dispose transports.
      if ((description.type === 'offer' || description.type === 'answer') &&
          !rejected && usingBundle && sdpMLineIndex > 0 &&
          pc.transceivers[sdpMLineIndex]) {
        pc._disposeIceAndDtlsTransports(sdpMLineIndex);
        pc.transceivers[sdpMLineIndex].iceGatherer =
            pc.transceivers[0].iceGatherer;
        pc.transceivers[sdpMLineIndex].iceTransport =
            pc.transceivers[0].iceTransport;
        pc.transceivers[sdpMLineIndex].dtlsTransport =
            pc.transceivers[0].dtlsTransport;
        if (pc.transceivers[sdpMLineIndex].rtpSender) {
          pc.transceivers[sdpMLineIndex].rtpSender.setTransport(
              pc.transceivers[0].dtlsTransport);
        }
        if (pc.transceivers[sdpMLineIndex].rtpReceiver) {
          pc.transceivers[sdpMLineIndex].rtpReceiver.setTransport(
              pc.transceivers[0].dtlsTransport);
        }
      }
      if (description.type === 'offer' && !rejected) {
        transceiver = pc.transceivers[sdpMLineIndex] ||
            pc._createTransceiver(kind);
        transceiver.mid = mid;

        if (!transceiver.iceGatherer) {
          transceiver.iceGatherer = pc._createIceGatherer(sdpMLineIndex,
              usingBundle);
        }

        if (cands.length && transceiver.iceTransport.state === 'new') {
          if (isComplete && (!usingBundle || sdpMLineIndex === 0)) {
            transceiver.iceTransport.setRemoteCandidates(cands);
          } else {
            cands.forEach(function(candidate) {
              maybeAddCandidate(transceiver.iceTransport, candidate);
            });
          }
        }

        localCapabilities = window.RTCRtpReceiver.getCapabilities(kind);

        // filter RTX until additional stuff needed for RTX is implemented
        // in adapter.js
        if (edgeVersion < 15019) {
          localCapabilities.codecs = localCapabilities.codecs.filter(
              function(codec) {
                return codec.name !== 'rtx';
              });
        }

        sendEncodingParameters = transceiver.sendEncodingParameters || [{
          ssrc: (2 * sdpMLineIndex + 2) * 1001
        }];

        // TODO: rewrite to use http://w3c.github.io/webrtc-pc/#set-associated-remote-streams
        var isNewTrack = false;
        if (direction === 'sendrecv' || direction === 'sendonly') {
          isNewTrack = !transceiver.rtpReceiver;
          rtpReceiver = transceiver.rtpReceiver ||
              new window.RTCRtpReceiver(transceiver.dtlsTransport, kind);

          if (isNewTrack) {
            var stream;
            track = rtpReceiver.track;
            // FIXME: does not work with Plan B.
            if (remoteMsid && remoteMsid.stream === '-') {
              // no-op. a stream id of '-' means: no associated stream.
            } else if (remoteMsid) {
              if (!streams[remoteMsid.stream]) {
                streams[remoteMsid.stream] = new window.MediaStream();
                Object.defineProperty(streams[remoteMsid.stream], 'id', {
                  get: function() {
                    return remoteMsid.stream;
                  }
                });
              }
              Object.defineProperty(track, 'id', {
                get: function() {
                  return remoteMsid.track;
                }
              });
              stream = streams[remoteMsid.stream];
            } else {
              if (!streams.default) {
                streams.default = new window.MediaStream();
              }
              stream = streams.default;
            }
            if (stream) {
              addTrackToStreamAndFireEvent(track, stream);
              transceiver.associatedRemoteMediaStreams.push(stream);
            }
            receiverList.push([track, rtpReceiver, stream]);
          }
        } else if (transceiver.rtpReceiver && transceiver.rtpReceiver.track) {
          transceiver.associatedRemoteMediaStreams.forEach(function(s) {
            var nativeTrack = s.getTracks().find(function(t) {
              return t.id === transceiver.rtpReceiver.track.id;
            });
            if (nativeTrack) {
              removeTrackFromStreamAndFireEvent(nativeTrack, s);
            }
          });
          transceiver.associatedRemoteMediaStreams = [];
        }

        transceiver.localCapabilities = localCapabilities;
        transceiver.remoteCapabilities = remoteCapabilities;
        transceiver.rtpReceiver = rtpReceiver;
        transceiver.rtcpParameters = rtcpParameters;
        transceiver.sendEncodingParameters = sendEncodingParameters;
        transceiver.recvEncodingParameters = recvEncodingParameters;

        // Start the RTCRtpReceiver now. The RTPSender is started in
        // setLocalDescription.
        pc._transceive(pc.transceivers[sdpMLineIndex],
            false,
            isNewTrack);
      } else if (description.type === 'answer' && !rejected) {
        transceiver = pc.transceivers[sdpMLineIndex];
        iceGatherer = transceiver.iceGatherer;
        iceTransport = transceiver.iceTransport;
        dtlsTransport = transceiver.dtlsTransport;
        rtpReceiver = transceiver.rtpReceiver;
        sendEncodingParameters = transceiver.sendEncodingParameters;
        localCapabilities = transceiver.localCapabilities;

        pc.transceivers[sdpMLineIndex].recvEncodingParameters =
            recvEncodingParameters;
        pc.transceivers[sdpMLineIndex].remoteCapabilities =
            remoteCapabilities;
        pc.transceivers[sdpMLineIndex].rtcpParameters = rtcpParameters;

        if (cands.length && iceTransport.state === 'new') {
          if ((isIceLite || isComplete) &&
              (!usingBundle || sdpMLineIndex === 0)) {
            iceTransport.setRemoteCandidates(cands);
          } else {
            cands.forEach(function(candidate) {
              maybeAddCandidate(transceiver.iceTransport, candidate);
            });
          }
        }

        if (!usingBundle || sdpMLineIndex === 0) {
          if (iceTransport.state === 'new') {
            iceTransport.start(iceGatherer, remoteIceParameters,
                'controlling');
          }
          if (dtlsTransport.state === 'new') {
            dtlsTransport.start(remoteDtlsParameters);
          }
        }

        pc._transceive(transceiver,
            direction === 'sendrecv' || direction === 'recvonly',
            direction === 'sendrecv' || direction === 'sendonly');

        // TODO: rewrite to use http://w3c.github.io/webrtc-pc/#set-associated-remote-streams
        if (rtpReceiver &&
            (direction === 'sendrecv' || direction === 'sendonly')) {
          track = rtpReceiver.track;
          if (remoteMsid) {
            if (!streams[remoteMsid.stream]) {
              streams[remoteMsid.stream] = new window.MediaStream();
            }
            addTrackToStreamAndFireEvent(track, streams[remoteMsid.stream]);
            receiverList.push([track, rtpReceiver, streams[remoteMsid.stream]]);
          } else {
            if (!streams.default) {
              streams.default = new window.MediaStream();
            }
            addTrackToStreamAndFireEvent(track, streams.default);
            receiverList.push([track, rtpReceiver, streams.default]);
          }
        } else {
          // FIXME: actually the receiver should be created later.
          delete transceiver.rtpReceiver;
        }
      }
    });

    if (pc._dtlsRole === undefined) {
      pc._dtlsRole = description.type === 'offer' ? 'active' : 'passive';
    }

    pc._remoteDescription = {
      type: description.type,
      sdp: description.sdp
    };
    if (description.type === 'offer') {
      pc._updateSignalingState('have-remote-offer');
    } else {
      pc._updateSignalingState('stable');
    }
    Object.keys(streams).forEach(function(sid) {
      var stream = streams[sid];
      if (stream.getTracks().length) {
        if (pc.remoteStreams.indexOf(stream) === -1) {
          pc.remoteStreams.push(stream);
          var event = new Event('addstream');
          event.stream = stream;
          window.setTimeout(function() {
            pc._dispatchEvent('addstream', event);
          });
        }

        receiverList.forEach(function(item) {
          var track = item[0];
          var receiver = item[1];
          if (stream.id !== item[2].id) {
            return;
          }
          fireAddTrack(pc, track, receiver, [stream]);
        });
      }
    });
    receiverList.forEach(function(item) {
      if (item[2]) {
        return;
      }
      fireAddTrack(pc, item[0], item[1], []);
    });

    // check whether addIceCandidate({}) was called within four seconds after
    // setRemoteDescription.
    window.setTimeout(function() {
      if (!(pc && pc.transceivers)) {
        return;
      }
      pc.transceivers.forEach(function(transceiver) {
        if (transceiver.iceTransport &&
            transceiver.iceTransport.state === 'new' &&
            transceiver.iceTransport.getRemoteCandidates().length > 0) {
          console.warn('Timeout for addRemoteCandidate. Consider sending ' +
              'an end-of-candidates notification');
          transceiver.iceTransport.addRemoteCandidate({});
        }
      });
    }, 4000);

    return Promise.resolve();
  };

  RTCPeerConnection.prototype.close = function() {
    this.transceivers.forEach(function(transceiver) {
      /* not yet
      if (transceiver.iceGatherer) {
        transceiver.iceGatherer.close();
      }
      */
      if (transceiver.iceTransport) {
        transceiver.iceTransport.stop();
      }
      if (transceiver.dtlsTransport) {
        transceiver.dtlsTransport.stop();
      }
      if (transceiver.rtpSender) {
        transceiver.rtpSender.stop();
      }
      if (transceiver.rtpReceiver) {
        transceiver.rtpReceiver.stop();
      }
    });
    // FIXME: clean up tracks, local streams, remote streams, etc
    this._isClosed = true;
    this._updateSignalingState('closed');
  };

  // Update the signaling state.
  RTCPeerConnection.prototype._updateSignalingState = function(newState) {
    this.signalingState = newState;
    var event = new Event('signalingstatechange');
    this._dispatchEvent('signalingstatechange', event);
  };

  // Determine whether to fire the negotiationneeded event.
  RTCPeerConnection.prototype._maybeFireNegotiationNeeded = function() {
    var pc = this;
    if (this.signalingState !== 'stable' || this.needNegotiation === true) {
      return;
    }
    this.needNegotiation = true;
    window.setTimeout(function() {
      if (pc.needNegotiation) {
        pc.needNegotiation = false;
        var event = new Event('negotiationneeded');
        pc._dispatchEvent('negotiationneeded', event);
      }
    }, 0);
  };

  // Update the ice connection state.
  RTCPeerConnection.prototype._updateIceConnectionState = function() {
    var newState;
    var states = {
      'new': 0,
      closed: 0,
      checking: 0,
      connected: 0,
      completed: 0,
      disconnected: 0,
      failed: 0
    };
    this.transceivers.forEach(function(transceiver) {
      states[transceiver.iceTransport.state]++;
    });

    newState = 'new';
    if (states.failed > 0) {
      newState = 'failed';
    } else if (states.checking > 0) {
      newState = 'checking';
    } else if (states.disconnected > 0) {
      newState = 'disconnected';
    } else if (states.new > 0) {
      newState = 'new';
    } else if (states.connected > 0) {
      newState = 'connected';
    } else if (states.completed > 0) {
      newState = 'completed';
    }

    if (newState !== this.iceConnectionState) {
      this.iceConnectionState = newState;
      var event = new Event('iceconnectionstatechange');
      this._dispatchEvent('iceconnectionstatechange', event);
    }
  };

  // Update the connection state.
  RTCPeerConnection.prototype._updateConnectionState = function() {
    var newState;
    var states = {
      'new': 0,
      closed: 0,
      connecting: 0,
      connected: 0,
      completed: 0,
      disconnected: 0,
      failed: 0
    };
    this.transceivers.forEach(function(transceiver) {
      states[transceiver.iceTransport.state]++;
      states[transceiver.dtlsTransport.state]++;
    });
    // ICETransport.completed and connected are the same for this purpose.
    states.connected += states.completed;

    newState = 'new';
    if (states.failed > 0) {
      newState = 'failed';
    } else if (states.connecting > 0) {
      newState = 'connecting';
    } else if (states.disconnected > 0) {
      newState = 'disconnected';
    } else if (states.new > 0) {
      newState = 'new';
    } else if (states.connected > 0) {
      newState = 'connected';
    }

    if (newState !== this.connectionState) {
      this.connectionState = newState;
      var event = new Event('connectionstatechange');
      this._dispatchEvent('connectionstatechange', event);
    }
  };

  RTCPeerConnection.prototype.createOffer = function() {
    var pc = this;

    if (pc._isClosed) {
      return Promise.reject(makeError('InvalidStateError',
          'Can not call createOffer after close'));
    }

    var numAudioTracks = pc.transceivers.filter(function(t) {
      return t.kind === 'audio';
    }).length;
    var numVideoTracks = pc.transceivers.filter(function(t) {
      return t.kind === 'video';
    }).length;

    // Determine number of audio and video tracks we need to send/recv.
    var offerOptions = arguments[0];
    if (offerOptions) {
      // Reject Chrome legacy constraints.
      if (offerOptions.mandatory || offerOptions.optional) {
        throw new TypeError(
            'Legacy mandatory/optional constraints not supported.');
      }
      if (offerOptions.offerToReceiveAudio !== undefined) {
        if (offerOptions.offerToReceiveAudio === true) {
          numAudioTracks = 1;
        } else if (offerOptions.offerToReceiveAudio === false) {
          numAudioTracks = 0;
        } else {
          numAudioTracks = offerOptions.offerToReceiveAudio;
        }
      }
      if (offerOptions.offerToReceiveVideo !== undefined) {
        if (offerOptions.offerToReceiveVideo === true) {
          numVideoTracks = 1;
        } else if (offerOptions.offerToReceiveVideo === false) {
          numVideoTracks = 0;
        } else {
          numVideoTracks = offerOptions.offerToReceiveVideo;
        }
      }
    }

    pc.transceivers.forEach(function(transceiver) {
      if (transceiver.kind === 'audio') {
        numAudioTracks--;
        if (numAudioTracks < 0) {
          transceiver.wantReceive = false;
        }
      } else if (transceiver.kind === 'video') {
        numVideoTracks--;
        if (numVideoTracks < 0) {
          transceiver.wantReceive = false;
        }
      }
    });

    // Create M-lines for recvonly streams.
    while (numAudioTracks > 0 || numVideoTracks > 0) {
      if (numAudioTracks > 0) {
        pc._createTransceiver('audio');
        numAudioTracks--;
      }
      if (numVideoTracks > 0) {
        pc._createTransceiver('video');
        numVideoTracks--;
      }
    }

    var sdp = SDPUtils.writeSessionBoilerplate(pc._sdpSessionId,
        pc._sdpSessionVersion++);
    pc.transceivers.forEach(function(transceiver, sdpMLineIndex) {
      // For each track, create an ice gatherer, ice transport,
      // dtls transport, potentially rtpsender and rtpreceiver.
      var track = transceiver.track;
      var kind = transceiver.kind;
      var mid = transceiver.mid || SDPUtils.generateIdentifier();
      transceiver.mid = mid;

      if (!transceiver.iceGatherer) {
        transceiver.iceGatherer = pc._createIceGatherer(sdpMLineIndex,
            pc.usingBundle);
      }

      var localCapabilities = window.RTCRtpSender.getCapabilities(kind);
      // filter RTX until additional stuff needed for RTX is implemented
      // in adapter.js
      if (edgeVersion < 15019) {
        localCapabilities.codecs = localCapabilities.codecs.filter(
            function(codec) {
              return codec.name !== 'rtx';
            });
      }
      localCapabilities.codecs.forEach(function(codec) {
        // work around https://bugs.chromium.org/p/webrtc/issues/detail?id=6552
        // by adding level-asymmetry-allowed=1
        if (codec.name === 'H264' &&
            codec.parameters['level-asymmetry-allowed'] === undefined) {
          codec.parameters['level-asymmetry-allowed'] = '1';
        }

        // for subsequent offers, we might have to re-use the payload
        // type of the last offer.
        if (transceiver.remoteCapabilities &&
            transceiver.remoteCapabilities.codecs) {
          transceiver.remoteCapabilities.codecs.forEach(function(remoteCodec) {
            if (codec.name.toLowerCase() === remoteCodec.name.toLowerCase() &&
                codec.clockRate === remoteCodec.clockRate) {
              codec.preferredPayloadType = remoteCodec.payloadType;
            }
          });
        }
      });
      localCapabilities.headerExtensions.forEach(function(hdrExt) {
        var remoteExtensions = transceiver.remoteCapabilities &&
            transceiver.remoteCapabilities.headerExtensions || [];
        remoteExtensions.forEach(function(rHdrExt) {
          if (hdrExt.uri === rHdrExt.uri) {
            hdrExt.id = rHdrExt.id;
          }
        });
      });

      // generate an ssrc now, to be used later in rtpSender.send
      var sendEncodingParameters = transceiver.sendEncodingParameters || [{
        ssrc: (2 * sdpMLineIndex + 1) * 1001
      }];
      if (track) {
        // add RTX
        if (edgeVersion >= 15019 && kind === 'video' &&
            !sendEncodingParameters[0].rtx) {
          sendEncodingParameters[0].rtx = {
            ssrc: sendEncodingParameters[0].ssrc + 1
          };
        }
      }

      if (transceiver.wantReceive) {
        transceiver.rtpReceiver = new window.RTCRtpReceiver(
            transceiver.dtlsTransport, kind);
      }

      transceiver.localCapabilities = localCapabilities;
      transceiver.sendEncodingParameters = sendEncodingParameters;
    });

    // always offer BUNDLE and dispose on return if not supported.
    if (pc._config.bundlePolicy !== 'max-compat') {
      sdp += 'a=group:BUNDLE ' + pc.transceivers.map(function(t) {
        return t.mid;
      }).join(' ') + '\r\n';
    }
    sdp += 'a=ice-options:trickle\r\n';

    pc.transceivers.forEach(function(transceiver, sdpMLineIndex) {
      sdp += writeMediaSection(transceiver, transceiver.localCapabilities,
          'offer', transceiver.stream, pc._dtlsRole);
      sdp += 'a=rtcp-rsize\r\n';

      if (transceiver.iceGatherer && pc.iceGatheringState !== 'new' &&
          (sdpMLineIndex === 0 || !pc.usingBundle)) {
        transceiver.iceGatherer.getLocalCandidates().forEach(function(cand) {
          cand.component = 1;
          sdp += 'a=' + SDPUtils.writeCandidate(cand) + '\r\n';
        });

        if (transceiver.iceGatherer.state === 'completed') {
          sdp += 'a=end-of-candidates\r\n';
        }
      }
    });

    var desc = new window.RTCSessionDescription({
      type: 'offer',
      sdp: sdp
    });
    return Promise.resolve(desc);
  };

  RTCPeerConnection.prototype.createAnswer = function() {
    var pc = this;

    if (pc._isClosed) {
      return Promise.reject(makeError('InvalidStateError',
          'Can not call createAnswer after close'));
    }

    if (!(pc.signalingState === 'have-remote-offer' ||
        pc.signalingState === 'have-local-pranswer')) {
      return Promise.reject(makeError('InvalidStateError',
          'Can not call createAnswer in signalingState ' + pc.signalingState));
    }

    var sdp = SDPUtils.writeSessionBoilerplate(pc._sdpSessionId,
        pc._sdpSessionVersion++);
    if (pc.usingBundle) {
      sdp += 'a=group:BUNDLE ' + pc.transceivers.map(function(t) {
        return t.mid;
      }).join(' ') + '\r\n';
    }
    var mediaSectionsInOffer = SDPUtils.getMediaSections(
        pc._remoteDescription.sdp).length;
    pc.transceivers.forEach(function(transceiver, sdpMLineIndex) {
      if (sdpMLineIndex + 1 > mediaSectionsInOffer) {
        return;
      }
      if (transceiver.rejected) {
        if (transceiver.kind === 'application') {
          if (transceiver.protocol === 'DTLS/SCTP') { // legacy fmt
            sdp += 'm=application 0 DTLS/SCTP 5000\r\n';
          } else {
            sdp += 'm=application 0 ' + transceiver.protocol +
                ' webrtc-datachannel\r\n';
          }
        } else if (transceiver.kind === 'audio') {
          sdp += 'm=audio 0 UDP/TLS/RTP/SAVPF 0\r\n' +
              'a=rtpmap:0 PCMU/8000\r\n';
        } else if (transceiver.kind === 'video') {
          sdp += 'm=video 0 UDP/TLS/RTP/SAVPF 120\r\n' +
              'a=rtpmap:120 VP8/90000\r\n';
        }
        sdp += 'c=IN IP4 0.0.0.0\r\n' +
            'a=inactive\r\n' +
            'a=mid:' + transceiver.mid + '\r\n';
        return;
      }

      // FIXME: look at direction.
      if (transceiver.stream) {
        var localTrack;
        if (transceiver.kind === 'audio') {
          localTrack = transceiver.stream.getAudioTracks()[0];
        } else if (transceiver.kind === 'video') {
          localTrack = transceiver.stream.getVideoTracks()[0];
        }
        if (localTrack) {
          // add RTX
          if (edgeVersion >= 15019 && transceiver.kind === 'video' &&
              !transceiver.sendEncodingParameters[0].rtx) {
            transceiver.sendEncodingParameters[0].rtx = {
              ssrc: transceiver.sendEncodingParameters[0].ssrc + 1
            };
          }
        }
      }

      // Calculate intersection of capabilities.
      var commonCapabilities = getCommonCapabilities(
          transceiver.localCapabilities,
          transceiver.remoteCapabilities);

      var hasRtx = commonCapabilities.codecs.filter(function(c) {
        return c.name.toLowerCase() === 'rtx';
      }).length;
      if (!hasRtx && transceiver.sendEncodingParameters[0].rtx) {
        delete transceiver.sendEncodingParameters[0].rtx;
      }

      sdp += writeMediaSection(transceiver, commonCapabilities,
          'answer', transceiver.stream, pc._dtlsRole);
      if (transceiver.rtcpParameters &&
          transceiver.rtcpParameters.reducedSize) {
        sdp += 'a=rtcp-rsize\r\n';
      }
    });

    var desc = new window.RTCSessionDescription({
      type: 'answer',
      sdp: sdp
    });
    return Promise.resolve(desc);
  };

  RTCPeerConnection.prototype.addIceCandidate = function(candidate) {
    var pc = this;
    var sections;
    if (candidate && !(candidate.sdpMLineIndex !== undefined ||
        candidate.sdpMid)) {
      return Promise.reject(new TypeError('sdpMLineIndex or sdpMid required'));
    }

    // TODO: needs to go into ops queue.
    return new Promise(function(resolve, reject) {
      if (!pc._remoteDescription) {
        return reject(makeError('InvalidStateError',
            'Can not add ICE candidate without a remote description'));
      } else if (!candidate || candidate.candidate === '') {
        for (var j = 0; j < pc.transceivers.length; j++) {
          if (pc.transceivers[j].rejected) {
            continue;
          }
          pc.transceivers[j].iceTransport.addRemoteCandidate({});
          sections = SDPUtils.getMediaSections(pc._remoteDescription.sdp);
          sections[j] += 'a=end-of-candidates\r\n';
          pc._remoteDescription.sdp =
              SDPUtils.getDescription(pc._remoteDescription.sdp) +
              sections.join('');
          if (pc.usingBundle) {
            break;
          }
        }
      } else {
        var sdpMLineIndex = candidate.sdpMLineIndex;
        if (candidate.sdpMid) {
          for (var i = 0; i < pc.transceivers.length; i++) {
            if (pc.transceivers[i].mid === candidate.sdpMid) {
              sdpMLineIndex = i;
              break;
            }
          }
        }
        var transceiver = pc.transceivers[sdpMLineIndex];
        if (transceiver) {
          if (transceiver.rejected) {
            return resolve();
          }
          var cand = Object.keys(candidate.candidate).length > 0 ?
              SDPUtils.parseCandidate(candidate.candidate) : {};
          // Ignore Chrome's invalid candidates since Edge does not like them.
          if (cand.protocol === 'tcp' && (cand.port === 0 || cand.port === 9)) {
            return resolve();
          }
          // Ignore RTCP candidates, we assume RTCP-MUX.
          if (cand.component && cand.component !== 1) {
            return resolve();
          }
          // when using bundle, avoid adding candidates to the wrong
          // ice transport. And avoid adding candidates added in the SDP.
          if (sdpMLineIndex === 0 || (sdpMLineIndex > 0 &&
              transceiver.iceTransport !== pc.transceivers[0].iceTransport)) {
            if (!maybeAddCandidate(transceiver.iceTransport, cand)) {
              return reject(makeError('OperationError',
                  'Can not add ICE candidate'));
            }
          }

          // update the remoteDescription.
          var candidateString = candidate.candidate.trim();
          if (candidateString.indexOf('a=') === 0) {
            candidateString = candidateString.substr(2);
          }
          sections = SDPUtils.getMediaSections(pc._remoteDescription.sdp);
          sections[sdpMLineIndex] += 'a=' +
              (cand.type ? candidateString : 'end-of-candidates')
              + '\r\n';
          pc._remoteDescription.sdp =
              SDPUtils.getDescription(pc._remoteDescription.sdp) +
              sections.join('');
        } else {
          return reject(makeError('OperationError',
              'Can not add ICE candidate'));
        }
      }
      resolve();
    });
  };

  RTCPeerConnection.prototype.getStats = function(selector) {
    if (selector && selector instanceof window.MediaStreamTrack) {
      var senderOrReceiver = null;
      this.transceivers.forEach(function(transceiver) {
        if (transceiver.rtpSender &&
            transceiver.rtpSender.track === selector) {
          senderOrReceiver = transceiver.rtpSender;
        } else if (transceiver.rtpReceiver &&
            transceiver.rtpReceiver.track === selector) {
          senderOrReceiver = transceiver.rtpReceiver;
        }
      });
      if (!senderOrReceiver) {
        throw makeError('InvalidAccessError', 'Invalid selector.');
      }
      return senderOrReceiver.getStats();
    }

    var promises = [];
    this.transceivers.forEach(function(transceiver) {
      ['rtpSender', 'rtpReceiver', 'iceGatherer', 'iceTransport',
          'dtlsTransport'].forEach(function(method) {
            if (transceiver[method]) {
              promises.push(transceiver[method].getStats());
            }
          });
    });
    return Promise.all(promises).then(function(allStats) {
      var results = new Map();
      allStats.forEach(function(stats) {
        stats.forEach(function(stat) {
          results.set(stat.id, stat);
        });
      });
      return results;
    });
  };

  // fix low-level stat names and return Map instead of object.
  var ortcObjects = ['RTCRtpSender', 'RTCRtpReceiver', 'RTCIceGatherer',
    'RTCIceTransport', 'RTCDtlsTransport'];
  ortcObjects.forEach(function(ortcObjectName) {
    var obj = window[ortcObjectName];
    if (obj && obj.prototype && obj.prototype.getStats) {
      var nativeGetstats = obj.prototype.getStats;
      obj.prototype.getStats = function() {
        return nativeGetstats.apply(this)
        .then(function(nativeStats) {
          var mapStats = new Map();
          Object.keys(nativeStats).forEach(function(id) {
            nativeStats[id].type = fixStatsType(nativeStats[id]);
            mapStats.set(id, nativeStats[id]);
          });
          return mapStats;
        });
      };
    }
  });

  // legacy callback shims. Should be moved to adapter.js some days.
  var methods = ['createOffer', 'createAnswer'];
  methods.forEach(function(method) {
    var nativeMethod = RTCPeerConnection.prototype[method];
    RTCPeerConnection.prototype[method] = function() {
      var args = arguments;
      if (typeof args[0] === 'function' ||
          typeof args[1] === 'function') { // legacy
        return nativeMethod.apply(this, [arguments[2]])
        .then(function(description) {
          if (typeof args[0] === 'function') {
            args[0].apply(null, [description]);
          }
        }, function(error) {
          if (typeof args[1] === 'function') {
            args[1].apply(null, [error]);
          }
        });
      }
      return nativeMethod.apply(this, arguments);
    };
  });

  methods = ['setLocalDescription', 'setRemoteDescription', 'addIceCandidate'];
  methods.forEach(function(method) {
    var nativeMethod = RTCPeerConnection.prototype[method];
    RTCPeerConnection.prototype[method] = function() {
      var args = arguments;
      if (typeof args[1] === 'function' ||
          typeof args[2] === 'function') { // legacy
        return nativeMethod.apply(this, arguments)
        .then(function() {
          if (typeof args[1] === 'function') {
            args[1].apply(null);
          }
        }, function(error) {
          if (typeof args[2] === 'function') {
            args[2].apply(null, [error]);
          }
        });
      }
      return nativeMethod.apply(this, arguments);
    };
  });

  // getStats is special. It doesn't have a spec legacy method yet we support
  // getStats(something, cb) without error callbacks.
  ['getStats'].forEach(function(method) {
    var nativeMethod = RTCPeerConnection.prototype[method];
    RTCPeerConnection.prototype[method] = function() {
      var args = arguments;
      if (typeof args[1] === 'function') {
        return nativeMethod.apply(this, arguments)
        .then(function() {
          if (typeof args[1] === 'function') {
            args[1].apply(null);
          }
        });
      }
      return nativeMethod.apply(this, arguments);
    };
  });

  return RTCPeerConnection;
};

},{"sdp":2}],2:[function(require,module,exports){
 /* eslint-env node */
'use strict';

// SDP helpers.
var SDPUtils = {};

// Generate an alphanumeric identifier for cname or mids.
// TODO: use UUIDs instead? https://gist.github.com/jed/982883
SDPUtils.generateIdentifier = function() {
  return Math.random().toString(36).substr(2, 10);
};

// The RTCP CNAME used by all peerconnections from the same JS.
SDPUtils.localCName = SDPUtils.generateIdentifier();

// Splits SDP into lines, dealing with both CRLF and LF.
SDPUtils.splitLines = function(blob) {
  return blob.trim().split('\n').map(function(line) {
    return line.trim();
  });
};
// Splits SDP into sessionpart and mediasections. Ensures CRLF.
SDPUtils.splitSections = function(blob) {
  var parts = blob.split('\nm=');
  return parts.map(function(part, index) {
    return (index > 0 ? 'm=' + part : part).trim() + '\r\n';
  });
};

// returns the session description.
SDPUtils.getDescription = function(blob) {
  var sections = SDPUtils.splitSections(blob);
  return sections && sections[0];
};

// returns the individual media sections.
SDPUtils.getMediaSections = function(blob) {
  var sections = SDPUtils.splitSections(blob);
  sections.shift();
  return sections;
};

// Returns lines that start with a certain prefix.
SDPUtils.matchPrefix = function(blob, prefix) {
  return SDPUtils.splitLines(blob).filter(function(line) {
    return line.indexOf(prefix) === 0;
  });
};

// Parses an ICE candidate line. Sample input:
// candidate:702786350 2 udp 41819902 8.8.8.8 60769 typ relay raddr 8.8.8.8
// rport 55996"
SDPUtils.parseCandidate = function(line) {
  var parts;
  // Parse both variants.
  if (line.indexOf('a=candidate:') === 0) {
    parts = line.substring(12).split(' ');
  } else {
    parts = line.substring(10).split(' ');
  }

  var candidate = {
    foundation: parts[0],
    component: parseInt(parts[1], 10),
    protocol: parts[2].toLowerCase(),
    priority: parseInt(parts[3], 10),
    ip: parts[4],
    port: parseInt(parts[5], 10),
    // skip parts[6] == 'typ'
    type: parts[7]
  };

  for (var i = 8; i < parts.length; i += 2) {
    switch (parts[i]) {
      case 'raddr':
        candidate.relatedAddress = parts[i + 1];
        break;
      case 'rport':
        candidate.relatedPort = parseInt(parts[i + 1], 10);
        break;
      case 'tcptype':
        candidate.tcpType = parts[i + 1];
        break;
      case 'ufrag':
        candidate.ufrag = parts[i + 1]; // for backward compability.
        candidate.usernameFragment = parts[i + 1];
        break;
      default: // extension handling, in particular ufrag
        candidate[parts[i]] = parts[i + 1];
        break;
    }
  }
  return candidate;
};

// Translates a candidate object into SDP candidate attribute.
SDPUtils.writeCandidate = function(candidate) {
  var sdp = [];
  sdp.push(candidate.foundation);
  sdp.push(candidate.component);
  sdp.push(candidate.protocol.toUpperCase());
  sdp.push(candidate.priority);
  sdp.push(candidate.ip);
  sdp.push(candidate.port);

  var type = candidate.type;
  sdp.push('typ');
  sdp.push(type);
  if (type !== 'host' && candidate.relatedAddress &&
      candidate.relatedPort) {
    sdp.push('raddr');
    sdp.push(candidate.relatedAddress);
    sdp.push('rport');
    sdp.push(candidate.relatedPort);
  }
  if (candidate.tcpType && candidate.protocol.toLowerCase() === 'tcp') {
    sdp.push('tcptype');
    sdp.push(candidate.tcpType);
  }
  if (candidate.usernameFragment || candidate.ufrag) {
    sdp.push('ufrag');
    sdp.push(candidate.usernameFragment || candidate.ufrag);
  }
  return 'candidate:' + sdp.join(' ');
};

// Parses an ice-options line, returns an array of option tags.
// a=ice-options:foo bar
SDPUtils.parseIceOptions = function(line) {
  return line.substr(14).split(' ');
};

// Parses an rtpmap line, returns RTCRtpCoddecParameters. Sample input:
// a=rtpmap:111 opus/48000/2
SDPUtils.parseRtpMap = function(line) {
  var parts = line.substr(9).split(' ');
  var parsed = {
    payloadType: parseInt(parts.shift(), 10) // was: id
  };

  parts = parts[0].split('/');

  parsed.name = parts[0];
  parsed.clockRate = parseInt(parts[1], 10); // was: clockrate
  parsed.channels = parts.length === 3 ? parseInt(parts[2], 10) : 1;
  // legacy alias, got renamed back to channels in ORTC.
  parsed.numChannels = parsed.channels;
  return parsed;
};

// Generate an a=rtpmap line from RTCRtpCodecCapability or
// RTCRtpCodecParameters.
SDPUtils.writeRtpMap = function(codec) {
  var pt = codec.payloadType;
  if (codec.preferredPayloadType !== undefined) {
    pt = codec.preferredPayloadType;
  }
  var channels = codec.channels || codec.numChannels || 1;
  return 'a=rtpmap:' + pt + ' ' + codec.name + '/' + codec.clockRate +
      (channels !== 1 ? '/' + channels : '') + '\r\n';
};

// Parses an a=extmap line (headerextension from RFC 5285). Sample input:
// a=extmap:2 urn:ietf:params:rtp-hdrext:toffset
// a=extmap:2/sendonly urn:ietf:params:rtp-hdrext:toffset
SDPUtils.parseExtmap = function(line) {
  var parts = line.substr(9).split(' ');
  return {
    id: parseInt(parts[0], 10),
    direction: parts[0].indexOf('/') > 0 ? parts[0].split('/')[1] : 'sendrecv',
    uri: parts[1]
  };
};

// Generates a=extmap line from RTCRtpHeaderExtensionParameters or
// RTCRtpHeaderExtension.
SDPUtils.writeExtmap = function(headerExtension) {
  return 'a=extmap:' + (headerExtension.id || headerExtension.preferredId) +
      (headerExtension.direction && headerExtension.direction !== 'sendrecv'
          ? '/' + headerExtension.direction
          : '') +
      ' ' + headerExtension.uri + '\r\n';
};

// Parses an ftmp line, returns dictionary. Sample input:
// a=fmtp:96 vbr=on;cng=on
// Also deals with vbr=on; cng=on
SDPUtils.parseFmtp = function(line) {
  var parsed = {};
  var kv;
  var parts = line.substr(line.indexOf(' ') + 1).split(';');
  for (var j = 0; j < parts.length; j++) {
    kv = parts[j].trim().split('=');
    parsed[kv[0].trim()] = kv[1];
  }
  return parsed;
};

// Generates an a=ftmp line from RTCRtpCodecCapability or RTCRtpCodecParameters.
SDPUtils.writeFmtp = function(codec) {
  var line = '';
  var pt = codec.payloadType;
  if (codec.preferredPayloadType !== undefined) {
    pt = codec.preferredPayloadType;
  }
  if (codec.parameters && Object.keys(codec.parameters).length) {
    var params = [];
    Object.keys(codec.parameters).forEach(function(param) {
      if (codec.parameters[param]) {
        params.push(param + '=' + codec.parameters[param]);
      } else {
        params.push(param);
      }
    });
    line += 'a=fmtp:' + pt + ' ' + params.join(';') + '\r\n';
  }
  return line;
};

// Parses an rtcp-fb line, returns RTCPRtcpFeedback object. Sample input:
// a=rtcp-fb:98 nack rpsi
SDPUtils.parseRtcpFb = function(line) {
  var parts = line.substr(line.indexOf(' ') + 1).split(' ');
  return {
    type: parts.shift(),
    parameter: parts.join(' ')
  };
};
// Generate a=rtcp-fb lines from RTCRtpCodecCapability or RTCRtpCodecParameters.
SDPUtils.writeRtcpFb = function(codec) {
  var lines = '';
  var pt = codec.payloadType;
  if (codec.preferredPayloadType !== undefined) {
    pt = codec.preferredPayloadType;
  }
  if (codec.rtcpFeedback && codec.rtcpFeedback.length) {
    // FIXME: special handling for trr-int?
    codec.rtcpFeedback.forEach(function(fb) {
      lines += 'a=rtcp-fb:' + pt + ' ' + fb.type +
      (fb.parameter && fb.parameter.length ? ' ' + fb.parameter : '') +
          '\r\n';
    });
  }
  return lines;
};

// Parses an RFC 5576 ssrc media attribute. Sample input:
// a=ssrc:3735928559 cname:something
SDPUtils.parseSsrcMedia = function(line) {
  var sp = line.indexOf(' ');
  var parts = {
    ssrc: parseInt(line.substr(7, sp - 7), 10)
  };
  var colon = line.indexOf(':', sp);
  if (colon > -1) {
    parts.attribute = line.substr(sp + 1, colon - sp - 1);
    parts.value = line.substr(colon + 1);
  } else {
    parts.attribute = line.substr(sp + 1);
  }
  return parts;
};

SDPUtils.parseSsrcGroup = function(line) {
  var parts = line.substr(13).split(' ');
  return {
    semantics: parts.shift(),
    ssrcs: parts.map(function(ssrc) {
      return parseInt(ssrc, 10);
    })
  };
};

// Extracts the MID (RFC 5888) from a media section.
// returns the MID or undefined if no mid line was found.
SDPUtils.getMid = function(mediaSection) {
  var mid = SDPUtils.matchPrefix(mediaSection, 'a=mid:')[0];
  if (mid) {
    return mid.substr(6);
  }
};

SDPUtils.parseFingerprint = function(line) {
  var parts = line.substr(14).split(' ');
  return {
    algorithm: parts[0].toLowerCase(), // algorithm is case-sensitive in Edge.
    value: parts[1]
  };
};

// Extracts DTLS parameters from SDP media section or sessionpart.
// FIXME: for consistency with other functions this should only
//   get the fingerprint line as input. See also getIceParameters.
SDPUtils.getDtlsParameters = function(mediaSection, sessionpart) {
  var lines = SDPUtils.matchPrefix(mediaSection + sessionpart,
      'a=fingerprint:');
  // Note: a=setup line is ignored since we use the 'auto' role.
  // Note2: 'algorithm' is not case sensitive except in Edge.
  return {
    role: 'auto',
    fingerprints: lines.map(SDPUtils.parseFingerprint)
  };
};

// Serializes DTLS parameters to SDP.
SDPUtils.writeDtlsParameters = function(params, setupType) {
  var sdp = 'a=setup:' + setupType + '\r\n';
  params.fingerprints.forEach(function(fp) {
    sdp += 'a=fingerprint:' + fp.algorithm + ' ' + fp.value + '\r\n';
  });
  return sdp;
};
// Parses ICE information from SDP media section or sessionpart.
// FIXME: for consistency with other functions this should only
//   get the ice-ufrag and ice-pwd lines as input.
SDPUtils.getIceParameters = function(mediaSection, sessionpart) {
  var lines = SDPUtils.splitLines(mediaSection);
  // Search in session part, too.
  lines = lines.concat(SDPUtils.splitLines(sessionpart));
  var iceParameters = {
    usernameFragment: lines.filter(function(line) {
      return line.indexOf('a=ice-ufrag:') === 0;
    })[0].substr(12),
    password: lines.filter(function(line) {
      return line.indexOf('a=ice-pwd:') === 0;
    })[0].substr(10)
  };
  return iceParameters;
};

// Serializes ICE parameters to SDP.
SDPUtils.writeIceParameters = function(params) {
  return 'a=ice-ufrag:' + params.usernameFragment + '\r\n' +
      'a=ice-pwd:' + params.password + '\r\n';
};

// Parses the SDP media section and returns RTCRtpParameters.
SDPUtils.parseRtpParameters = function(mediaSection) {
  var description = {
    codecs: [],
    headerExtensions: [],
    fecMechanisms: [],
    rtcp: []
  };
  var lines = SDPUtils.splitLines(mediaSection);
  var mline = lines[0].split(' ');
  for (var i = 3; i < mline.length; i++) { // find all codecs from mline[3..]
    var pt = mline[i];
    var rtpmapline = SDPUtils.matchPrefix(
        mediaSection, 'a=rtpmap:' + pt + ' ')[0];
    if (rtpmapline) {
      var codec = SDPUtils.parseRtpMap(rtpmapline);
      var fmtps = SDPUtils.matchPrefix(
          mediaSection, 'a=fmtp:' + pt + ' ');
      // Only the first a=fmtp:<pt> is considered.
      codec.parameters = fmtps.length ? SDPUtils.parseFmtp(fmtps[0]) : {};
      codec.rtcpFeedback = SDPUtils.matchPrefix(
          mediaSection, 'a=rtcp-fb:' + pt + ' ')
        .map(SDPUtils.parseRtcpFb);
      description.codecs.push(codec);
      // parse FEC mechanisms from rtpmap lines.
      switch (codec.name.toUpperCase()) {
        case 'RED':
        case 'ULPFEC':
          description.fecMechanisms.push(codec.name.toUpperCase());
          break;
        default: // only RED and ULPFEC are recognized as FEC mechanisms.
          break;
      }
    }
  }
  SDPUtils.matchPrefix(mediaSection, 'a=extmap:').forEach(function(line) {
    description.headerExtensions.push(SDPUtils.parseExtmap(line));
  });
  // FIXME: parse rtcp.
  return description;
};

// Generates parts of the SDP media section describing the capabilities /
// parameters.
SDPUtils.writeRtpDescription = function(kind, caps) {
  var sdp = '';

  // Build the mline.
  sdp += 'm=' + kind + ' ';
  sdp += caps.codecs.length > 0 ? '9' : '0'; // reject if no codecs.
  sdp += ' UDP/TLS/RTP/SAVPF ';
  sdp += caps.codecs.map(function(codec) {
    if (codec.preferredPayloadType !== undefined) {
      return codec.preferredPayloadType;
    }
    return codec.payloadType;
  }).join(' ') + '\r\n';

  sdp += 'c=IN IP4 0.0.0.0\r\n';
  sdp += 'a=rtcp:9 IN IP4 0.0.0.0\r\n';

  // Add a=rtpmap lines for each codec. Also fmtp and rtcp-fb.
  caps.codecs.forEach(function(codec) {
    sdp += SDPUtils.writeRtpMap(codec);
    sdp += SDPUtils.writeFmtp(codec);
    sdp += SDPUtils.writeRtcpFb(codec);
  });
  var maxptime = 0;
  caps.codecs.forEach(function(codec) {
    if (codec.maxptime > maxptime) {
      maxptime = codec.maxptime;
    }
  });
  if (maxptime > 0) {
    sdp += 'a=maxptime:' + maxptime + '\r\n';
  }
  sdp += 'a=rtcp-mux\r\n';

  if (caps.headerExtensions) {
    caps.headerExtensions.forEach(function(extension) {
      sdp += SDPUtils.writeExtmap(extension);
    });
  }
  // FIXME: write fecMechanisms.
  return sdp;
};

// Parses the SDP media section and returns an array of
// RTCRtpEncodingParameters.
SDPUtils.parseRtpEncodingParameters = function(mediaSection) {
  var encodingParameters = [];
  var description = SDPUtils.parseRtpParameters(mediaSection);
  var hasRed = description.fecMechanisms.indexOf('RED') !== -1;
  var hasUlpfec = description.fecMechanisms.indexOf('ULPFEC') !== -1;

  // filter a=ssrc:... cname:, ignore PlanB-msid
  var ssrcs = SDPUtils.matchPrefix(mediaSection, 'a=ssrc:')
  .map(function(line) {
    return SDPUtils.parseSsrcMedia(line);
  })
  .filter(function(parts) {
    return parts.attribute === 'cname';
  });
  var primarySsrc = ssrcs.length > 0 && ssrcs[0].ssrc;
  var secondarySsrc;

  var flows = SDPUtils.matchPrefix(mediaSection, 'a=ssrc-group:FID')
  .map(function(line) {
    var parts = line.substr(17).split(' ');
    return parts.map(function(part) {
      return parseInt(part, 10);
    });
  });
  if (flows.length > 0 && flows[0].length > 1 && flows[0][0] === primarySsrc) {
    secondarySsrc = flows[0][1];
  }

  description.codecs.forEach(function(codec) {
    if (codec.name.toUpperCase() === 'RTX' && codec.parameters.apt) {
      var encParam = {
        ssrc: primarySsrc,
        codecPayloadType: parseInt(codec.parameters.apt, 10)
      };
      if (primarySsrc && secondarySsrc) {
        encParam.rtx = {ssrc: secondarySsrc};
      }
      encodingParameters.push(encParam);
      if (hasRed) {
        encParam = JSON.parse(JSON.stringify(encParam));
        encParam.fec = {
          ssrc: secondarySsrc,
          mechanism: hasUlpfec ? 'red+ulpfec' : 'red'
        };
        encodingParameters.push(encParam);
      }
    }
  });
  if (encodingParameters.length === 0 && primarySsrc) {
    encodingParameters.push({
      ssrc: primarySsrc
    });
  }

  // we support both b=AS and b=TIAS but interpret AS as TIAS.
  var bandwidth = SDPUtils.matchPrefix(mediaSection, 'b=');
  if (bandwidth.length) {
    if (bandwidth[0].indexOf('b=TIAS:') === 0) {
      bandwidth = parseInt(bandwidth[0].substr(7), 10);
    } else if (bandwidth[0].indexOf('b=AS:') === 0) {
      // use formula from JSEP to convert b=AS to TIAS value.
      bandwidth = parseInt(bandwidth[0].substr(5), 10) * 1000 * 0.95
          - (50 * 40 * 8);
    } else {
      bandwidth = undefined;
    }
    encodingParameters.forEach(function(params) {
      params.maxBitrate = bandwidth;
    });
  }
  return encodingParameters;
};

// parses http://draft.ortc.org/#rtcrtcpparameters*
SDPUtils.parseRtcpParameters = function(mediaSection) {
  var rtcpParameters = {};

  // Gets the first SSRC. Note tha with RTX there might be multiple
  // SSRCs.
  var remoteSsrc = SDPUtils.matchPrefix(mediaSection, 'a=ssrc:')
      .map(function(line) {
        return SDPUtils.parseSsrcMedia(line);
      })
      .filter(function(obj) {
        return obj.attribute === 'cname';
      })[0];
  if (remoteSsrc) {
    rtcpParameters.cname = remoteSsrc.value;
    rtcpParameters.ssrc = remoteSsrc.ssrc;
  }

  // Edge uses the compound attribute instead of reducedSize
  // compound is !reducedSize
  var rsize = SDPUtils.matchPrefix(mediaSection, 'a=rtcp-rsize');
  rtcpParameters.reducedSize = rsize.length > 0;
  rtcpParameters.compound = rsize.length === 0;

  // parses the rtcp-mux attrіbute.
  // Note that Edge does not support unmuxed RTCP.
  var mux = SDPUtils.matchPrefix(mediaSection, 'a=rtcp-mux');
  rtcpParameters.mux = mux.length > 0;

  return rtcpParameters;
};

// parses either a=msid: or a=ssrc:... msid lines and returns
// the id of the MediaStream and MediaStreamTrack.
SDPUtils.parseMsid = function(mediaSection) {
  var parts;
  var spec = SDPUtils.matchPrefix(mediaSection, 'a=msid:');
  if (spec.length === 1) {
    parts = spec[0].substr(7).split(' ');
    return {stream: parts[0], track: parts[1]};
  }
  var planB = SDPUtils.matchPrefix(mediaSection, 'a=ssrc:')
  .map(function(line) {
    return SDPUtils.parseSsrcMedia(line);
  })
  .filter(function(msidParts) {
    return msidParts.attribute === 'msid';
  });
  if (planB.length > 0) {
    parts = planB[0].value.split(' ');
    return {stream: parts[0], track: parts[1]};
  }
};

// Generate a session ID for SDP.
// https://tools.ietf.org/html/draft-ietf-rtcweb-jsep-20#section-5.2.1
// recommends using a cryptographically random +ve 64-bit value
// but right now this should be acceptable and within the right range
SDPUtils.generateSessionId = function() {
  return Math.random().toString().substr(2, 21);
};

// Write boilder plate for start of SDP
// sessId argument is optional - if not supplied it will
// be generated randomly
// sessVersion is optional and defaults to 2
SDPUtils.writeSessionBoilerplate = function(sessId, sessVer) {
  var sessionId;
  var version = sessVer !== undefined ? sessVer : 2;
  if (sessId) {
    sessionId = sessId;
  } else {
    sessionId = SDPUtils.generateSessionId();
  }
  // FIXME: sess-id should be an NTP timestamp.
  return 'v=0\r\n' +
      'o=thisisadapterortc ' + sessionId + ' ' + version +
        ' IN IP4 127.0.0.1\r\n' +
      's=-\r\n' +
      't=0 0\r\n';
};

SDPUtils.writeMediaSection = function(transceiver, caps, type, stream) {
  var sdp = SDPUtils.writeRtpDescription(transceiver.kind, caps);

  // Map ICE parameters (ufrag, pwd) to SDP.
  sdp += SDPUtils.writeIceParameters(
      transceiver.iceGatherer.getLocalParameters());

  // Map DTLS parameters to SDP.
  sdp += SDPUtils.writeDtlsParameters(
      transceiver.dtlsTransport.getLocalParameters(),
      type === 'offer' ? 'actpass' : 'active');

  sdp += 'a=mid:' + transceiver.mid + '\r\n';

  if (transceiver.direction) {
    sdp += 'a=' + transceiver.direction + '\r\n';
  } else if (transceiver.rtpSender && transceiver.rtpReceiver) {
    sdp += 'a=sendrecv\r\n';
  } else if (transceiver.rtpSender) {
    sdp += 'a=sendonly\r\n';
  } else if (transceiver.rtpReceiver) {
    sdp += 'a=recvonly\r\n';
  } else {
    sdp += 'a=inactive\r\n';
  }

  if (transceiver.rtpSender) {
    // spec.
    var msid = 'msid:' + stream.id + ' ' +
        transceiver.rtpSender.track.id + '\r\n';
    sdp += 'a=' + msid;

    // for Chrome.
    sdp += 'a=ssrc:' + transceiver.sendEncodingParameters[0].ssrc +
        ' ' + msid;
    if (transceiver.sendEncodingParameters[0].rtx) {
      sdp += 'a=ssrc:' + transceiver.sendEncodingParameters[0].rtx.ssrc +
          ' ' + msid;
      sdp += 'a=ssrc-group:FID ' +
          transceiver.sendEncodingParameters[0].ssrc + ' ' +
          transceiver.sendEncodingParameters[0].rtx.ssrc +
          '\r\n';
    }
  }
  // FIXME: this should be written by writeRtpDescription.
  sdp += 'a=ssrc:' + transceiver.sendEncodingParameters[0].ssrc +
      ' cname:' + SDPUtils.localCName + '\r\n';
  if (transceiver.rtpSender && transceiver.sendEncodingParameters[0].rtx) {
    sdp += 'a=ssrc:' + transceiver.sendEncodingParameters[0].rtx.ssrc +
        ' cname:' + SDPUtils.localCName + '\r\n';
  }
  return sdp;
};

// Gets the direction from the mediaSection or the sessionpart.
SDPUtils.getDirection = function(mediaSection, sessionpart) {
  // Look for sendrecv, sendonly, recvonly, inactive, default to sendrecv.
  var lines = SDPUtils.splitLines(mediaSection);
  for (var i = 0; i < lines.length; i++) {
    switch (lines[i]) {
      case 'a=sendrecv':
      case 'a=sendonly':
      case 'a=recvonly':
      case 'a=inactive':
        return lines[i].substr(2);
      default:
        // FIXME: What should happen here?
    }
  }
  if (sessionpart) {
    return SDPUtils.getDirection(sessionpart);
  }
  return 'sendrecv';
};

SDPUtils.getKind = function(mediaSection) {
  var lines = SDPUtils.splitLines(mediaSection);
  var mline = lines[0].split(' ');
  return mline[0].substr(2);
};

SDPUtils.isRejected = function(mediaSection) {
  return mediaSection.split(' ', 2)[1] === '0';
};

SDPUtils.parseMLine = function(mediaSection) {
  var lines = SDPUtils.splitLines(mediaSection);
  var parts = lines[0].substr(2).split(' ');
  return {
    kind: parts[0],
    port: parseInt(parts[1], 10),
    protocol: parts[2],
    fmt: parts.slice(3).join(' ')
  };
};

SDPUtils.parseOLine = function(mediaSection) {
  var line = SDPUtils.matchPrefix(mediaSection, 'o=')[0];
  var parts = line.substr(2).split(' ');
  return {
    username: parts[0],
    sessionId: parts[1],
    sessionVersion: parseInt(parts[2], 10),
    netType: parts[3],
    addressType: parts[4],
    address: parts[5]
  };
};

// a very naive interpretation of a valid SDP.
SDPUtils.isValidSDP = function(blob) {
  if (typeof blob !== 'string' || blob.length === 0) {
    return false;
  }
  var lines = SDPUtils.splitLines(blob);
  for (var i = 0; i < lines.length; i++) {
    if (lines[i].length < 2 || lines[i].charAt(1) !== '=') {
      return false;
    }
    // TODO: check the modifier a bit more.
  }
  return true;
};

// Expose public methods.
if (typeof module === 'object') {
  module.exports = SDPUtils;
}

},{}],3:[function(require,module,exports){
(function (global){
/*
 *  Copyright (c) 2016 The WebRTC project authors. All Rights Reserved.
 *
 *  Use of this source code is governed by a BSD-style license
 *  that can be found in the LICENSE file in the root of the source
 *  tree.
 */
 /* eslint-env node */

'use strict';

var adapterFactory = require('./adapter_factory.js');
module.exports = adapterFactory({window: global.window});

}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})
},{"./adapter_factory.js":4}],4:[function(require,module,exports){
/*
 *  Copyright (c) 2016 The WebRTC project authors. All Rights Reserved.
 *
 *  Use of this source code is governed by a BSD-style license
 *  that can be found in the LICENSE file in the root of the source
 *  tree.
 */
 /* eslint-env node */

'use strict';

var utils = require('./utils');
// Shimming starts here.
module.exports = function(dependencies, opts) {
  var window = dependencies && dependencies.window;

  var options = {
    shimChrome: true,
    shimFirefox: true,
    shimEdge: true,
    shimSafari: true,
  };

  for (var key in opts) {
    if (hasOwnProperty.call(opts, key)) {
      options[key] = opts[key];
    }
  }

  // Utils.
  var logging = utils.log;
  var browserDetails = utils.detectBrowser(window);

  // Uncomment the line below if you want logging to occur, including logging
  // for the switch statement below. Can also be turned on in the browser via
  // adapter.disableLog(false), but then logging from the switch statement below
  // will not appear.
  // require('./utils').disableLog(false);

  // Browser shims.
  var chromeShim = require('./chrome/chrome_shim') || null;
  var edgeShim = require('./edge/edge_shim') || null;
  var firefoxShim = require('./firefox/firefox_shim') || null;
  var safariShim = require('./safari/safari_shim') || null;
  var commonShim = require('./common_shim') || null;

  // Export to the adapter global object visible in the browser.
  var adapter = {
    browserDetails: browserDetails,
    commonShim: commonShim,
    extractVersion: utils.extractVersion,
    disableLog: utils.disableLog,
    disableWarnings: utils.disableWarnings
  };

  // Shim browser if found.
  switch (browserDetails.browser) {
    case 'chrome':
      if (!chromeShim || !chromeShim.shimPeerConnection ||
          !options.shimChrome) {
        logging('Chrome shim is not included in this adapter release.');
        return adapter;
      }
      logging('adapter.js shimming chrome.');
      // Export to the adapter global object visible in the browser.
      adapter.browserShim = chromeShim;
      commonShim.shimCreateObjectURL(window);

      chromeShim.shimGetUserMedia(window);
      chromeShim.shimMediaStream(window);
      chromeShim.shimSourceObject(window);
      chromeShim.shimPeerConnection(window);
      chromeShim.shimOnTrack(window);
      chromeShim.shimAddTrackRemoveTrack(window);
      chromeShim.shimGetSendersWithDtmf(window);
      chromeShim.shimSenderReceiverGetStats(window);
      chromeShim.fixNegotiationNeeded(window);

      commonShim.shimRTCIceCandidate(window);
      commonShim.shimMaxMessageSize(window);
      commonShim.shimSendThrowTypeError(window);
      break;
    case 'firefox':
      if (!firefoxShim || !firefoxShim.shimPeerConnection ||
          !options.shimFirefox) {
        logging('Firefox shim is not included in this adapter release.');
        return adapter;
      }
      logging('adapter.js shimming firefox.');
      // Export to the adapter global object visible in the browser.
      adapter.browserShim = firefoxShim;
      commonShim.shimCreateObjectURL(window);

      firefoxShim.shimGetUserMedia(window);
      firefoxShim.shimSourceObject(window);
      firefoxShim.shimPeerConnection(window);
      firefoxShim.shimOnTrack(window);
      firefoxShim.shimRemoveStream(window);
      firefoxShim.shimSenderGetStats(window);
      firefoxShim.shimReceiverGetStats(window);
      firefoxShim.shimRTCDataChannel(window);

      commonShim.shimRTCIceCandidate(window);
      commonShim.shimMaxMessageSize(window);
      commonShim.shimSendThrowTypeError(window);
      break;
    case 'edge':
      if (!edgeShim || !edgeShim.shimPeerConnection || !options.shimEdge) {
        logging('MS edge shim is not included in this adapter release.');
        return adapter;
      }
      logging('adapter.js shimming edge.');
      // Export to the adapter global object visible in the browser.
      adapter.browserShim = edgeShim;
      commonShim.shimCreateObjectURL(window);

      edgeShim.shimGetUserMedia(window);
      edgeShim.shimPeerConnection(window);
      edgeShim.shimReplaceTrack(window);

      // the edge shim implements the full RTCIceCandidate object.

      commonShim.shimMaxMessageSize(window);
      commonShim.shimSendThrowTypeError(window);
      break;
    case 'safari':
      if (!safariShim || !options.shimSafari) {
        logging('Safari shim is not included in this adapter release.');
        return adapter;
      }
      logging('adapter.js shimming safari.');
      // Export to the adapter global object visible in the browser.
      adapter.browserShim = safariShim;
      commonShim.shimCreateObjectURL(window);

      safariShim.shimRTCIceServerUrls(window);
      safariShim.shimCreateOfferLegacy(window);
      safariShim.shimCallbacksAPI(window);
      safariShim.shimLocalStreamsAPI(window);
      safariShim.shimRemoteStreamsAPI(window);
      safariShim.shimTrackEventTransceiver(window);
      safariShim.shimGetUserMedia(window);

      commonShim.shimRTCIceCandidate(window);
      commonShim.shimMaxMessageSize(window);
      commonShim.shimSendThrowTypeError(window);
      break;
    default:
      logging('Unsupported browser!');
      break;
  }

  return adapter;
};

},{"./chrome/chrome_shim":5,"./common_shim":7,"./edge/edge_shim":8,"./firefox/firefox_shim":11,"./safari/safari_shim":13,"./utils":14}],5:[function(require,module,exports){

/*
 *  Copyright (c) 2016 The WebRTC project authors. All Rights Reserved.
 *
 *  Use of this source code is governed by a BSD-style license
 *  that can be found in the LICENSE file in the root of the source
 *  tree.
 */
 /* eslint-env node */
'use strict';
var utils = require('../utils.js');
var logging = utils.log;

/* iterates the stats graph recursively. */
function walkStats(stats, base, resultSet) {
  if (!base || resultSet.has(base.id)) {
    return;
  }
  resultSet.set(base.id, base);
  Object.keys(base).forEach(function(name) {
    if (name.endsWith('Id')) {
      walkStats(stats, stats.get(base[name]), resultSet);
    } else if (name.endsWith('Ids')) {
      base[name].forEach(function(id) {
        walkStats(stats, stats.get(id), resultSet);
      });
    }
  });
}

/* filter getStats for a sender/receiver track. */
function filterStats(result, track, outbound) {
  var streamStatsType = outbound ? 'outbound-rtp' : 'inbound-rtp';
  var filteredResult = new Map();
  if (track === null) {
    return filteredResult;
  }
  var trackStats = [];
  result.forEach(function(value) {
    if (value.type === 'track' &&
        value.trackIdentifier === track.id) {
      trackStats.push(value);
    }
  });
  trackStats.forEach(function(trackStat) {
    result.forEach(function(stats) {
      if (stats.type === streamStatsType && stats.trackId === trackStat.id) {
        walkStats(result, stats, filteredResult);
      }
    });
  });
  return filteredResult;
}

module.exports = {
  shimGetUserMedia: require('./getusermedia'),
  shimMediaStream: function(window) {
    window.MediaStream = window.MediaStream || window.webkitMediaStream;
  },

  shimOnTrack: function(window) {
    if (typeof window === 'object' && window.RTCPeerConnection && !('ontrack' in
        window.RTCPeerConnection.prototype)) {
      Object.defineProperty(window.RTCPeerConnection.prototype, 'ontrack', {
        get: function() {
          return this._ontrack;
        },
        set: function(f) {
          if (this._ontrack) {
            this.removeEventListener('track', this._ontrack);
          }
          this.addEventListener('track', this._ontrack = f);
        },
        enumerable: true,
        configurable: true
      });
      var origSetRemoteDescription =
          window.RTCPeerConnection.prototype.setRemoteDescription;
      window.RTCPeerConnection.prototype.setRemoteDescription = function() {
        var pc = this;
        if (!pc._ontrackpoly) {
          pc._ontrackpoly = function(e) {
            // onaddstream does not fire when a track is added to an existing
            // stream. But stream.onaddtrack is implemented so we use that.
            e.stream.addEventListener('addtrack', function(te) {
              var receiver;
              if (window.RTCPeerConnection.prototype.getReceivers) {
                receiver = pc.getReceivers().find(function(r) {
                  return r.track && r.track.id === te.track.id;
                });
              } else {
                receiver = {track: te.track};
              }

              var event = new Event('track');
              event.track = te.track;
              event.receiver = receiver;
              event.transceiver = {receiver: receiver};
              event.streams = [e.stream];
              pc.dispatchEvent(event);
            });
            e.stream.getTracks().forEach(function(track) {
              var receiver;
              if (window.RTCPeerConnection.prototype.getReceivers) {
                receiver = pc.getReceivers().find(function(r) {
                  return r.track && r.track.id === track.id;
                });
              } else {
                receiver = {track: track};
              }
              var event = new Event('track');
              event.track = track;
              event.receiver = receiver;
              event.transceiver = {receiver: receiver};
              event.streams = [e.stream];
              pc.dispatchEvent(event);
            });
          };
          pc.addEventListener('addstream', pc._ontrackpoly);
        }
        return origSetRemoteDescription.apply(pc, arguments);
      };
    } else if (!('RTCRtpTransceiver' in window)) {
      utils.wrapPeerConnectionEvent(window, 'track', function(e) {
        if (!e.transceiver) {
          e.transceiver = {receiver: e.receiver};
        }
        return e;
      });
    }
  },

  shimGetSendersWithDtmf: function(window) {
    // Overrides addTrack/removeTrack, depends on shimAddTrackRemoveTrack.
    if (typeof window === 'object' && window.RTCPeerConnection &&
        !('getSenders' in window.RTCPeerConnection.prototype) &&
        'createDTMFSender' in window.RTCPeerConnection.prototype) {
      var shimSenderWithDtmf = function(pc, track) {
        return {
          track: track,
          get dtmf() {
            if (this._dtmf === undefined) {
              if (track.kind === 'audio') {
                this._dtmf = pc.createDTMFSender(track);
              } else {
                this._dtmf = null;
              }
            }
            return this._dtmf;
          },
          _pc: pc
        };
      };

      // augment addTrack when getSenders is not available.
      if (!window.RTCPeerConnection.prototype.getSenders) {
        window.RTCPeerConnection.prototype.getSenders = function() {
          this._senders = this._senders || [];
          return this._senders.slice(); // return a copy of the internal state.
        };
        var origAddTrack = window.RTCPeerConnection.prototype.addTrack;
        window.RTCPeerConnection.prototype.addTrack = function(track, stream) {
          var pc = this;
          var sender = origAddTrack.apply(pc, arguments);
          if (!sender) {
            sender = shimSenderWithDtmf(pc, track);
            pc._senders.push(sender);
          }
          return sender;
        };

        var origRemoveTrack = window.RTCPeerConnection.prototype.removeTrack;
        window.RTCPeerConnection.prototype.removeTrack = function(sender) {
          var pc = this;
          origRemoveTrack.apply(pc, arguments);
          var idx = pc._senders.indexOf(sender);
          if (idx !== -1) {
            pc._senders.splice(idx, 1);
          }
        };
      }
      var origAddStream = window.RTCPeerConnection.prototype.addStream;
      window.RTCPeerConnection.prototype.addStream = function(stream) {
        var pc = this;
        pc._senders = pc._senders || [];
        origAddStream.apply(pc, [stream]);
        stream.getTracks().forEach(function(track) {
          pc._senders.push(shimSenderWithDtmf(pc, track));
        });
      };

      var origRemoveStream = window.RTCPeerConnection.prototype.removeStream;
      window.RTCPeerConnection.prototype.removeStream = function(stream) {
        var pc = this;
        pc._senders = pc._senders || [];
        origRemoveStream.apply(pc, [stream]);

        stream.getTracks().forEach(function(track) {
          var sender = pc._senders.find(function(s) {
            return s.track === track;
          });
          if (sender) {
            pc._senders.splice(pc._senders.indexOf(sender), 1); // remove sender
          }
        });
      };
    } else if (typeof window === 'object' && window.RTCPeerConnection &&
               'getSenders' in window.RTCPeerConnection.prototype &&
               'createDTMFSender' in window.RTCPeerConnection.prototype &&
               window.RTCRtpSender &&
               !('dtmf' in window.RTCRtpSender.prototype)) {
      var origGetSenders = window.RTCPeerConnection.prototype.getSenders;
      window.RTCPeerConnection.prototype.getSenders = function() {
        var pc = this;
        var senders = origGetSenders.apply(pc, []);
        senders.forEach(function(sender) {
          sender._pc = pc;
        });
        return senders;
      };

      Object.defineProperty(window.RTCRtpSender.prototype, 'dtmf', {
        get: function() {
          if (this._dtmf === undefined) {
            if (this.track.kind === 'audio') {
              this._dtmf = this._pc.createDTMFSender(this.track);
            } else {
              this._dtmf = null;
            }
          }
          return this._dtmf;
        }
      });
    }
  },

  shimSenderReceiverGetStats: function(window) {
    if (!(typeof window === 'object' && window.RTCPeerConnection &&
        window.RTCRtpSender && window.RTCRtpReceiver)) {
      return;
    }

    // shim sender stats.
    if (!('getStats' in window.RTCRtpSender.prototype)) {
      var origGetSenders = window.RTCPeerConnection.prototype.getSenders;
      if (origGetSenders) {
        window.RTCPeerConnection.prototype.getSenders = function() {
          var pc = this;
          var senders = origGetSenders.apply(pc, []);
          senders.forEach(function(sender) {
            sender._pc = pc;
          });
          return senders;
        };
      }

      var origAddTrack = window.RTCPeerConnection.prototype.addTrack;
      if (origAddTrack) {
        window.RTCPeerConnection.prototype.addTrack = function() {
          var sender = origAddTrack.apply(this, arguments);
          sender._pc = this;
          return sender;
        };
      }
      window.RTCRtpSender.prototype.getStats = function() {
        var sender = this;
        return this._pc.getStats().then(function(result) {
          /* Note: this will include stats of all senders that
           *   send a track with the same id as sender.track as
           *   it is not possible to identify the RTCRtpSender.
           */
          return filterStats(result, sender.track, true);
        });
      };
    }

    // shim receiver stats.
    if (!('getStats' in window.RTCRtpReceiver.prototype)) {
      var origGetReceivers = window.RTCPeerConnection.prototype.getReceivers;
      if (origGetReceivers) {
        window.RTCPeerConnection.prototype.getReceivers = function() {
          var pc = this;
          var receivers = origGetReceivers.apply(pc, []);
          receivers.forEach(function(receiver) {
            receiver._pc = pc;
          });
          return receivers;
        };
      }
      utils.wrapPeerConnectionEvent(window, 'track', function(e) {
        e.receiver._pc = e.srcElement;
        return e;
      });
      window.RTCRtpReceiver.prototype.getStats = function() {
        var receiver = this;
        return this._pc.getStats().then(function(result) {
          return filterStats(result, receiver.track, false);
        });
      };
    }

    if (!('getStats' in window.RTCRtpSender.prototype &&
        'getStats' in window.RTCRtpReceiver.prototype)) {
      return;
    }

    // shim RTCPeerConnection.getStats(track).
    var origGetStats = window.RTCPeerConnection.prototype.getStats;
    window.RTCPeerConnection.prototype.getStats = function() {
      var pc = this;
      if (arguments.length > 0 &&
          arguments[0] instanceof window.MediaStreamTrack) {
        var track = arguments[0];
        var sender;
        var receiver;
        var err;
        pc.getSenders().forEach(function(s) {
          if (s.track === track) {
            if (sender) {
              err = true;
            } else {
              sender = s;
            }
          }
        });
        pc.getReceivers().forEach(function(r) {
          if (r.track === track) {
            if (receiver) {
              err = true;
            } else {
              receiver = r;
            }
          }
          return r.track === track;
        });
        if (err || (sender && receiver)) {
          return Promise.reject(new DOMException(
            'There are more than one sender or receiver for the track.',
            'InvalidAccessError'));
        } else if (sender) {
          return sender.getStats();
        } else if (receiver) {
          return receiver.getStats();
        }
        return Promise.reject(new DOMException(
          'There is no sender or receiver for the track.',
          'InvalidAccessError'));
      }
      return origGetStats.apply(pc, arguments);
    };
  },

  shimSourceObject: function(window) {
    var URL = window && window.URL;

    if (typeof window === 'object') {
      if (window.HTMLMediaElement &&
        !('srcObject' in window.HTMLMediaElement.prototype)) {
        // Shim the srcObject property, once, when HTMLMediaElement is found.
        Object.defineProperty(window.HTMLMediaElement.prototype, 'srcObject', {
          get: function() {
            return this._srcObject;
          },
          set: function(stream) {
            var self = this;
            // Use _srcObject as a private property for this shim
            this._srcObject = stream;
            if (this.src) {
              URL.revokeObjectURL(this.src);
            }

            if (!stream) {
              this.src = '';
              return undefined;
            }
            this.src = URL.createObjectURL(stream);
            // We need to recreate the blob url when a track is added or
            // removed. Doing it manually since we want to avoid a recursion.
            stream.addEventListener('addtrack', function() {
              if (self.src) {
                URL.revokeObjectURL(self.src);
              }
              self.src = URL.createObjectURL(stream);
            });
            stream.addEventListener('removetrack', function() {
              if (self.src) {
                URL.revokeObjectURL(self.src);
              }
              self.src = URL.createObjectURL(stream);
            });
          }
        });
      }
    }
  },

  shimAddTrackRemoveTrackWithNative: function(window) {
    // shim addTrack/removeTrack with native variants in order to make
    // the interactions with legacy getLocalStreams behave as in other browsers.
    // Keeps a mapping stream.id => [stream, rtpsenders...]
    window.RTCPeerConnection.prototype.getLocalStreams = function() {
      var pc = this;
      this._shimmedLocalStreams = this._shimmedLocalStreams || {};
      return Object.keys(this._shimmedLocalStreams).map(function(streamId) {
        return pc._shimmedLocalStreams[streamId][0];
      });
    };

    var origAddTrack = window.RTCPeerConnection.prototype.addTrack;
    window.RTCPeerConnection.prototype.addTrack = function(track, stream) {
      if (!stream) {
        return origAddTrack.apply(this, arguments);
      }
      this._shimmedLocalStreams = this._shimmedLocalStreams || {};

      var sender = origAddTrack.apply(this, arguments);
      if (!this._shimmedLocalStreams[stream.id]) {
        this._shimmedLocalStreams[stream.id] = [stream, sender];
      } else if (this._shimmedLocalStreams[stream.id].indexOf(sender) === -1) {
        this._shimmedLocalStreams[stream.id].push(sender);
      }
      return sender;
    };

    var origAddStream = window.RTCPeerConnection.prototype.addStream;
    window.RTCPeerConnection.prototype.addStream = function(stream) {
      var pc = this;
      this._shimmedLocalStreams = this._shimmedLocalStreams || {};

      stream.getTracks().forEach(function(track) {
        var alreadyExists = pc.getSenders().find(function(s) {
          return s.track === track;
        });
        if (alreadyExists) {
          throw new DOMException('Track already exists.',
              'InvalidAccessError');
        }
      });
      var existingSenders = pc.getSenders();
      origAddStream.apply(this, arguments);
      var newSenders = pc.getSenders().filter(function(newSender) {
        return existingSenders.indexOf(newSender) === -1;
      });
      this._shimmedLocalStreams[stream.id] = [stream].concat(newSenders);
    };

    var origRemoveStream = window.RTCPeerConnection.prototype.removeStream;
    window.RTCPeerConnection.prototype.removeStream = function(stream) {
      this._shimmedLocalStreams = this._shimmedLocalStreams || {};
      delete this._shimmedLocalStreams[stream.id];
      return origRemoveStream.apply(this, arguments);
    };

    var origRemoveTrack = window.RTCPeerConnection.prototype.removeTrack;
    window.RTCPeerConnection.prototype.removeTrack = function(sender) {
      var pc = this;
      this._shimmedLocalStreams = this._shimmedLocalStreams || {};
      if (sender) {
        Object.keys(this._shimmedLocalStreams).forEach(function(streamId) {
          var idx = pc._shimmedLocalStreams[streamId].indexOf(sender);
          if (idx !== -1) {
            pc._shimmedLocalStreams[streamId].splice(idx, 1);
          }
          if (pc._shimmedLocalStreams[streamId].length === 1) {
            delete pc._shimmedLocalStreams[streamId];
          }
        });
      }
      return origRemoveTrack.apply(this, arguments);
    };
  },

  shimAddTrackRemoveTrack: function(window) {
    var browserDetails = utils.detectBrowser(window);
    // shim addTrack and removeTrack.
    if (window.RTCPeerConnection.prototype.addTrack &&
        browserDetails.version >= 65) {
      return this.shimAddTrackRemoveTrackWithNative(window);
    }

    // also shim pc.getLocalStreams when addTrack is shimmed
    // to return the original streams.
    var origGetLocalStreams = window.RTCPeerConnection.prototype
        .getLocalStreams;
    window.RTCPeerConnection.prototype.getLocalStreams = function() {
      var pc = this;
      var nativeStreams = origGetLocalStreams.apply(this);
      pc._reverseStreams = pc._reverseStreams || {};
      return nativeStreams.map(function(stream) {
        return pc._reverseStreams[stream.id];
      });
    };

    var origAddStream = window.RTCPeerConnection.prototype.addStream;
    window.RTCPeerConnection.prototype.addStream = function(stream) {
      var pc = this;
      pc._streams = pc._streams || {};
      pc._reverseStreams = pc._reverseStreams || {};

      stream.getTracks().forEach(function(track) {
        var alreadyExists = pc.getSenders().find(function(s) {
          return s.track === track;
        });
        if (alreadyExists) {
          throw new DOMException('Track already exists.',
              'InvalidAccessError');
        }
      });
      // Add identity mapping for consistency with addTrack.
      // Unless this is being used with a stream from addTrack.
      if (!pc._reverseStreams[stream.id]) {
        var newStream = new window.MediaStream(stream.getTracks());
        pc._streams[stream.id] = newStream;
        pc._reverseStreams[newStream.id] = stream;
        stream = newStream;
      }
      origAddStream.apply(pc, [stream]);
    };

    var origRemoveStream = window.RTCPeerConnection.prototype.removeStream;
    window.RTCPeerConnection.prototype.removeStream = function(stream) {
      var pc = this;
      pc._streams = pc._streams || {};
      pc._reverseStreams = pc._reverseStreams || {};

      origRemoveStream.apply(pc, [(pc._streams[stream.id] || stream)]);
      delete pc._reverseStreams[(pc._streams[stream.id] ?
          pc._streams[stream.id].id : stream.id)];
      delete pc._streams[stream.id];
    };

    window.RTCPeerConnection.prototype.addTrack = function(track, stream) {
      var pc = this;
      if (pc.signalingState === 'closed') {
        throw new DOMException(
          'The RTCPeerConnection\'s signalingState is \'closed\'.',
          'InvalidStateError');
      }
      var streams = [].slice.call(arguments, 1);
      if (streams.length !== 1 ||
          !streams[0].getTracks().find(function(t) {
            return t === track;
          })) {
        // this is not fully correct but all we can manage without
        // [[associated MediaStreams]] internal slot.
        throw new DOMException(
          'The adapter.js addTrack polyfill only supports a single ' +
          ' stream which is associated with the specified track.',
          'NotSupportedError');
      }

      var alreadyExists = pc.getSenders().find(function(s) {
        return s.track === track;
      });
      if (alreadyExists) {
        throw new DOMException('Track already exists.',
            'InvalidAccessError');
      }

      pc._streams = pc._streams || {};
      pc._reverseStreams = pc._reverseStreams || {};
      var oldStream = pc._streams[stream.id];
      if (oldStream) {
        // this is using odd Chrome behaviour, use with caution:
        // https://bugs.chromium.org/p/webrtc/issues/detail?id=7815
        // Note: we rely on the high-level addTrack/dtmf shim to
        // create the sender with a dtmf sender.
        oldStream.addTrack(track);

        // Trigger ONN async.
        Promise.resolve().then(function() {
          pc.dispatchEvent(new Event('negotiationneeded'));
        });
      } else {
        var newStream = new window.MediaStream([track]);
        pc._streams[stream.id] = newStream;
        pc._reverseStreams[newStream.id] = stream;
        pc.addStream(newStream);
      }
      return pc.getSenders().find(function(s) {
        return s.track === track;
      });
    };

    // replace the internal stream id with the external one and
    // vice versa.
    function replaceInternalStreamId(pc, description) {
      var sdp = description.sdp;
      Object.keys(pc._reverseStreams || []).forEach(function(internalId) {
        var externalStream = pc._reverseStreams[internalId];
        var internalStream = pc._streams[externalStream.id];
        sdp = sdp.replace(new RegExp(internalStream.id, 'g'),
            externalStream.id);
      });
      return new RTCSessionDescription({
        type: description.type,
        sdp: sdp
      });
    }
    function replaceExternalStreamId(pc, description) {
      var sdp = description.sdp;
      Object.keys(pc._reverseStreams || []).forEach(function(internalId) {
        var externalStream = pc._reverseStreams[internalId];
        var internalStream = pc._streams[externalStream.id];
        sdp = sdp.replace(new RegExp(externalStream.id, 'g'),
            internalStream.id);
      });
      return new RTCSessionDescription({
        type: description.type,
        sdp: sdp
      });
    }
    ['createOffer', 'createAnswer'].forEach(function(method) {
      var nativeMethod = window.RTCPeerConnection.prototype[method];
      window.RTCPeerConnection.prototype[method] = function() {
        var pc = this;
        var args = arguments;
        var isLegacyCall = arguments.length &&
            typeof arguments[0] === 'function';
        if (isLegacyCall) {
          return nativeMethod.apply(pc, [
            function(description) {
              var desc = replaceInternalStreamId(pc, description);
              args[0].apply(null, [desc]);
            },
            function(err) {
              if (args[1]) {
                args[1].apply(null, err);
              }
            }, arguments[2]
          ]);
        }
        return nativeMethod.apply(pc, arguments)
        .then(function(description) {
          return replaceInternalStreamId(pc, description);
        });
      };
    });

    var origSetLocalDescription =
        window.RTCPeerConnection.prototype.setLocalDescription;
    window.RTCPeerConnection.prototype.setLocalDescription = function() {
      var pc = this;
      if (!arguments.length || !arguments[0].type) {
        return origSetLocalDescription.apply(pc, arguments);
      }
      arguments[0] = replaceExternalStreamId(pc, arguments[0]);
      return origSetLocalDescription.apply(pc, arguments);
    };

    // TODO: mangle getStats: https://w3c.github.io/webrtc-stats/#dom-rtcmediastreamstats-streamidentifier

    var origLocalDescription = Object.getOwnPropertyDescriptor(
        window.RTCPeerConnection.prototype, 'localDescription');
    Object.defineProperty(window.RTCPeerConnection.prototype,
        'localDescription', {
          get: function() {
            var pc = this;
            var description = origLocalDescription.get.apply(this);
            if (description.type === '') {
              return description;
            }
            return replaceInternalStreamId(pc, description);
          }
        });

    window.RTCPeerConnection.prototype.removeTrack = function(sender) {
      var pc = this;
      if (pc.signalingState === 'closed') {
        throw new DOMException(
          'The RTCPeerConnection\'s signalingState is \'closed\'.',
          'InvalidStateError');
      }
      // We can not yet check for sender instanceof RTCRtpSender
      // since we shim RTPSender. So we check if sender._pc is set.
      if (!sender._pc) {
        throw new DOMException('Argument 1 of RTCPeerConnection.removeTrack ' +
            'does not implement interface RTCRtpSender.', 'TypeError');
      }
      var isLocal = sender._pc === pc;
      if (!isLocal) {
        throw new DOMException('Sender was not created by this connection.',
            'InvalidAccessError');
      }

      // Search for the native stream the senders track belongs to.
      pc._streams = pc._streams || {};
      var stream;
      Object.keys(pc._streams).forEach(function(streamid) {
        var hasTrack = pc._streams[streamid].getTracks().find(function(track) {
          return sender.track === track;
        });
        if (hasTrack) {
          stream = pc._streams[streamid];
        }
      });

      if (stream) {
        if (stream.getTracks().length === 1) {
          // if this is the last track of the stream, remove the stream. This
          // takes care of any shimmed _senders.
          pc.removeStream(pc._reverseStreams[stream.id]);
        } else {
          // relying on the same odd chrome behaviour as above.
          stream.removeTrack(sender.track);
        }
        pc.dispatchEvent(new Event('negotiationneeded'));
      }
    };
  },

  shimPeerConnection: function(window) {
    var browserDetails = utils.detectBrowser(window);

    // The RTCPeerConnection object.
    if (!window.RTCPeerConnection && window.webkitRTCPeerConnection) {
      window.RTCPeerConnection = function(pcConfig, pcConstraints) {
        // Translate iceTransportPolicy to iceTransports,
        // see https://code.google.com/p/webrtc/issues/detail?id=4869
        // this was fixed in M56 along with unprefixing RTCPeerConnection.
        logging('PeerConnection');
        if (pcConfig && pcConfig.iceTransportPolicy) {
          pcConfig.iceTransports = pcConfig.iceTransportPolicy;
        }

        return new window.webkitRTCPeerConnection(pcConfig, pcConstraints);
      };
      window.RTCPeerConnection.prototype =
          window.webkitRTCPeerConnection.prototype;
      // wrap static methods. Currently just generateCertificate.
      if (window.webkitRTCPeerConnection.generateCertificate) {
        Object.defineProperty(window.RTCPeerConnection, 'generateCertificate', {
          get: function() {
            return window.webkitRTCPeerConnection.generateCertificate;
          }
        });
      }
    } else {
      // migrate from non-spec RTCIceServer.url to RTCIceServer.urls
      var OrigPeerConnection = window.RTCPeerConnection;
      window.RTCPeerConnection = function(pcConfig, pcConstraints) {
        if (pcConfig && pcConfig.iceServers) {
          var newIceServers = [];
          for (var i = 0; i < pcConfig.iceServers.length; i++) {
            var server = pcConfig.iceServers[i];
            if (!server.hasOwnProperty('urls') &&
                server.hasOwnProperty('url')) {
              utils.deprecated('RTCIceServer.url', 'RTCIceServer.urls');
              server = JSON.parse(JSON.stringify(server));
              server.urls = server.url;
              newIceServers.push(server);
            } else {
              newIceServers.push(pcConfig.iceServers[i]);
            }
          }
          pcConfig.iceServers = newIceServers;
        }
        return new OrigPeerConnection(pcConfig, pcConstraints);
      };
      window.RTCPeerConnection.prototype = OrigPeerConnection.prototype;
      // wrap static methods. Currently just generateCertificate.
      Object.defineProperty(window.RTCPeerConnection, 'generateCertificate', {
        get: function() {
          return OrigPeerConnection.generateCertificate;
        }
      });
    }

    var origGetStats = window.RTCPeerConnection.prototype.getStats;
    window.RTCPeerConnection.prototype.getStats = function(selector,
        successCallback, errorCallback) {
      var pc = this;
      var args = arguments;

      // If selector is a function then we are in the old style stats so just
      // pass back the original getStats format to avoid breaking old users.
      if (arguments.length > 0 && typeof selector === 'function') {
        return origGetStats.apply(this, arguments);
      }

      // When spec-style getStats is supported, return those when called with
      // either no arguments or the selector argument is null.
      if (origGetStats.length === 0 && (arguments.length === 0 ||
          typeof arguments[0] !== 'function')) {
        return origGetStats.apply(this, []);
      }

      var fixChromeStats_ = function(response) {
        var standardReport = {};
        var reports = response.result();
        reports.forEach(function(report) {
          var standardStats = {
            id: report.id,
            timestamp: report.timestamp,
            type: {
              localcandidate: 'local-candidate',
              remotecandidate: 'remote-candidate'
            }[report.type] || report.type
          };
          report.names().forEach(function(name) {
            standardStats[name] = report.stat(name);
          });
          standardReport[standardStats.id] = standardStats;
        });

        return standardReport;
      };

      // shim getStats with maplike support
      var makeMapStats = function(stats) {
        return new Map(Object.keys(stats).map(function(key) {
          return [key, stats[key]];
        }));
      };

      if (arguments.length >= 2) {
        var successCallbackWrapper_ = function(response) {
          args[1](makeMapStats(fixChromeStats_(response)));
        };

        return origGetStats.apply(this, [successCallbackWrapper_,
          arguments[0]]);
      }

      // promise-support
      return new Promise(function(resolve, reject) {
        origGetStats.apply(pc, [
          function(response) {
            resolve(makeMapStats(fixChromeStats_(response)));
          }, reject]);
      }).then(successCallback, errorCallback);
    };

    // add promise support -- natively available in Chrome 51
    if (browserDetails.version < 51) {
      ['setLocalDescription', 'setRemoteDescription', 'addIceCandidate']
          .forEach(function(method) {
            var nativeMethod = window.RTCPeerConnection.prototype[method];
            window.RTCPeerConnection.prototype[method] = function() {
              var args = arguments;
              var pc = this;
              var promise = new Promise(function(resolve, reject) {
                nativeMethod.apply(pc, [args[0], resolve, reject]);
              });
              if (args.length < 2) {
                return promise;
              }
              return promise.then(function() {
                args[1].apply(null, []);
              },
              function(err) {
                if (args.length >= 3) {
                  args[2].apply(null, [err]);
                }
              });
            };
          });
    }

    // promise support for createOffer and createAnswer. Available (without
    // bugs) since M52: crbug/619289
    if (browserDetails.version < 52) {
      ['createOffer', 'createAnswer'].forEach(function(method) {
        var nativeMethod = window.RTCPeerConnection.prototype[method];
        window.RTCPeerConnection.prototype[method] = function() {
          var pc = this;
          if (arguments.length < 1 || (arguments.length === 1 &&
              typeof arguments[0] === 'object')) {
            var opts = arguments.length === 1 ? arguments[0] : undefined;
            return new Promise(function(resolve, reject) {
              nativeMethod.apply(pc, [resolve, reject, opts]);
            });
          }
          return nativeMethod.apply(this, arguments);
        };
      });
    }

    // shim implicit creation of RTCSessionDescription/RTCIceCandidate
    ['setLocalDescription', 'setRemoteDescription', 'addIceCandidate']
        .forEach(function(method) {
          var nativeMethod = window.RTCPeerConnection.prototype[method];
          window.RTCPeerConnection.prototype[method] = function() {
            arguments[0] = new ((method === 'addIceCandidate') ?
                window.RTCIceCandidate :
                window.RTCSessionDescription)(arguments[0]);
            return nativeMethod.apply(this, arguments);
          };
        });

    // support for addIceCandidate(null or undefined)
    var nativeAddIceCandidate =
        window.RTCPeerConnection.prototype.addIceCandidate;
    window.RTCPeerConnection.prototype.addIceCandidate = function() {
      if (!arguments[0]) {
        if (arguments[1]) {
          arguments[1].apply(null);
        }
        return Promise.resolve();
      }
      return nativeAddIceCandidate.apply(this, arguments);
    };
  },

  fixNegotiationNeeded: function(window) {
    utils.wrapPeerConnectionEvent(window, 'negotiationneeded', function(e) {
      var pc = e.target;
      if (pc.signalingState !== 'stable') {
        return;
      }
      return e;
    });
  },

  shimGetDisplayMedia: function(window, getSourceId) {
    if ('getDisplayMedia' in window.navigator) {
      return;
    }
    // getSourceId is a function that returns a promise resolving with
    // the sourceId of the screen/window/tab to be shared.
    if (typeof getSourceId !== 'function') {
      console.error('shimGetDisplayMedia: getSourceId argument is not ' +
          'a function');
      return;
    }
    navigator.getDisplayMedia = function(constraints) {
      return getSourceId(constraints)
        .then(function(sourceId) {
          constraints.video = {
            mandatory: {
              chromeMediaSource: 'desktop',
              chromeMediaSourceId: sourceId,
              maxFrameRate: constraints.video.frameRate || 3
            }
          };
          return navigator.mediaDevices.getUserMedia(constraints);
        });
    };
  }
};

},{"../utils.js":14,"./getusermedia":6}],6:[function(require,module,exports){
/*
 *  Copyright (c) 2016 The WebRTC project authors. All Rights Reserved.
 *
 *  Use of this source code is governed by a BSD-style license
 *  that can be found in the LICENSE file in the root of the source
 *  tree.
 */
 /* eslint-env node */
'use strict';
var utils = require('../utils.js');
var logging = utils.log;

// Expose public methods.
module.exports = function(window) {
  var browserDetails = utils.detectBrowser(window);
  var navigator = window && window.navigator;

  var constraintsToChrome_ = function(c) {
    if (typeof c !== 'object' || c.mandatory || c.optional) {
      return c;
    }
    var cc = {};
    Object.keys(c).forEach(function(key) {
      if (key === 'require' || key === 'advanced' || key === 'mediaSource') {
        return;
      }
      var r = (typeof c[key] === 'object') ? c[key] : {ideal: c[key]};
      if (r.exact !== undefined && typeof r.exact === 'number') {
        r.min = r.max = r.exact;
      }
      var oldname_ = function(prefix, name) {
        if (prefix) {
          return prefix + name.charAt(0).toUpperCase() + name.slice(1);
        }
        return (name === 'deviceId') ? 'sourceId' : name;
      };
      if (r.ideal !== undefined) {
        cc.optional = cc.optional || [];
        var oc = {};
        if (typeof r.ideal === 'number') {
          oc[oldname_('min', key)] = r.ideal;
          cc.optional.push(oc);
          oc = {};
          oc[oldname_('max', key)] = r.ideal;
          cc.optional.push(oc);
        } else {
          oc[oldname_('', key)] = r.ideal;
          cc.optional.push(oc);
        }
      }
      if (r.exact !== undefined && typeof r.exact !== 'number') {
        cc.mandatory = cc.mandatory || {};
        cc.mandatory[oldname_('', key)] = r.exact;
      } else {
        ['min', 'max'].forEach(function(mix) {
          if (r[mix] !== undefined) {
            cc.mandatory = cc.mandatory || {};
            cc.mandatory[oldname_(mix, key)] = r[mix];
          }
        });
      }
    });
    if (c.advanced) {
      cc.optional = (cc.optional || []).concat(c.advanced);
    }
    return cc;
  };

  var shimConstraints_ = function(constraints, func) {
    if (browserDetails.version >= 61) {
      return func(constraints);
    }
    constraints = JSON.parse(JSON.stringify(constraints));
    if (constraints && typeof constraints.audio === 'object') {
      var remap = function(obj, a, b) {
        if (a in obj && !(b in obj)) {
          obj[b] = obj[a];
          delete obj[a];
        }
      };
      constraints = JSON.parse(JSON.stringify(constraints));
      remap(constraints.audio, 'autoGainControl', 'googAutoGainControl');
      remap(constraints.audio, 'noiseSuppression', 'googNoiseSuppression');
      constraints.audio = constraintsToChrome_(constraints.audio);
    }
    if (constraints && typeof constraints.video === 'object') {
      // Shim facingMode for mobile & surface pro.
      var face = constraints.video.facingMode;
      face = face && ((typeof face === 'object') ? face : {ideal: face});
      var getSupportedFacingModeLies = browserDetails.version < 66;

      if ((face && (face.exact === 'user' || face.exact === 'environment' ||
                    face.ideal === 'user' || face.ideal === 'environment')) &&
          !(navigator.mediaDevices.getSupportedConstraints &&
            navigator.mediaDevices.getSupportedConstraints().facingMode &&
            !getSupportedFacingModeLies)) {
        delete constraints.video.facingMode;
        var matches;
        if (face.exact === 'environment' || face.ideal === 'environment') {
          matches = ['back', 'rear'];
        } else if (face.exact === 'user' || face.ideal === 'user') {
          matches = ['front'];
        }
        if (matches) {
          // Look for matches in label, or use last cam for back (typical).
          return navigator.mediaDevices.enumerateDevices()
          .then(function(devices) {
            devices = devices.filter(function(d) {
              return d.kind === 'videoinput';
            });
            var dev = devices.find(function(d) {
              return matches.some(function(match) {
                return d.label.toLowerCase().indexOf(match) !== -1;
              });
            });
            if (!dev && devices.length && matches.indexOf('back') !== -1) {
              dev = devices[devices.length - 1]; // more likely the back cam
            }
            if (dev) {
              constraints.video.deviceId = face.exact ? {exact: dev.deviceId} :
                                                        {ideal: dev.deviceId};
            }
            constraints.video = constraintsToChrome_(constraints.video);
            logging('chrome: ' + JSON.stringify(constraints));
            return func(constraints);
          });
        }
      }
      constraints.video = constraintsToChrome_(constraints.video);
    }
    logging('chrome: ' + JSON.stringify(constraints));
    return func(constraints);
  };

  var shimError_ = function(e) {
    if (browserDetails.version >= 64) {
      return e;
    }
    return {
      name: {
        PermissionDeniedError: 'NotAllowedError',
        PermissionDismissedError: 'NotAllowedError',
        InvalidStateError: 'NotAllowedError',
        DevicesNotFoundError: 'NotFoundError',
        ConstraintNotSatisfiedError: 'OverconstrainedError',
        TrackStartError: 'NotReadableError',
        MediaDeviceFailedDueToShutdown: 'NotAllowedError',
        MediaDeviceKillSwitchOn: 'NotAllowedError',
        TabCaptureError: 'AbortError',
        ScreenCaptureError: 'AbortError',
        DeviceCaptureError: 'AbortError'
      }[e.name] || e.name,
      message: e.message,
      constraint: e.constraint || e.constraintName,
      toString: function() {
        return this.name + (this.message && ': ') + this.message;
      }
    };
  };

  var getUserMedia_ = function(constraints, onSuccess, onError) {
    shimConstraints_(constraints, function(c) {
      navigator.webkitGetUserMedia(c, onSuccess, function(e) {
        if (onError) {
          onError(shimError_(e));
        }
      });
    });
  };

  navigator.getUserMedia = getUserMedia_;

  // Returns the result of getUserMedia as a Promise.
  var getUserMediaPromise_ = function(constraints) {
    return new Promise(function(resolve, reject) {
      navigator.getUserMedia(constraints, resolve, reject);
    });
  };

  if (!navigator.mediaDevices) {
    navigator.mediaDevices = {
      getUserMedia: getUserMediaPromise_,
      enumerateDevices: function() {
        return new Promise(function(resolve) {
          var kinds = {audio: 'audioinput', video: 'videoinput'};
          return window.MediaStreamTrack.getSources(function(devices) {
            resolve(devices.map(function(device) {
              return {label: device.label,
                kind: kinds[device.kind],
                deviceId: device.id,
                groupId: ''};
            }));
          });
        });
      },
      getSupportedConstraints: function() {
        return {
          deviceId: true, echoCancellation: true, facingMode: true,
          frameRate: true, height: true, width: true
        };
      }
    };
  }

  // A shim for getUserMedia method on the mediaDevices object.
  // TODO(KaptenJansson) remove once implemented in Chrome stable.
  if (!navigator.mediaDevices.getUserMedia) {
    navigator.mediaDevices.getUserMedia = function(constraints) {
      return getUserMediaPromise_(constraints);
    };
  } else {
    // Even though Chrome 45 has navigator.mediaDevices and a getUserMedia
    // function which returns a Promise, it does not accept spec-style
    // constraints.
    var origGetUserMedia = navigator.mediaDevices.getUserMedia.
        bind(navigator.mediaDevices);
    navigator.mediaDevices.getUserMedia = function(cs) {
      return shimConstraints_(cs, function(c) {
        return origGetUserMedia(c).then(function(stream) {
          if (c.audio && !stream.getAudioTracks().length ||
              c.video && !stream.getVideoTracks().length) {
            stream.getTracks().forEach(function(track) {
              track.stop();
            });
            throw new DOMException('', 'NotFoundError');
          }
          return stream;
        }, function(e) {
          return Promise.reject(shimError_(e));
        });
      });
    };
  }

  // Dummy devicechange event methods.
  // TODO(KaptenJansson) remove once implemented in Chrome stable.
  if (typeof navigator.mediaDevices.addEventListener === 'undefined') {
    navigator.mediaDevices.addEventListener = function() {
      logging('Dummy mediaDevices.addEventListener called.');
    };
  }
  if (typeof navigator.mediaDevices.removeEventListener === 'undefined') {
    navigator.mediaDevices.removeEventListener = function() {
      logging('Dummy mediaDevices.removeEventListener called.');
    };
  }
};

},{"../utils.js":14}],7:[function(require,module,exports){
/*
 *  Copyright (c) 2017 The WebRTC project authors. All Rights Reserved.
 *
 *  Use of this source code is governed by a BSD-style license
 *  that can be found in the LICENSE file in the root of the source
 *  tree.
 */
 /* eslint-env node */
'use strict';

var SDPUtils = require('sdp');
var utils = require('./utils');

module.exports = {
  shimRTCIceCandidate: function(window) {
    // foundation is arbitrarily chosen as an indicator for full support for
    // https://w3c.github.io/webrtc-pc/#rtcicecandidate-interface
    if (!window.RTCIceCandidate || (window.RTCIceCandidate && 'foundation' in
        window.RTCIceCandidate.prototype)) {
      return;
    }

    var NativeRTCIceCandidate = window.RTCIceCandidate;
    window.RTCIceCandidate = function(args) {
      // Remove the a= which shouldn't be part of the candidate string.
      if (typeof args === 'object' && args.candidate &&
          args.candidate.indexOf('a=') === 0) {
        args = JSON.parse(JSON.stringify(args));
        args.candidate = args.candidate.substr(2);
      }

      if (args.candidate && args.candidate.length) {
        // Augment the native candidate with the parsed fields.
        var nativeCandidate = new NativeRTCIceCandidate(args);
        var parsedCandidate = SDPUtils.parseCandidate(args.candidate);
        var augmentedCandidate = Object.assign(nativeCandidate,
            parsedCandidate);

        // Add a serializer that does not serialize the extra attributes.
        augmentedCandidate.toJSON = function() {
          return {
            candidate: augmentedCandidate.candidate,
            sdpMid: augmentedCandidate.sdpMid,
            sdpMLineIndex: augmentedCandidate.sdpMLineIndex,
            usernameFragment: augmentedCandidate.usernameFragment,
          };
        };
        return augmentedCandidate;
      }
      return new NativeRTCIceCandidate(args);
    };
    window.RTCIceCandidate.prototype = NativeRTCIceCandidate.prototype;

    // Hook up the augmented candidate in onicecandidate and
    // addEventListener('icecandidate', ...)
    utils.wrapPeerConnectionEvent(window, 'icecandidate', function(e) {
      if (e.candidate) {
        Object.defineProperty(e, 'candidate', {
          value: new window.RTCIceCandidate(e.candidate),
          writable: 'false'
        });
      }
      return e;
    });
  },

  // shimCreateObjectURL must be called before shimSourceObject to avoid loop.

  shimCreateObjectURL: function(window) {
    var URL = window && window.URL;

    if (!(typeof window === 'object' && window.HTMLMediaElement &&
          'srcObject' in window.HTMLMediaElement.prototype &&
        URL.createObjectURL && URL.revokeObjectURL)) {
      // Only shim CreateObjectURL using srcObject if srcObject exists.
      return undefined;
    }

    var nativeCreateObjectURL = URL.createObjectURL.bind(URL);
    var nativeRevokeObjectURL = URL.revokeObjectURL.bind(URL);
    var streams = new Map(), newId = 0;

    URL.createObjectURL = function(stream) {
      if ('getTracks' in stream) {
        var url = 'polyblob:' + (++newId);
        streams.set(url, stream);
        utils.deprecated('URL.createObjectURL(stream)',
            'elem.srcObject = stream');
        return url;
      }
      return nativeCreateObjectURL(stream);
    };
    URL.revokeObjectURL = function(url) {
      nativeRevokeObjectURL(url);
      streams.delete(url);
    };

    var dsc = Object.getOwnPropertyDescriptor(window.HTMLMediaElement.prototype,
                                              'src');
    Object.defineProperty(window.HTMLMediaElement.prototype, 'src', {
      get: function() {
        return dsc.get.apply(this);
      },
      set: function(url) {
        this.srcObject = streams.get(url) || null;
        return dsc.set.apply(this, [url]);
      }
    });

    var nativeSetAttribute = window.HTMLMediaElement.prototype.setAttribute;
    window.HTMLMediaElement.prototype.setAttribute = function() {
      if (arguments.length === 2 &&
          ('' + arguments[0]).toLowerCase() === 'src') {
        this.srcObject = streams.get(arguments[1]) || null;
      }
      return nativeSetAttribute.apply(this, arguments);
    };
  },

  shimMaxMessageSize: function(window) {
    if (window.RTCSctpTransport || !window.RTCPeerConnection) {
      return;
    }
    var browserDetails = utils.detectBrowser(window);

    if (!('sctp' in window.RTCPeerConnection.prototype)) {
      Object.defineProperty(window.RTCPeerConnection.prototype, 'sctp', {
        get: function() {
          return typeof this._sctp === 'undefined' ? null : this._sctp;
        }
      });
    }

    var sctpInDescription = function(description) {
      var sections = SDPUtils.splitSections(description.sdp);
      sections.shift();
      return sections.some(function(mediaSection) {
        var mLine = SDPUtils.parseMLine(mediaSection);
        return mLine && mLine.kind === 'application'
            && mLine.protocol.indexOf('SCTP') !== -1;
      });
    };

    var getRemoteFirefoxVersion = function(description) {
      // TODO: Is there a better solution for detecting Firefox?
      var match = description.sdp.match(/mozilla...THIS_IS_SDPARTA-(\d+)/);
      if (match === null || match.length < 2) {
        return -1;
      }
      var version = parseInt(match[1], 10);
      // Test for NaN (yes, this is ugly)
      return version !== version ? -1 : version;
    };

    var getCanSendMaxMessageSize = function(remoteIsFirefox) {
      // Every implementation we know can send at least 64 KiB.
      // Note: Although Chrome is technically able to send up to 256 KiB, the
      //       data does not reach the other peer reliably.
      //       See: https://bugs.chromium.org/p/webrtc/issues/detail?id=8419
      var canSendMaxMessageSize = 65536;
      if (browserDetails.browser === 'firefox') {
        if (browserDetails.version < 57) {
          if (remoteIsFirefox === -1) {
            // FF < 57 will send in 16 KiB chunks using the deprecated PPID
            // fragmentation.
            canSendMaxMessageSize = 16384;
          } else {
            // However, other FF (and RAWRTC) can reassemble PPID-fragmented
            // messages. Thus, supporting ~2 GiB when sending.
            canSendMaxMessageSize = 2147483637;
          }
        } else if (browserDetails.version < 60) {
          // Currently, all FF >= 57 will reset the remote maximum message size
          // to the default value when a data channel is created at a later
          // stage. :(
          // See: https://bugzilla.mozilla.org/show_bug.cgi?id=1426831
          canSendMaxMessageSize =
            browserDetails.version === 57 ? 65535 : 65536;
        } else {
          // FF >= 60 supports sending ~2 GiB
          canSendMaxMessageSize = 2147483637;
        }
      }
      return canSendMaxMessageSize;
    };

    var getMaxMessageSize = function(description, remoteIsFirefox) {
      // Note: 65536 bytes is the default value from the SDP spec. Also,
      //       every implementation we know supports receiving 65536 bytes.
      var maxMessageSize = 65536;

      // FF 57 has a slightly incorrect default remote max message size, so
      // we need to adjust it here to avoid a failure when sending.
      // See: https://bugzilla.mozilla.org/show_bug.cgi?id=1425697
      if (browserDetails.browser === 'firefox'
           && browserDetails.version === 57) {
        maxMessageSize = 65535;
      }

      var match = SDPUtils.matchPrefix(description.sdp, 'a=max-message-size:');
      if (match.length > 0) {
        maxMessageSize = parseInt(match[0].substr(19), 10);
      } else if (browserDetails.browser === 'firefox' &&
                  remoteIsFirefox !== -1) {
        // If the maximum message size is not present in the remote SDP and
        // both local and remote are Firefox, the remote peer can receive
        // ~2 GiB.
        maxMessageSize = 2147483637;
      }
      return maxMessageSize;
    };

    var origSetRemoteDescription =
        window.RTCPeerConnection.prototype.setRemoteDescription;
    window.RTCPeerConnection.prototype.setRemoteDescription = function() {
      var pc = this;
      pc._sctp = null;

      if (sctpInDescription(arguments[0])) {
        // Check if the remote is FF.
        var isFirefox = getRemoteFirefoxVersion(arguments[0]);

        // Get the maximum message size the local peer is capable of sending
        var canSendMMS = getCanSendMaxMessageSize(isFirefox);

        // Get the maximum message size of the remote peer.
        var remoteMMS = getMaxMessageSize(arguments[0], isFirefox);

        // Determine final maximum message size
        var maxMessageSize;
        if (canSendMMS === 0 && remoteMMS === 0) {
          maxMessageSize = Number.POSITIVE_INFINITY;
        } else if (canSendMMS === 0 || remoteMMS === 0) {
          maxMessageSize = Math.max(canSendMMS, remoteMMS);
        } else {
          maxMessageSize = Math.min(canSendMMS, remoteMMS);
        }

        // Create a dummy RTCSctpTransport object and the 'maxMessageSize'
        // attribute.
        var sctp = {};
        Object.defineProperty(sctp, 'maxMessageSize', {
          get: function() {
            return maxMessageSize;
          }
        });
        pc._sctp = sctp;
      }

      return origSetRemoteDescription.apply(pc, arguments);
    };
  },

  shimSendThrowTypeError: function(window) {
    if (!(window.RTCPeerConnection &&
        'createDataChannel' in window.RTCPeerConnection.prototype)) {
      return;
    }

    // Note: Although Firefox >= 57 has a native implementation, the maximum
    //       message size can be reset for all data channels at a later stage.
    //       See: https://bugzilla.mozilla.org/show_bug.cgi?id=1426831

    function wrapDcSend(dc, pc) {
      var origDataChannelSend = dc.send;
      dc.send = function() {
        var data = arguments[0];
        var length = data.length || data.size || data.byteLength;
        if (dc.readyState === 'open' &&
            pc.sctp && length > pc.sctp.maxMessageSize) {
          throw new TypeError('Message too large (can send a maximum of ' +
            pc.sctp.maxMessageSize + ' bytes)');
        }
        return origDataChannelSend.apply(dc, arguments);
      };
    }
    var origCreateDataChannel =
      window.RTCPeerConnection.prototype.createDataChannel;
    window.RTCPeerConnection.prototype.createDataChannel = function() {
      var pc = this;
      var dataChannel = origCreateDataChannel.apply(pc, arguments);
      wrapDcSend(dataChannel, pc);
      return dataChannel;
    };
    utils.wrapPeerConnectionEvent(window, 'datachannel', function(e) {
      wrapDcSend(e.channel, e.target);
      return e;
    });
  }
};

},{"./utils":14,"sdp":2}],8:[function(require,module,exports){
/*
 *  Copyright (c) 2016 The WebRTC project authors. All Rights Reserved.
 *
 *  Use of this source code is governed by a BSD-style license
 *  that can be found in the LICENSE file in the root of the source
 *  tree.
 */
 /* eslint-env node */
'use strict';

var utils = require('../utils');
var filterIceServers = require('./filtericeservers');
var shimRTCPeerConnection = require('rtcpeerconnection-shim');

module.exports = {
  shimGetUserMedia: require('./getusermedia'),
  shimPeerConnection: function(window) {
    var browserDetails = utils.detectBrowser(window);

    if (window.RTCIceGatherer) {
      if (!window.RTCIceCandidate) {
        window.RTCIceCandidate = function(args) {
          return args;
        };
      }
      if (!window.RTCSessionDescription) {
        window.RTCSessionDescription = function(args) {
          return args;
        };
      }
      // this adds an additional event listener to MediaStrackTrack that signals
      // when a tracks enabled property was changed. Workaround for a bug in
      // addStream, see below. No longer required in 15025+
      if (browserDetails.version < 15025) {
        var origMSTEnabled = Object.getOwnPropertyDescriptor(
            window.MediaStreamTrack.prototype, 'enabled');
        Object.defineProperty(window.MediaStreamTrack.prototype, 'enabled', {
          set: function(value) {
            origMSTEnabled.set.call(this, value);
            var ev = new Event('enabled');
            ev.enabled = value;
            this.dispatchEvent(ev);
          }
        });
      }
    }

    // ORTC defines the DTMF sender a bit different.
    // https://github.com/w3c/ortc/issues/714
    if (window.RTCRtpSender && !('dtmf' in window.RTCRtpSender.prototype)) {
      Object.defineProperty(window.RTCRtpSender.prototype, 'dtmf', {
        get: function() {
          if (this._dtmf === undefined) {
            if (this.track.kind === 'audio') {
              this._dtmf = new window.RTCDtmfSender(this);
            } else if (this.track.kind === 'video') {
              this._dtmf = null;
            }
          }
          return this._dtmf;
        }
      });
    }
    // Edge currently only implements the RTCDtmfSender, not the
    // RTCDTMFSender alias. See http://draft.ortc.org/#rtcdtmfsender2*
    if (window.RTCDtmfSender && !window.RTCDTMFSender) {
      window.RTCDTMFSender = window.RTCDtmfSender;
    }

    var RTCPeerConnectionShim = shimRTCPeerConnection(window,
        browserDetails.version);
    window.RTCPeerConnection = function(config) {
      if (config && config.iceServers) {
        config.iceServers = filterIceServers(config.iceServers);
      }
      return new RTCPeerConnectionShim(config);
    };
    window.RTCPeerConnection.prototype = RTCPeerConnectionShim.prototype;
  },
  shimReplaceTrack: function(window) {
    // ORTC has replaceTrack -- https://github.com/w3c/ortc/issues/614
    if (window.RTCRtpSender &&
        !('replaceTrack' in window.RTCRtpSender.prototype)) {
      window.RTCRtpSender.prototype.replaceTrack =
          window.RTCRtpSender.prototype.setTrack;
    }
  }
};

},{"../utils":14,"./filtericeservers":9,"./getusermedia":10,"rtcpeerconnection-shim":1}],9:[function(require,module,exports){
/*
 *  Copyright (c) 2018 The WebRTC project authors. All Rights Reserved.
 *
 *  Use of this source code is governed by a BSD-style license
 *  that can be found in the LICENSE file in the root of the source
 *  tree.
 */
 /* eslint-env node */
'use strict';

var utils = require('../utils');
// Edge does not like
// 1) stun: filtered after 14393 unless ?transport=udp is present
// 2) turn: that does not have all of turn:host:port?transport=udp
// 3) turn: with ipv6 addresses
// 4) turn: occurring muliple times
module.exports = function(iceServers, edgeVersion) {
  var hasTurn = false;
  iceServers = JSON.parse(JSON.stringify(iceServers));
  return iceServers.filter(function(server) {
    if (server && (server.urls || server.url)) {
      var urls = server.urls || server.url;
      if (server.url && !server.urls) {
        utils.deprecated('RTCIceServer.url', 'RTCIceServer.urls');
      }
      var isString = typeof urls === 'string';
      if (isString) {
        urls = [urls];
      }
      urls = urls.filter(function(url) {
        var validTurn = url.indexOf('turn:') === 0 &&
            url.indexOf('transport=udp') !== -1 &&
            url.indexOf('turn:[') === -1 &&
            !hasTurn;

        if (validTurn) {
          hasTurn = true;
          return true;
        }
        return url.indexOf('stun:') === 0 && edgeVersion >= 14393 &&
            url.indexOf('?transport=udp') === -1;
      });

      delete server.url;
      server.urls = isString ? urls[0] : urls;
      return !!urls.length;
    }
  });
};

},{"../utils":14}],10:[function(require,module,exports){
/*
 *  Copyright (c) 2016 The WebRTC project authors. All Rights Reserved.
 *
 *  Use of this source code is governed by a BSD-style license
 *  that can be found in the LICENSE file in the root of the source
 *  tree.
 */
 /* eslint-env node */
'use strict';

// Expose public methods.
module.exports = function(window) {
  var navigator = window && window.navigator;

  var shimError_ = function(e) {
    return {
      name: {PermissionDeniedError: 'NotAllowedError'}[e.name] || e.name,
      message: e.message,
      constraint: e.constraint,
      toString: function() {
        return this.name;
      }
    };
  };

  // getUserMedia error shim.
  var origGetUserMedia = navigator.mediaDevices.getUserMedia.
      bind(navigator.mediaDevices);
  navigator.mediaDevices.getUserMedia = function(c) {
    return origGetUserMedia(c).catch(function(e) {
      return Promise.reject(shimError_(e));
    });
  };
};

},{}],11:[function(require,module,exports){
/*
 *  Copyright (c) 2016 The WebRTC project authors. All Rights Reserved.
 *
 *  Use of this source code is governed by a BSD-style license
 *  that can be found in the LICENSE file in the root of the source
 *  tree.
 */
 /* eslint-env node */
'use strict';

var utils = require('../utils');

module.exports = {
  shimGetUserMedia: require('./getusermedia'),
  shimOnTrack: function(window) {
    if (typeof window === 'object' && window.RTCPeerConnection && !('ontrack' in
        window.RTCPeerConnection.prototype)) {
      Object.defineProperty(window.RTCPeerConnection.prototype, 'ontrack', {
        get: function() {
          return this._ontrack;
        },
        set: function(f) {
          if (this._ontrack) {
            this.removeEventListener('track', this._ontrack);
            this.removeEventListener('addstream', this._ontrackpoly);
          }
          this.addEventListener('track', this._ontrack = f);
          this.addEventListener('addstream', this._ontrackpoly = function(e) {
            e.stream.getTracks().forEach(function(track) {
              var event = new Event('track');
              event.track = track;
              event.receiver = {track: track};
              event.transceiver = {receiver: event.receiver};
              event.streams = [e.stream];
              this.dispatchEvent(event);
            }.bind(this));
          }.bind(this));
        },
        enumerable: true,
        configurable: true
      });
    }
    if (typeof window === 'object' && window.RTCTrackEvent &&
        ('receiver' in window.RTCTrackEvent.prototype) &&
        !('transceiver' in window.RTCTrackEvent.prototype)) {
      Object.defineProperty(window.RTCTrackEvent.prototype, 'transceiver', {
        get: function() {
          return {receiver: this.receiver};
        }
      });
    }
  },

  shimSourceObject: function(window) {
    // Firefox has supported mozSrcObject since FF22, unprefixed in 42.
    if (typeof window === 'object') {
      if (window.HTMLMediaElement &&
        !('srcObject' in window.HTMLMediaElement.prototype)) {
        // Shim the srcObject property, once, when HTMLMediaElement is found.
        Object.defineProperty(window.HTMLMediaElement.prototype, 'srcObject', {
          get: function() {
            return this.mozSrcObject;
          },
          set: function(stream) {
            this.mozSrcObject = stream;
          }
        });
      }
    }
  },

  shimPeerConnection: function(window) {
    var browserDetails = utils.detectBrowser(window);

    if (typeof window !== 'object' || !(window.RTCPeerConnection ||
        window.mozRTCPeerConnection)) {
      return; // probably media.peerconnection.enabled=false in about:config
    }
    // The RTCPeerConnection object.
    if (!window.RTCPeerConnection) {
      window.RTCPeerConnection = function(pcConfig, pcConstraints) {
        if (browserDetails.version < 38) {
          // .urls is not supported in FF < 38.
          // create RTCIceServers with a single url.
          if (pcConfig && pcConfig.iceServers) {
            var newIceServers = [];
            for (var i = 0; i < pcConfig.iceServers.length; i++) {
              var server = pcConfig.iceServers[i];
              if (server.hasOwnProperty('urls')) {
                for (var j = 0; j < server.urls.length; j++) {
                  var newServer = {
                    url: server.urls[j]
                  };
                  if (server.urls[j].indexOf('turn') === 0) {
                    newServer.username = server.username;
                    newServer.credential = server.credential;
                  }
                  newIceServers.push(newServer);
                }
              } else {
                newIceServers.push(pcConfig.iceServers[i]);
              }
            }
            pcConfig.iceServers = newIceServers;
          }
        }
        return new window.mozRTCPeerConnection(pcConfig, pcConstraints);
      };
      window.RTCPeerConnection.prototype =
          window.mozRTCPeerConnection.prototype;

      // wrap static methods. Currently just generateCertificate.
      if (window.mozRTCPeerConnection.generateCertificate) {
        Object.defineProperty(window.RTCPeerConnection, 'generateCertificate', {
          get: function() {
            return window.mozRTCPeerConnection.generateCertificate;
          }
        });
      }

      window.RTCSessionDescription = window.mozRTCSessionDescription;
      window.RTCIceCandidate = window.mozRTCIceCandidate;
    }

    // shim away need for obsolete RTCIceCandidate/RTCSessionDescription.
    ['setLocalDescription', 'setRemoteDescription', 'addIceCandidate']
        .forEach(function(method) {
          var nativeMethod = window.RTCPeerConnection.prototype[method];
          window.RTCPeerConnection.prototype[method] = function() {
            arguments[0] = new ((method === 'addIceCandidate') ?
                window.RTCIceCandidate :
                window.RTCSessionDescription)(arguments[0]);
            return nativeMethod.apply(this, arguments);
          };
        });

    // support for addIceCandidate(null or undefined)
    var nativeAddIceCandidate =
        window.RTCPeerConnection.prototype.addIceCandidate;
    window.RTCPeerConnection.prototype.addIceCandidate = function() {
      if (!arguments[0]) {
        if (arguments[1]) {
          arguments[1].apply(null);
        }
        return Promise.resolve();
      }
      return nativeAddIceCandidate.apply(this, arguments);
    };

    // shim getStats with maplike support
    var makeMapStats = function(stats) {
      var map = new Map();
      Object.keys(stats).forEach(function(key) {
        map.set(key, stats[key]);
        map[key] = stats[key];
      });
      return map;
    };

    var modernStatsTypes = {
      inboundrtp: 'inbound-rtp',
      outboundrtp: 'outbound-rtp',
      candidatepair: 'candidate-pair',
      localcandidate: 'local-candidate',
      remotecandidate: 'remote-candidate'
    };

    var nativeGetStats = window.RTCPeerConnection.prototype.getStats;
    window.RTCPeerConnection.prototype.getStats = function(
      selector,
      onSucc,
      onErr
    ) {
      return nativeGetStats.apply(this, [selector || null])
        .then(function(stats) {
          if (browserDetails.version < 48) {
            stats = makeMapStats(stats);
          }
          if (browserDetails.version < 53 && !onSucc) {
            // Shim only promise getStats with spec-hyphens in type names
            // Leave callback version alone; misc old uses of forEach before Map
            try {
              stats.forEach(function(stat) {
                stat.type = modernStatsTypes[stat.type] || stat.type;
              });
            } catch (e) {
              if (e.name !== 'TypeError') {
                throw e;
              }
              // Avoid TypeError: "type" is read-only, in old versions. 34-43ish
              stats.forEach(function(stat, i) {
                stats.set(i, Object.assign({}, stat, {
                  type: modernStatsTypes[stat.type] || stat.type
                }));
              });
            }
          }
          return stats;
        })
        .then(onSucc, onErr);
    };
  },

  shimSenderGetStats: function(window) {
    if (!(typeof window === 'object' && window.RTCPeerConnection &&
        window.RTCRtpSender)) {
      return;
    }
    if (window.RTCRtpSender && 'getStats' in window.RTCRtpSender.prototype) {
      return;
    }
    var origGetSenders = window.RTCPeerConnection.prototype.getSenders;
    if (origGetSenders) {
      window.RTCPeerConnection.prototype.getSenders = function() {
        var pc = this;
        var senders = origGetSenders.apply(pc, []);
        senders.forEach(function(sender) {
          sender._pc = pc;
        });
        return senders;
      };
    }

    var origAddTrack = window.RTCPeerConnection.prototype.addTrack;
    if (origAddTrack) {
      window.RTCPeerConnection.prototype.addTrack = function() {
        var sender = origAddTrack.apply(this, arguments);
        sender._pc = this;
        return sender;
      };
    }
    window.RTCRtpSender.prototype.getStats = function() {
      return this.track ? this._pc.getStats(this.track) :
          Promise.resolve(new Map());
    };
  },

  shimReceiverGetStats: function(window) {
    if (!(typeof window === 'object' && window.RTCPeerConnection &&
        window.RTCRtpSender)) {
      return;
    }
    if (window.RTCRtpSender && 'getStats' in window.RTCRtpReceiver.prototype) {
      return;
    }
    var origGetReceivers = window.RTCPeerConnection.prototype.getReceivers;
    if (origGetReceivers) {
      window.RTCPeerConnection.prototype.getReceivers = function() {
        var pc = this;
        var receivers = origGetReceivers.apply(pc, []);
        receivers.forEach(function(receiver) {
          receiver._pc = pc;
        });
        return receivers;
      };
    }
    utils.wrapPeerConnectionEvent(window, 'track', function(e) {
      e.receiver._pc = e.srcElement;
      return e;
    });
    window.RTCRtpReceiver.prototype.getStats = function() {
      return this._pc.getStats(this.track);
    };
  },

  shimRemoveStream: function(window) {
    if (!window.RTCPeerConnection ||
        'removeStream' in window.RTCPeerConnection.prototype) {
      return;
    }
    window.RTCPeerConnection.prototype.removeStream = function(stream) {
      var pc = this;
      utils.deprecated('removeStream', 'removeTrack');
      this.getSenders().forEach(function(sender) {
        if (sender.track && stream.getTracks().indexOf(sender.track) !== -1) {
          pc.removeTrack(sender);
        }
      });
    };
  },

  shimRTCDataChannel: function(window) {
    // rename DataChannel to RTCDataChannel (native fix in FF60):
    // https://bugzilla.mozilla.org/show_bug.cgi?id=1173851
    if (window.DataChannel && !window.RTCDataChannel) {
      window.RTCDataChannel = window.DataChannel;
    }
  },

  shimGetDisplayMedia: function(window, preferredMediaSource) {
    if ('getDisplayMedia' in window.navigator) {
      return;
    }
    navigator.getDisplayMedia = function(constraints) {
      if (!(constraints && constraints.video)) {
        var err = new DOMException('getDisplayMedia without video ' +
            'constraints is undefined');
        err.name = 'NotFoundError';
        // from https://heycam.github.io/webidl/#idl-DOMException-error-names
        err.code = 8;
        return Promise.reject(err);
      }
      if (constraints.video === true) {
        constraints.video = {mediaSource: preferredMediaSource};
      } else {
        constraints.video.mediaSource = preferredMediaSource;
      }
      return navigator.mediaDevices.getUserMedia(constraints);
    };
  }
};

},{"../utils":14,"./getusermedia":12}],12:[function(require,module,exports){
/*
 *  Copyright (c) 2016 The WebRTC project authors. All Rights Reserved.
 *
 *  Use of this source code is governed by a BSD-style license
 *  that can be found in the LICENSE file in the root of the source
 *  tree.
 */
 /* eslint-env node */
'use strict';

var utils = require('../utils');
var logging = utils.log;

// Expose public methods.
module.exports = function(window) {
  var browserDetails = utils.detectBrowser(window);
  var navigator = window && window.navigator;
  var MediaStreamTrack = window && window.MediaStreamTrack;

  var shimError_ = function(e) {
    return {
      name: {
        InternalError: 'NotReadableError',
        NotSupportedError: 'TypeError',
        PermissionDeniedError: 'NotAllowedError',
        SecurityError: 'NotAllowedError'
      }[e.name] || e.name,
      message: {
        'The operation is insecure.': 'The request is not allowed by the ' +
        'user agent or the platform in the current context.'
      }[e.message] || e.message,
      constraint: e.constraint,
      toString: function() {
        return this.name + (this.message && ': ') + this.message;
      }
    };
  };

  // getUserMedia constraints shim.
  var getUserMedia_ = function(constraints, onSuccess, onError) {
    var constraintsToFF37_ = function(c) {
      if (typeof c !== 'object' || c.require) {
        return c;
      }
      var require = [];
      Object.keys(c).forEach(function(key) {
        if (key === 'require' || key === 'advanced' || key === 'mediaSource') {
          return;
        }
        var r = c[key] = (typeof c[key] === 'object') ?
            c[key] : {ideal: c[key]};
        if (r.min !== undefined ||
            r.max !== undefined || r.exact !== undefined) {
          require.push(key);
        }
        if (r.exact !== undefined) {
          if (typeof r.exact === 'number') {
            r. min = r.max = r.exact;
          } else {
            c[key] = r.exact;
          }
          delete r.exact;
        }
        if (r.ideal !== undefined) {
          c.advanced = c.advanced || [];
          var oc = {};
          if (typeof r.ideal === 'number') {
            oc[key] = {min: r.ideal, max: r.ideal};
          } else {
            oc[key] = r.ideal;
          }
          c.advanced.push(oc);
          delete r.ideal;
          if (!Object.keys(r).length) {
            delete c[key];
          }
        }
      });
      if (require.length) {
        c.require = require;
      }
      return c;
    };
    constraints = JSON.parse(JSON.stringify(constraints));
    if (browserDetails.version < 38) {
      logging('spec: ' + JSON.stringify(constraints));
      if (constraints.audio) {
        constraints.audio = constraintsToFF37_(constraints.audio);
      }
      if (constraints.video) {
        constraints.video = constraintsToFF37_(constraints.video);
      }
      logging('ff37: ' + JSON.stringify(constraints));
    }
    return navigator.mozGetUserMedia(constraints, onSuccess, function(e) {
      onError(shimError_(e));
    });
  };

  // Returns the result of getUserMedia as a Promise.
  var getUserMediaPromise_ = function(constraints) {
    return new Promise(function(resolve, reject) {
      getUserMedia_(constraints, resolve, reject);
    });
  };

  // Shim for mediaDevices on older versions.
  if (!navigator.mediaDevices) {
    navigator.mediaDevices = {getUserMedia: getUserMediaPromise_,
      addEventListener: function() { },
      removeEventListener: function() { }
    };
  }
  navigator.mediaDevices.enumerateDevices =
      navigator.mediaDevices.enumerateDevices || function() {
        return new Promise(function(resolve) {
          var infos = [
            {kind: 'audioinput', deviceId: 'default', label: '', groupId: ''},
            {kind: 'videoinput', deviceId: 'default', label: '', groupId: ''}
          ];
          resolve(infos);
        });
      };

  if (browserDetails.version < 41) {
    // Work around http://bugzil.la/1169665
    var orgEnumerateDevices =
        navigator.mediaDevices.enumerateDevices.bind(navigator.mediaDevices);
    navigator.mediaDevices.enumerateDevices = function() {
      return orgEnumerateDevices().then(undefined, function(e) {
        if (e.name === 'NotFoundError') {
          return [];
        }
        throw e;
      });
    };
  }
  if (browserDetails.version < 49) {
    var origGetUserMedia = navigator.mediaDevices.getUserMedia.
        bind(navigator.mediaDevices);
    navigator.mediaDevices.getUserMedia = function(c) {
      return origGetUserMedia(c).then(function(stream) {
        // Work around https://bugzil.la/802326
        if (c.audio && !stream.getAudioTracks().length ||
            c.video && !stream.getVideoTracks().length) {
          stream.getTracks().forEach(function(track) {
            track.stop();
          });
          throw new DOMException('The object can not be found here.',
                                 'NotFoundError');
        }
        return stream;
      }, function(e) {
        return Promise.reject(shimError_(e));
      });
    };
  }
  if (!(browserDetails.version > 55 &&
      'autoGainControl' in navigator.mediaDevices.getSupportedConstraints())) {
    var remap = function(obj, a, b) {
      if (a in obj && !(b in obj)) {
        obj[b] = obj[a];
        delete obj[a];
      }
    };

    var nativeGetUserMedia = navigator.mediaDevices.getUserMedia.
        bind(navigator.mediaDevices);
    navigator.mediaDevices.getUserMedia = function(c) {
      if (typeof c === 'object' && typeof c.audio === 'object') {
        c = JSON.parse(JSON.stringify(c));
        remap(c.audio, 'autoGainControl', 'mozAutoGainControl');
        remap(c.audio, 'noiseSuppression', 'mozNoiseSuppression');
      }
      return nativeGetUserMedia(c);
    };

    if (MediaStreamTrack && MediaStreamTrack.prototype.getSettings) {
      var nativeGetSettings = MediaStreamTrack.prototype.getSettings;
      MediaStreamTrack.prototype.getSettings = function() {
        var obj = nativeGetSettings.apply(this, arguments);
        remap(obj, 'mozAutoGainControl', 'autoGainControl');
        remap(obj, 'mozNoiseSuppression', 'noiseSuppression');
        return obj;
      };
    }

    if (MediaStreamTrack && MediaStreamTrack.prototype.applyConstraints) {
      var nativeApplyConstraints = MediaStreamTrack.prototype.applyConstraints;
      MediaStreamTrack.prototype.applyConstraints = function(c) {
        if (this.kind === 'audio' && typeof c === 'object') {
          c = JSON.parse(JSON.stringify(c));
          remap(c, 'autoGainControl', 'mozAutoGainControl');
          remap(c, 'noiseSuppression', 'mozNoiseSuppression');
        }
        return nativeApplyConstraints.apply(this, [c]);
      };
    }
  }
  navigator.getUserMedia = function(constraints, onSuccess, onError) {
    if (browserDetails.version < 44) {
      return getUserMedia_(constraints, onSuccess, onError);
    }
    // Replace Firefox 44+'s deprecation warning with unprefixed version.
    utils.deprecated('navigator.getUserMedia',
        'navigator.mediaDevices.getUserMedia');
    navigator.mediaDevices.getUserMedia(constraints).then(onSuccess, onError);
  };
};

},{"../utils":14}],13:[function(require,module,exports){
/*
 *  Copyright (c) 2016 The WebRTC project authors. All Rights Reserved.
 *
 *  Use of this source code is governed by a BSD-style license
 *  that can be found in the LICENSE file in the root of the source
 *  tree.
 */
'use strict';
var utils = require('../utils');

module.exports = {
  shimLocalStreamsAPI: function(window) {
    if (typeof window !== 'object' || !window.RTCPeerConnection) {
      return;
    }
    if (!('getLocalStreams' in window.RTCPeerConnection.prototype)) {
      window.RTCPeerConnection.prototype.getLocalStreams = function() {
        if (!this._localStreams) {
          this._localStreams = [];
        }
        return this._localStreams;
      };
    }
    if (!('getStreamById' in window.RTCPeerConnection.prototype)) {
      window.RTCPeerConnection.prototype.getStreamById = function(id) {
        var result = null;
        if (this._localStreams) {
          this._localStreams.forEach(function(stream) {
            if (stream.id === id) {
              result = stream;
            }
          });
        }
        if (this._remoteStreams) {
          this._remoteStreams.forEach(function(stream) {
            if (stream.id === id) {
              result = stream;
            }
          });
        }
        return result;
      };
    }
    if (!('addStream' in window.RTCPeerConnection.prototype)) {
      var _addTrack = window.RTCPeerConnection.prototype.addTrack;
      window.RTCPeerConnection.prototype.addStream = function(stream) {
        if (!this._localStreams) {
          this._localStreams = [];
        }
        if (this._localStreams.indexOf(stream) === -1) {
          this._localStreams.push(stream);
        }
        var pc = this;
        stream.getTracks().forEach(function(track) {
          _addTrack.call(pc, track, stream);
        });
      };

      window.RTCPeerConnection.prototype.addTrack = function(track, stream) {
        if (stream) {
          if (!this._localStreams) {
            this._localStreams = [stream];
          } else if (this._localStreams.indexOf(stream) === -1) {
            this._localStreams.push(stream);
          }
        }
        return _addTrack.call(this, track, stream);
      };
    }
    if (!('removeStream' in window.RTCPeerConnection.prototype)) {
      window.RTCPeerConnection.prototype.removeStream = function(stream) {
        if (!this._localStreams) {
          this._localStreams = [];
        }
        var index = this._localStreams.indexOf(stream);
        if (index === -1) {
          return;
        }
        this._localStreams.splice(index, 1);
        var pc = this;
        var tracks = stream.getTracks();
        this.getSenders().forEach(function(sender) {
          if (tracks.indexOf(sender.track) !== -1) {
            pc.removeTrack(sender);
          }
        });
      };
    }
  },
  shimRemoteStreamsAPI: function(window) {
    if (typeof window !== 'object' || !window.RTCPeerConnection) {
      return;
    }
    if (!('getRemoteStreams' in window.RTCPeerConnection.prototype)) {
      window.RTCPeerConnection.prototype.getRemoteStreams = function() {
        return this._remoteStreams ? this._remoteStreams : [];
      };
    }
    if (!('onaddstream' in window.RTCPeerConnection.prototype)) {
      Object.defineProperty(window.RTCPeerConnection.prototype, 'onaddstream', {
        get: function() {
          return this._onaddstream;
        },
        set: function(f) {
          if (this._onaddstream) {
            this.removeEventListener('addstream', this._onaddstream);
          }
          this.addEventListener('addstream', this._onaddstream = f);
        }
      });
      var origSetRemoteDescription =
          window.RTCPeerConnection.prototype.setRemoteDescription;
      window.RTCPeerConnection.prototype.setRemoteDescription = function() {
        var pc = this;
        if (!this._onaddstreampoly) {
          this.addEventListener('track', this._onaddstreampoly = function(e) {
            e.streams.forEach(function(stream) {
              if (!pc._remoteStreams) {
                pc._remoteStreams = [];
              }
              if (pc._remoteStreams.indexOf(stream) >= 0) {
                return;
              }
              pc._remoteStreams.push(stream);
              var event = new Event('addstream');
              event.stream = stream;
              pc.dispatchEvent(event);
            });
          });
        }
        return origSetRemoteDescription.apply(pc, arguments);
      };
    }
  },
  shimCallbacksAPI: function(window) {
    if (typeof window !== 'object' || !window.RTCPeerConnection) {
      return;
    }
    var prototype = window.RTCPeerConnection.prototype;
    var createOffer = prototype.createOffer;
    var createAnswer = prototype.createAnswer;
    var setLocalDescription = prototype.setLocalDescription;
    var setRemoteDescription = prototype.setRemoteDescription;
    var addIceCandidate = prototype.addIceCandidate;

    prototype.createOffer = function(successCallback, failureCallback) {
      var options = (arguments.length >= 2) ? arguments[2] : arguments[0];
      var promise = createOffer.apply(this, [options]);
      if (!failureCallback) {
        return promise;
      }
      promise.then(successCallback, failureCallback);
      return Promise.resolve();
    };

    prototype.createAnswer = function(successCallback, failureCallback) {
      var options = (arguments.length >= 2) ? arguments[2] : arguments[0];
      var promise = createAnswer.apply(this, [options]);
      if (!failureCallback) {
        return promise;
      }
      promise.then(successCallback, failureCallback);
      return Promise.resolve();
    };

    var withCallback = function(description, successCallback, failureCallback) {
      var promise = setLocalDescription.apply(this, [description]);
      if (!failureCallback) {
        return promise;
      }
      promise.then(successCallback, failureCallback);
      return Promise.resolve();
    };
    prototype.setLocalDescription = withCallback;

    withCallback = function(description, successCallback, failureCallback) {
      var promise = setRemoteDescription.apply(this, [description]);
      if (!failureCallback) {
        return promise;
      }
      promise.then(successCallback, failureCallback);
      return Promise.resolve();
    };
    prototype.setRemoteDescription = withCallback;

    withCallback = function(candidate, successCallback, failureCallback) {
      var promise = addIceCandidate.apply(this, [candidate]);
      if (!failureCallback) {
        return promise;
      }
      promise.then(successCallback, failureCallback);
      return Promise.resolve();
    };
    prototype.addIceCandidate = withCallback;
  },
  shimGetUserMedia: function(window) {
    var navigator = window && window.navigator;

    if (!navigator.getUserMedia) {
      if (navigator.webkitGetUserMedia) {
        navigator.getUserMedia = navigator.webkitGetUserMedia.bind(navigator);
      } else if (navigator.mediaDevices &&
          navigator.mediaDevices.getUserMedia) {
        navigator.getUserMedia = function(constraints, cb, errcb) {
          navigator.mediaDevices.getUserMedia(constraints)
          .then(cb, errcb);
        }.bind(navigator);
      }
    }
  },
  shimRTCIceServerUrls: function(window) {
    // migrate from non-spec RTCIceServer.url to RTCIceServer.urls
    var OrigPeerConnection = window.RTCPeerConnection;
    window.RTCPeerConnection = function(pcConfig, pcConstraints) {
      if (pcConfig && pcConfig.iceServers) {
        var newIceServers = [];
        for (var i = 0; i < pcConfig.iceServers.length; i++) {
          var server = pcConfig.iceServers[i];
          if (!server.hasOwnProperty('urls') &&
              server.hasOwnProperty('url')) {
            utils.deprecated('RTCIceServer.url', 'RTCIceServer.urls');
            server = JSON.parse(JSON.stringify(server));
            server.urls = server.url;
            delete server.url;
            newIceServers.push(server);
          } else {
            newIceServers.push(pcConfig.iceServers[i]);
          }
        }
        pcConfig.iceServers = newIceServers;
      }
      return new OrigPeerConnection(pcConfig, pcConstraints);
    };
    window.RTCPeerConnection.prototype = OrigPeerConnection.prototype;
    // wrap static methods. Currently just generateCertificate.
    if ('generateCertificate' in window.RTCPeerConnection) {
      Object.defineProperty(window.RTCPeerConnection, 'generateCertificate', {
        get: function() {
          return OrigPeerConnection.generateCertificate;
        }
      });
    }
  },
  shimTrackEventTransceiver: function(window) {
    // Add event.transceiver member over deprecated event.receiver
    if (typeof window === 'object' && window.RTCPeerConnection &&
        ('receiver' in window.RTCTrackEvent.prototype) &&
        // can't check 'transceiver' in window.RTCTrackEvent.prototype, as it is
        // defined for some reason even when window.RTCTransceiver is not.
        !window.RTCTransceiver) {
      Object.defineProperty(window.RTCTrackEvent.prototype, 'transceiver', {
        get: function() {
          return {receiver: this.receiver};
        }
      });
    }
  },

  shimCreateOfferLegacy: function(window) {
    var origCreateOffer = window.RTCPeerConnection.prototype.createOffer;
    window.RTCPeerConnection.prototype.createOffer = function(offerOptions) {
      var pc = this;
      if (offerOptions) {
        if (typeof offerOptions.offerToReceiveAudio !== 'undefined') {
          // support bit values
          offerOptions.offerToReceiveAudio = !!offerOptions.offerToReceiveAudio;
        }
        var audioTransceiver = pc.getTransceivers().find(function(transceiver) {
          return transceiver.sender.track &&
              transceiver.sender.track.kind === 'audio';
        });
        if (offerOptions.offerToReceiveAudio === false && audioTransceiver) {
          if (audioTransceiver.direction === 'sendrecv') {
            if (audioTransceiver.setDirection) {
              audioTransceiver.setDirection('sendonly');
            } else {
              audioTransceiver.direction = 'sendonly';
            }
          } else if (audioTransceiver.direction === 'recvonly') {
            if (audioTransceiver.setDirection) {
              audioTransceiver.setDirection('inactive');
            } else {
              audioTransceiver.direction = 'inactive';
            }
          }
        } else if (offerOptions.offerToReceiveAudio === true &&
            !audioTransceiver) {
          pc.addTransceiver('audio');
        }


        if (typeof offerOptions.offerToReceiveVideo !== 'undefined') {
          // support bit values
          offerOptions.offerToReceiveVideo = !!offerOptions.offerToReceiveVideo;
        }
        var videoTransceiver = pc.getTransceivers().find(function(transceiver) {
          return transceiver.sender.track &&
              transceiver.sender.track.kind === 'video';
        });
        if (offerOptions.offerToReceiveVideo === false && videoTransceiver) {
          if (videoTransceiver.direction === 'sendrecv') {
            videoTransceiver.setDirection('sendonly');
          } else if (videoTransceiver.direction === 'recvonly') {
            videoTransceiver.setDirection('inactive');
          }
        } else if (offerOptions.offerToReceiveVideo === true &&
            !videoTransceiver) {
          pc.addTransceiver('video');
        }
      }
      return origCreateOffer.apply(pc, arguments);
    };
  }
};

},{"../utils":14}],14:[function(require,module,exports){
/*
 *  Copyright (c) 2016 The WebRTC project authors. All Rights Reserved.
 *
 *  Use of this source code is governed by a BSD-style license
 *  that can be found in the LICENSE file in the root of the source
 *  tree.
 */
 /* eslint-env node */
'use strict';

var logDisabled_ = true;
var deprecationWarnings_ = true;

/**
 * Extract browser version out of the provided user agent string.
 *
 * @param {!string} uastring userAgent string.
 * @param {!string} expr Regular expression used as match criteria.
 * @param {!number} pos position in the version string to be returned.
 * @return {!number} browser version.
 */
function extractVersion(uastring, expr, pos) {
  var match = uastring.match(expr);
  return match && match.length >= pos && parseInt(match[pos], 10);
}

// Wraps the peerconnection event eventNameToWrap in a function
// which returns the modified event object (or false to prevent
// the event).
function wrapPeerConnectionEvent(window, eventNameToWrap, wrapper) {
  if (!window.RTCPeerConnection) {
    return;
  }
  var proto = window.RTCPeerConnection.prototype;
  var nativeAddEventListener = proto.addEventListener;
  proto.addEventListener = function(nativeEventName, cb) {
    if (nativeEventName !== eventNameToWrap) {
      return nativeAddEventListener.apply(this, arguments);
    }
    var wrappedCallback = function(e) {
      var modifiedEvent = wrapper(e);
      if (modifiedEvent) {
        cb(modifiedEvent);
      }
    };
    this._eventMap = this._eventMap || {};
    this._eventMap[cb] = wrappedCallback;
    return nativeAddEventListener.apply(this, [nativeEventName,
      wrappedCallback]);
  };

  var nativeRemoveEventListener = proto.removeEventListener;
  proto.removeEventListener = function(nativeEventName, cb) {
    if (nativeEventName !== eventNameToWrap || !this._eventMap
        || !this._eventMap[cb]) {
      return nativeRemoveEventListener.apply(this, arguments);
    }
    var unwrappedCb = this._eventMap[cb];
    delete this._eventMap[cb];
    return nativeRemoveEventListener.apply(this, [nativeEventName,
      unwrappedCb]);
  };

  Object.defineProperty(proto, 'on' + eventNameToWrap, {
    get: function() {
      return this['_on' + eventNameToWrap];
    },
    set: function(cb) {
      if (this['_on' + eventNameToWrap]) {
        this.removeEventListener(eventNameToWrap,
            this['_on' + eventNameToWrap]);
        delete this['_on' + eventNameToWrap];
      }
      if (cb) {
        this.addEventListener(eventNameToWrap,
            this['_on' + eventNameToWrap] = cb);
      }
    },
    enumerable: true,
    configurable: true
  });
}

// Utility methods.
module.exports = {
  extractVersion: extractVersion,
  wrapPeerConnectionEvent: wrapPeerConnectionEvent,
  disableLog: function(bool) {
    if (typeof bool !== 'boolean') {
      return new Error('Argument type: ' + typeof bool +
          '. Please use a boolean.');
    }
    logDisabled_ = bool;
    return (bool) ? 'adapter.js logging disabled' :
        'adapter.js logging enabled';
  },

  /**
   * Disable or enable deprecation warnings
   * @param {!boolean} bool set to true to disable warnings.
   */
  disableWarnings: function(bool) {
    if (typeof bool !== 'boolean') {
      return new Error('Argument type: ' + typeof bool +
          '. Please use a boolean.');
    }
    deprecationWarnings_ = !bool;
    return 'adapter.js deprecation warnings ' + (bool ? 'disabled' : 'enabled');
  },

  log: function() {
    if (typeof window === 'object') {
      if (logDisabled_) {
        return;
      }
      if (typeof console !== 'undefined' && typeof console.log === 'function') {
        console.log.apply(console, arguments);
      }
    }
  },

  /**
   * Shows a deprecation warning suggesting the modern and spec-compatible API.
   */
  deprecated: function(oldMethod, newMethod) {
    if (!deprecationWarnings_) {
      return;
    }
    console.warn(oldMethod + ' is deprecated, please use ' + newMethod +
        ' instead.');
  },

  /**
   * Browser detector.
   *
   * @return {object} result containing browser and version
   *     properties.
   */
  detectBrowser: function(window) {
    var navigator = window && window.navigator;

    // Returned result object.
    var result = {};
    result.browser = null;
    result.version = null;

    // Fail early if it's not a browser
    if (typeof window === 'undefined' || !window.navigator) {
      result.browser = 'Not a browser.';
      return result;
    }

    if (navigator.mozGetUserMedia) { // Firefox.
      result.browser = 'firefox';
      result.version = extractVersion(navigator.userAgent,
          /Firefox\/(\d+)\./, 1);
    } else if (navigator.webkitGetUserMedia) {
      // Chrome, Chromium, Webview, Opera.
      // Version matches Chrome/WebRTC version.
      result.browser = 'chrome';
      result.version = extractVersion(navigator.userAgent,
          /Chrom(e|ium)\/(\d+)\./, 2);
    } else if (navigator.mediaDevices &&
        navigator.userAgent.match(/Edge\/(\d+).(\d+)$/)) { // Edge.
      result.browser = 'edge';
      result.version = extractVersion(navigator.userAgent,
          /Edge\/(\d+).(\d+)$/, 2);
    } else if (window.RTCPeerConnection &&
        navigator.userAgent.match(/AppleWebKit\/(\d+)\./)) { // Safari.
      result.browser = 'safari';
      result.version = extractVersion(navigator.userAgent,
          /AppleWebKit\/(\d+)\./, 1);
    } else { // Default fallthrough: not supported.
      result.browser = 'Not a supported browser.';
      return result;
    }

    return result;
  }
};

},{}]},{},[3])(3)
});

/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(0)))

/***/ }),
/* 8 */
/***/ (function(module, exports, __webpack_require__) {

/* WEBPACK VAR INJECTION */(function(global) {var Constants = __webpack_require__(1)
var DetectRTC = __webpack_require__(9)
var Util = __webpack_require__(4)
var Log = __webpack_require__(3)


var Report = function (global, emitter) {
    this.global = global;
    this.emitter = emitter;
}
Report.fn = Report.prototype;
Report.fn.createJsonFromTag = function (tag) {
    var global = this.global;
    return {
        tag_key: tag,
        data: "",
        openid: global.config.openid,
        tinyid: global.config.tinyid,
        version: Constants.Version,
        ua: navigator.userAgent,
        sessionid: global.roomid
    };
};

Report.fn.send = function( tag , data){
    if( this.global.websocket ){
        var sendMsg = this.createJsonFromTag( tag );
        sendMsg.data = data || "";
        this.global.websocket.send( JSON.stringify(sendMsg) );
    }
};

Report.fn.initEndReport = function () {
    var global = this.global;
    var sendData = this.createJsonFromTag(Constants.RTC_EVENT.INIT_END_REPORT);
    sendData.data = {
        socketid: global.websocket.socketid,
        tinyid: global.tinyid,
        clientip: global.clientip,
        devicename: global.devicename,
        ostype: global.ostype,
        sdkAppId: global.config.sdkAppId,
        roomid: global.roomid,
        serverip: global.serverip,
        cpunumber: global.cpunumber,
        cpudevice: global.cpudevice
    };

    global.websocket.send(JSON.stringify(sendData));
};

Report.fn.addCommonInfoInQualityReport = function (data, ostype, devicename, serverip, clientip, tinyid, roomid, cpunumber, cpudevice) {
    var global = this.global;
    data["socketid"] = global.websocket.socketid;
    data["tinyid"] = tinyid;
    data["clientip"] = clientip;
    data["devicename"] = devicename;
    data["ostype"] = ostype;
    data["sdkAppId"] = global.config.sdkAppId;
    data["roomid"] = roomid;
    data["serverip"] = serverip;
    data["cpunumber"] = cpunumber;
    data["cpudevice"] = cpudevice;
    return data;
};
Report.fn.getQulityAsync = function (pcMap, callback) {
    var size = Object.keys(pcMap).length;
    var doneSize = 0;
    var self = this;

    if (size === 0) {
        Log.RTCLog.warn("get quality async failed! peerconnection size is 0!");
        callback(false, null);
        return;
    }

    var statsMap = {};
    for (var key in pcMap) {
        (function (index) {
            var testPC = pcMap[index];
            testPC.getStats(function (stats) {
                var results = stats.result();
                var items = [];

                for (var i = 0; i < results.length; i++) {

                    var res = results[i];

                    var item = {};
                    res.names().forEach(function (name) {
                        item[name] = res.stat(name);
                    });
                    item.id = res.id;
                    item.type = res.type;
                    item.timestamp = res.timestamp;
                    items.push(item);

                }
                statsMap[index] = items;
                doneSize++;
                if (doneSize >= size) {
                    var result = self.handleTotalReportData(statsMap);
                    callback(true, result);
                }
            }, function (error) {
                Log.RTCLog.error("get state failed! index = " + index);
                doneSize++;
                if (doneSize >= size) {
                    var result = self.handleTotalReportData(statsMap);
                    callback(true, result);
                }
            });

        })(key);
    }
};

Report.fn.getQualityReportFromSafariAsync = function (peerconnections, callback) {
    var global = this.global;
    var size = Object.keys(peerconnections).length;
    var doneSize = 0;
    var self = this;

    if (size === 0) {
        Log.RTCLog.warn("get quality async failed! peerconnection size is 0!");
        callback(false, null);
        return;
    }

    var cpuMaxFrequency = 0;
    if (navigator && navigator.cpuMaxFrequency) {
        cpuMaxFrequency = navigator.cpuMaxFrequency;
    }
    var micStatus = 0;
    if (global.localStream) {
        var audioTracks = global.localStream.getAudioTracks();
        if (audioTracks && audioTracks[0] && audioTracks[0].muted) {
            micStatus = 3;
        } else {
            micStatus = 1;
        }
    }
    var decodeVideoItemMap = {};
    var decodeAudioItemMap = {};
    var finalReportData = {
        WebRTCQualityReq: {
            uint64_begine_utime: new Date().getTime(),
            uint64_end_utime: 0,
            uint32_real_num: 0, //音频总下行包
            uint32_delay: 0, // Conn-audio-1-0 googRtt
            uint32_CPU_curfreq: cpuMaxFrequency,
            uint32_total_send_bps: 0, //总上行码率
            uint32_total_recv_bps: 0,
            AudioReportState: {
                uint32_audio_enc_pkg_br: 0, //音频上行码率
                uint32_audio_real_recv_pkg: 0, //音频下行收包
                uint32_audio_flow: 0, //音频下行流量
                uint32_audio_real_recv_br: 0, //音频下行码率
                uint32_audio_delay: 0, //googCurrentDelayMs
                uint32_audio_jitter: 0, //googJitterBufferMs
                uint32_microphone_status: micStatus,
                AudioDecState: []
            },
            VideoReportState: {
                uint32_video_delay: 0, //googTargetDelayMs
                uint32_video_snd_br: 0, //视频上行码率
                uint32_video_total_real_recv_pkg: 0, //视频下行收包
                uint32_video_rcv_br: 0, //视频下行码率
                uint32_send_total_pkg: 0, //视频上行发包
                VideoEncState: [{
                    uint32_enc_width: 0,
                    uint32_enc_height: 0,
                    uint32_capture_fps: 0,
                    uint32_enc_fps: 0
                }],
                VideoDecState: []
            }
        }
    };
    for (var key in peerconnections) {
        (function (index) {
            var currentPC = peerconnections[index];
            currentPC.getStats().then(function (result) {
                //console.log("[wadesheng] BEGIN , INDEX = " + index);
                var videoDec = {
                    uint32_video_recv_fps: 0,
                    uint32_video_recv_br: 0, //单路视频下行码率
                    uint32_video_real_recv_pkg: 0, //单路下行收包
                    uint32_dec_height: 0,
                    uint32_dec_width: 0,
                    uint32_video_jitter: 0,
                    uint64_sender_uin: "" //tinyid
                };

                var audioItem = {
                    uint32_audio_delay: 0,
                    uint32_audio_jitter: 0,
                    uint32_audio_real_recv_pkg: 0,
                    uint32_audio_flow: 0,
                    uint32_audio_real_recv_br: 0,
                    uint64_sender_uin: ""
                };

                result.forEach(function (value) {
                    var type = value.type;
                    // console.info("[wadesheng] node type " + type, value);
                    if (type === "inbound-rtp" && index != 0) {
                        var id = value["id"];
                        var mediaType = null;
                        if (!!id) {
                            if (id.toLowerCase().indexOf("video") !== -1) {
                                mediaType = "video";
                            } else if (id.toLowerCase().indexOf("audio") !== -1) {
                                mediaType = "audio";
                            }
                        }

                        if (mediaType === "video" || mediaType === "audio") {
                            var bytesReceived = value["bytesReceived"] || "0";
                            var packetsReceived = value["packetsReceived"] || "0";
                            if (mediaType === "video") {
                                finalReportData.WebRTCQualityReq.VideoReportState.uint32_video_rcv_br += parseInt(bytesReceived);
                                finalReportData.WebRTCQualityReq.VideoReportState.uint32_video_total_real_recv_pkg = parseInt(packetsReceived);

                                videoDec.uint64_sender_uin = key;
                                videoDec.uint32_video_real_recv_pkg = parseInt(packetsReceived);
                                videoDec.uint32_video_recv_br = parseInt(bytesReceived);
                                videoDec.uint32_video_jitter = value["jitter"] * 1000;
                            } else {
                                finalReportData.WebRTCQualityReq.AudioReportState.uint32_audio_real_recv_br += parseInt(bytesReceived);
                                finalReportData.WebRTCQualityReq.AudioReportState.uint32_audio_real_recv_pkg += parseInt(packetsReceived);
                                finalReportData.WebRTCQualityReq.AudioReportState.uint32_audio_flow += parseInt(bytesReceived);

                                audioItem.uint64_sender_uin = index;
                                audioItem.uint32_audio_real_recv_pkg = parseInt(packetsReceived);
                                audioItem.uint32_audio_flow = parseInt(bytesReceived);
                                audioItem.uint32_audio_jitter = value["jitter"] * 1000;
                            }
                        }
                    } else if (type === "outbound-rtp" && index == "0") {
                        var mediaType = value["mediaType"];
                        if (mediaType === "video" || mediaType === "audio") {
                            var bytesSend = value["bytesSent"] || "0";
                            var packetsSend = value["packetsSent"] || "0";

                            if (mediaType === "video") {
                                finalReportData.WebRTCQualityReq.VideoReportState.uint32_video_snd_br += parseInt(bytesSend);
                                finalReportData.WebRTCQualityReq.VideoReportState.uint32_send_total_pkg = parseInt(packetsSend);
                            } else {
                                finalReportData.WebRTCQualityReq.AudioReportState.uint32_audio_enc_pkg_br += parseInt(bytesSend);
                            }
                        }
                    } else if (type === "track") {
                        var id = value["id"];
                        if (index == "0") {

                        } else {
                            if (!!id && id.toLowerCase().indexOf("video") !== -1) {
                                videoDec.uint32_video_recv_fps = parseInt(value["framesPerSecond"] || "0");
                                videoDec.uint32_dec_width = parseInt(value["frameWidth"]);
                                videoDec.uint32_dec_height = parseInt(value["frameHeight"]);
                            }
                        }
                    } else if (type === "candidate-pair") {
                        var rrt = value["currentRoundTripTime"] * 1000;
                        if (index == "0") {
                            finalReportData.WebRTCQualityReq.uint32_delay = rrt;
                        } else {

                        }
                    }
                });

                if (index != "0") {
                    finalReportData.WebRTCQualityReq.AudioReportState.AudioDecState.push(audioItem);
                    finalReportData.WebRTCQualityReq.VideoReportState.VideoDecState.push(videoDec);
                }

                doneSize++;
                if (doneSize >= size) {
                    finalReportData = self.parseFinalReport(finalReportData, true);
                    callback(true, finalReportData);
                }
            }).catch(function (error) {
                doneSize++;
                if (doneSize >= size) {
                    finalReportData = self.parseFinalReport(finalReportData, true);
                    callback(true, finalReportData);
                }
            });
        })(key);
    }
};


Report.fn.getQualityReportFromFFAsync = function (peerconnections, callback) {
    var global = this.global;
    var size = Object.keys(peerconnections).length;
    var doneSize = 0;
    var self = this;

    if (size === 0) {
        Log.RTCLog.warn("get quality async failed! peerconnection size is 0!");
        callback(false, null);
        return;
    }

    var cpuMaxFrequency = 0;
    if (navigator && navigator.cpuMaxFrequency) {
        cpuMaxFrequency = navigator.cpuMaxFrequency;
    }
    var micStatus = 0;
    if (global.localStream) {
        var audioTracks = global.localStream.getAudioTracks();
        if (audioTracks && audioTracks[0] && audioTracks[0].muted) {
            micStatus = 3;
        } else {
            micStatus = 1;
        }
    }
    var decodeVideoItemMap = {};
    var decodeAudioItemMap = {};
    var finalReportData = {
        WebRTCQualityReq: {
            uint64_begine_utime: new Date().getTime(),
            uint64_end_utime: 0,
            uint32_real_num: 0, //音频总下行包
            uint32_delay: 0, // Conn-audio-1-0 googRtt
            uint32_CPU_curfreq: cpuMaxFrequency,
            uint32_total_send_bps: 0, //总上行码率
            uint32_total_recv_bps: 0,
            AudioReportState: {
                uint32_audio_enc_pkg_br: 0, //音频上行码率
                uint32_audio_real_recv_pkg: 0, //音频下行收包
                uint32_audio_flow: 0, //音频下行流量
                uint32_audio_real_recv_br: 0, //音频下行码率
                uint32_audio_delay: 0, //googCurrentDelayMs
                uint32_audio_jitter: 0, //googJitterBufferMs
                uint32_microphone_status: micStatus,
                AudioDecState: []
            },
            VideoReportState: {
                uint32_video_delay: 0, //googTargetDelayMs
                uint32_video_snd_br: 0, //视频上行码率
                uint32_video_total_real_recv_pkg: 0, //视频下行收包
                uint32_video_rcv_br: 0, //视频下行码率
                uint32_send_total_pkg: 0, //视频上行发包
                VideoEncState: [{
                    uint32_enc_width: 0,
                    uint32_enc_height: 0,
                    uint32_capture_fps: 0,
                    uint32_enc_fps: 0
                }],
                VideoDecState: []
            }
        }
    };
    for (var key in peerconnections) {
        (function (index) {
            var currentPC = peerconnections[index];
            currentPC.getStats().then(function (result) {
                //console.log("[wadesheng] BEGIN , INDEX = " + index);
                var videoDec = {
                    uint32_video_recv_fps: 0,
                    uint32_video_recv_br: 0, //单路视频下行码率
                    uint32_video_real_recv_pkg: 0, //单路下行收包
                    uint32_dec_height: 0,
                    uint32_dec_width: 0,
                    uint32_video_jitter: 0,
                    uint64_sender_uin: "" //tinyid
                };

                var audioItem = {
                    uint32_audio_delay: 0,
                    uint32_audio_jitter: 0,
                    uint32_audio_real_recv_pkg: 0,
                    uint32_audio_flow: 0,
                    uint32_audio_real_recv_br: 0,
                    uint64_sender_uin: ""
                };

                result.forEach(function (value) {
                    var type = value.type;
                    // console.info("[wadesheng] node type " + type, value);
                    if (type === "inbound-rtp" && index != 0) {
                        var id = value["id"];
                        var mediaType = null;
                        if (!!id) {
                            if (id.toLowerCase().indexOf("video") !== -1) {
                                mediaType = "video";
                            } else if (id.toLowerCase().indexOf("audio") !== -1) {
                                mediaType = "audio";
                            }
                        }

                        if (mediaType === "video" || mediaType === "audio") {
                            var bytesReceived = value["bytesReceived"] || "0";
                            var packetsReceived = value["packetsReceived"] || "0";
                            if (mediaType === "video") {
                                finalReportData.WebRTCQualityReq.VideoReportState.uint32_video_rcv_br += parseInt(bytesReceived);
                                finalReportData.WebRTCQualityReq.VideoReportState.uint32_video_total_real_recv_pkg = parseInt(packetsReceived);

                                videoDec.uint64_sender_uin = key;
                                videoDec.uint32_video_real_recv_pkg = parseInt(packetsReceived);
                                videoDec.uint32_video_recv_br = parseInt(bytesReceived);
                                videoDec.uint32_video_jitter = value["jitter"] * 1000;
                            } else {
                                finalReportData.WebRTCQualityReq.AudioReportState.uint32_audio_real_recv_br += parseInt(bytesReceived);
                                finalReportData.WebRTCQualityReq.AudioReportState.uint32_audio_real_recv_pkg += parseInt(packetsReceived);
                                finalReportData.WebRTCQualityReq.AudioReportState.uint32_audio_flow += parseInt(bytesReceived);

                                audioItem.uint64_sender_uin = index;
                                audioItem.uint32_audio_real_recv_pkg = parseInt(packetsReceived);
                                audioItem.uint32_audio_flow = parseInt(bytesReceived);
                                audioItem.uint32_audio_jitter = value["jitter"] * 1000;
                            }
                        }
                    } else if (type === "outbound-rtp" && index == "0") {
                        var mediaType = value["mediaType"];
                        if (mediaType === "video" || mediaType === "audio") {
                            var bytesSend = value["bytesSent"] || "0";
                            var packetsSend = value["packetsSent"] || "0";

                            if (mediaType === "video") {
                                finalReportData.WebRTCQualityReq.VideoReportState.uint32_video_snd_br += parseInt(bytesSend);
                                finalReportData.WebRTCQualityReq.VideoReportState.uint32_send_total_pkg = parseInt(packetsSend);
                            } else {
                                finalReportData.WebRTCQualityReq.AudioReportState.uint32_audio_enc_pkg_br += parseInt(bytesSend);
                            }
                        }
                    } else if (type === "track") {
                        var id = value["id"];
                        if (index == "0") {

                        } else {
                            if (!!id && id.toLowerCase().indexOf("video") !== -1) {
                                videoDec.uint32_video_recv_fps = parseInt(value["framesPerSecond"] || "0");
                                videoDec.uint32_dec_width = parseInt(value["frameWidth"]);
                                videoDec.uint32_dec_height = parseInt(value["frameHeight"]);
                            }
                        }
                    } else if (type === "candidate-pair") {
                        var rrt = value["currentRoundTripTime"] * 1000;
                        if (index == "0") {
                            finalReportData.WebRTCQualityReq.uint32_delay = rrt;
                        } else {

                        }
                    }
                });

                if (index != "0") {
                    finalReportData.WebRTCQualityReq.AudioReportState.AudioDecState.push(audioItem);
                    finalReportData.WebRTCQualityReq.VideoReportState.VideoDecState.push(videoDec);
                }

                doneSize++;
                if (doneSize >= size) {
                    finalReportData = self.parseFinalReport(finalReportData, true);
                    callback(true, finalReportData);
                }
            }).catch(function (error) {
                doneSize++;
                if (doneSize >= size) {
                    finalReportData = self.parseFinalReport(finalReportData, true);
                    callback(true, finalReportData);
                }
            });
        })(key);
    }
};


Report.fn.quality = function () {
    var global = this.global;
    var self = this;
    //Log.uploadWebLog(global, "start report quality data", null, Constants.KEY_TAG.RTC_LOG_TAG);

    if (!global.websocket) {
        Log.RTCLog.error("report quality data end, websocket is null!");
        Log.uploadWebLog(global, "report quality data end, websocket is null!", null, Constants.KEY_TAG.RTC_LOG_TAG);
        return;
    }

    if ((new Date()).valueOf() - global.reportTime > 5000) {
        var errMsg = "report quality time out, pre report time " + global.reportTime + " this report time " + (new Date()).valueOf();
        // Log.RTCLog.error(errMsg);
        Log.uploadWebLog(global, errMsg, null, Constants.KEY_TAG.REPORT_TIME_OUT_TAG);
    }
    
    if (DetectRTC.isSafari()) {
        this.getQualityReportFromSafariAsync(global.peerConnections, function (result, data) {
            var sendData = self.createJsonFromTag(Constants.RTC_EVENT.ON_QUALITY_REPORT);

            if (!result) {
                Log.RTCLog.error("[GetQualityReportFronSafariAsync] failed! ");
                sendData.data = self.handleTotalReportData({});
            } else {
                sendData.data = data;

                /*加入能力上报*/
                self.emitter.emit('onQualityReport', data)
            }

            sendData.data = self.addCommonInfoInQualityReport(sendData.data, global.ostype, global.ostype, global.relayip, global.localip, global.config.tinyid, global.roomid, global.cpunum, global.cpuname);
            try {
                if (global.websocket) {
                    global.websocket.send(JSON.stringify(sendData));
                    // Log.uploadWebLog(global, "report quality data send!", null, Constants.KEY_TAG.RTC_LOG_TAG);
                    global.reportTime = (new Date()).valueOf();
                }
            } catch (e) {
                Log.RTCLog.error("websocket send data error : " + e.message);
                Log.uploadWebLog(global, "websocket send data error : " + e.message, null, Constants.KEY_TAG.RTC_LOG_TAG);
            }

        });
    }else if( DetectRTC.isFF()){
        this.getQualityReportFromFFAsync(global.peerConnections, function (result, data) {
            var sendData = self.createJsonFromTag(Constants.RTC_EVENT.ON_QUALITY_REPORT);

            if (!result) {
                Log.RTCLog.error("[GetQualityReportFronSafariAsync] failed! ");
                sendData.data = self.handleTotalReportData({});
            } else {
                sendData.data = data;

                /*加入能力上报*/
                self.emitter.emit('onQualityReport', data)
            }

            sendData.data = self.addCommonInfoInQualityReport(sendData.data, global.ostype, global.ostype, global.relayip, global.localip, global.config.tinyid, global.roomid, global.cpunum, global.cpuname);
            try {
                if (global.websocket) {
                    global.websocket.send(JSON.stringify(sendData));
                    // Log.uploadWebLog(global, "report quality data send!", null, Constants.KEY_TAG.RTC_LOG_TAG);
                    global.reportTime = (new Date()).valueOf();
                }
            } catch (e) {
                Log.RTCLog.error("websocket send data error : " + e.message);
                Log.uploadWebLog(global, "websocket send data error : " + e.message, null, Constants.KEY_TAG.RTC_LOG_TAG);
            }
        });
    }else{
        this.getQulityAsync(global.peerConnections, function (result, data) {
            var sendData = self.createJsonFromTag(Constants.RTC_EVENT.ON_QUALITY_REPORT);
            if (!result) {
                sendData.data = self.handleTotalReportData({});
            } else {
                sendData.data = data;
                /*加入能力上报*/
                self.emitter.emit('onQualityReport', data)
            }
            sendData.data = self.addCommonInfoInQualityReport(sendData.data, global.ostype, global.ostype, global.relayip, global.localip, global.config.tinyid, global.roomid, global.cpunum, global.cpuname);
            try {
                if (global.websocket) {
                    global.websocket.send(JSON.stringify(sendData));
                    // Log.uploadWebLog(global, "report quality data send!", null, Constants.KEY_TAG.RTC_LOG_TAG);
                    global.reportTime = (new Date()).valueOf();
                }
            } catch (e) {
                Log.RTCLog.error("websocket send data error : " + e.message);
                Log.uploadWebLog(global, "[QUALITY REPORT]websocket send data error : " + e.message, null, Constants.KEY_TAG.RTC_LOG_TAG);
            }
        });
    }
};
Report.fn.parseFinalReport = function (finalReportData, isSafari) {
    isSafari = isSafari || false;
    finalReportData.WebRTCQualityReq.uint64_end_utime = new Date().getTime();
    if (!global.preReportData) {
        global.preReportData = Util.cloneObj(finalReportData);

        finalReportData.WebRTCQualityReq.AudioReportState.uint32_audio_enc_pkg_br = finalReportData.WebRTCQualityReq.AudioReportState.uint32_audio_enc_pkg_br * 8 / 2;
        finalReportData.WebRTCQualityReq.VideoReportState.uint32_video_rcv_br = finalReportData.WebRTCQualityReq.VideoReportState.uint32_video_rcv_br * 8 / 2;

        if (isSafari) {
            finalReportData.WebRTCQualityReq.VideoReportState.uint32_video_snd_br = finalReportData.WebRTCQualityReq.VideoReportState.uint32_video_snd_br * 8 / 2;
        }

        var videoDecLen = finalReportData.WebRTCQualityReq.VideoReportState.VideoDecState.length;
        for (var i = 0; i < videoDecLen; i++) {
            finalReportData.WebRTCQualityReq.VideoReportState.VideoDecState[i].uint32_video_recv_br = finalReportData.WebRTCQualityReq.VideoReportState.VideoDecState[i].uint32_video_recv_br * 8 / 2;
        }

        finalReportData.WebRTCQualityReq.uint32_total_send_bps = finalReportData.WebRTCQualityReq.AudioReportState.uint32_audio_enc_pkg_br + finalReportData.WebRTCQualityReq.VideoReportState.uint32_video_snd_br;
        return finalReportData;
    } else {
        var tmp = Util.cloneObj(finalReportData);
        finalReportData.WebRTCQualityReq.uint64_begine_utime = global.preReportData.WebRTCQualityReq.uint64_end_utime;

        finalReportData.WebRTCQualityReq.uint32_real_num -= global.preReportData.WebRTCQualityReq.uint32_real_num;
        if (finalReportData.WebRTCQualityReq.uint32_real_num <= 0) {
            finalReportData.WebRTCQualityReq.uint32_real_num = 0;
        }

        finalReportData.WebRTCQualityReq.AudioReportState.uint32_audio_real_recv_pkg -= global.preReportData.WebRTCQualityReq.AudioReportState.uint32_audio_real_recv_pkg;
        if (finalReportData.WebRTCQualityReq.AudioReportState.uint32_audio_real_recv_pkg <= 0) {
            finalReportData.WebRTCQualityReq.AudioReportState.uint32_audio_real_recv_pkg = 0;
        }

        finalReportData.WebRTCQualityReq.AudioReportState.uint32_audio_enc_pkg_br -= global.preReportData.WebRTCQualityReq.AudioReportState.uint32_audio_enc_pkg_br;
        if (finalReportData.WebRTCQualityReq.AudioReportState.uint32_audio_enc_pkg_br <= 0) {
            finalReportData.WebRTCQualityReq.AudioReportState.uint32_audio_enc_pkg_br = 0;
        }
        finalReportData.WebRTCQualityReq.AudioReportState.uint32_audio_enc_pkg_br = finalReportData.WebRTCQualityReq.AudioReportState.uint32_audio_enc_pkg_br * 8 / 2;

        if (isSafari) {
            finalReportData.WebRTCQualityReq.VideoReportState.uint32_video_snd_br -= global.preReportData.WebRTCQualityReq.VideoReportState.uint32_video_snd_br;
            if (finalReportData.WebRTCQualityReq.VideoReportState.uint32_video_snd_br <= 0) {
                finalReportData.WebRTCQualityReq.VideoReportState.uint32_video_snd_br = 0;
            }
            finalReportData.WebRTCQualityReq.VideoReportState.uint32_video_snd_br = finalReportData.WebRTCQualityReq.VideoReportState.uint32_video_snd_br * 8 / 2;
        }

        finalReportData.WebRTCQualityReq.AudioReportState.uint32_audio_flow -= global.preReportData.WebRTCQualityReq.AudioReportState.uint32_audio_flow;
        if (finalReportData.WebRTCQualityReq.AudioReportState.uint32_audio_flow <= 0) {
            finalReportData.WebRTCQualityReq.AudioReportState.uint32_audio_flow = 0;
        }

        finalReportData.WebRTCQualityReq.VideoReportState.uint32_send_total_pkg -= global.preReportData.WebRTCQualityReq.VideoReportState.uint32_send_total_pkg;
        if (finalReportData.WebRTCQualityReq.VideoReportState.uint32_send_total_pkg <= 0) {
            finalReportData.WebRTCQualityReq.VideoReportState.uint32_send_total_pkg = 0;
        }

        finalReportData.WebRTCQualityReq.VideoReportState.uint32_video_rcv_br -= global.preReportData.WebRTCQualityReq.VideoReportState.uint32_video_rcv_br;
        if (finalReportData.WebRTCQualityReq.VideoReportState.uint32_video_rcv_br <= 0) {
            finalReportData.WebRTCQualityReq.VideoReportState.uint32_video_rcv_br = 0;
        }
        finalReportData.WebRTCQualityReq.VideoReportState.uint32_video_rcv_br = finalReportData.WebRTCQualityReq.VideoReportState.uint32_video_rcv_br * 8 / 2;

        finalReportData.WebRTCQualityReq.VideoReportState.uint32_video_total_real_recv_pkg -= global.preReportData.WebRTCQualityReq.VideoReportState.uint32_video_total_real_recv_pkg;
        if (finalReportData.WebRTCQualityReq.VideoReportState.uint32_video_total_real_recv_pkg <= 0) {
            finalReportData.WebRTCQualityReq.VideoReportState.uint32_video_total_real_recv_pkg = 0;
        }

        //统计各路
        var len = finalReportData.WebRTCQualityReq.VideoReportState.VideoDecState.length;
        for (var i = 0; i < len; i++) {
            var decVideoItem = finalReportData.WebRTCQualityReq.VideoReportState.VideoDecState[i];
            var tinyid = decVideoItem.uint64_sender_uin;
            var recvPackage = decVideoItem.uint32_video_real_recv_pkg;
            var recvBr = decVideoItem.uint32_video_recv_br;

            for (var k = 0; k < global.preReportData.WebRTCQualityReq.VideoReportState.VideoDecState.length; k++) {
                var tempItem = global.preReportData.WebRTCQualityReq.VideoReportState.VideoDecState[k];

                if (tempItem.uint64_sender_uin === tinyid) {
                    //console.error("1 = " + recvPackage + " 2 = " + recvBr + " 3 = " + tempItem.uint32_video_real_recv_pkg + " 4 = " + tempItem.uint32_video_recv_br);
                    recvPackage -= tempItem.uint32_video_real_recv_pkg;
                    if (recvPackage <= 0) {
                        recvPackage = 0;
                    }

                    recvBr -= tempItem.uint32_video_recv_br;
                    if (recvBr <= 0) {
                        recvBr = 0;
                    }
                    break;
                }
            }
            finalReportData.WebRTCQualityReq.VideoReportState.VideoDecState[i].uint32_video_real_recv_pkg = recvPackage;
            finalReportData.WebRTCQualityReq.VideoReportState.VideoDecState[i].uint32_video_recv_br = recvBr * 8 / 2;
        }

        len = finalReportData.WebRTCQualityReq.AudioReportState.AudioDecState.length;
        for (var i = 0; i < len; i++) {
            var decAudioItem = finalReportData.WebRTCQualityReq.AudioReportState.AudioDecState[i];
            var audioRecvPack = decAudioItem.uint32_audio_real_recv_pkg;
            var audioRecvFlow = decAudioItem.uint32_audio_flow;
            var tinyid = decAudioItem.uint64_sender_uin;
            for (var h = 0; h < global.preReportData.WebRTCQualityReq.AudioReportState.AudioDecState.length; h++) {
                var tempAudioItem = global.preReportData.WebRTCQualityReq.AudioReportState.AudioDecState[h];
                if (tempAudioItem.uint64_sender_uin === tinyid) {
                    audioRecvPack -= tempAudioItem.uint32_audio_real_recv_pkg;
                    if (audioRecvPack <= 0) {
                        audioRecvPack = 0;
                    }

                    audioRecvFlow -= tempAudioItem.uint32_audio_flow;
                    if (audioRecvFlow <= 0) {
                        audioRecvFlow = 0;
                    }
                    break;
                }
            }
            finalReportData.WebRTCQualityReq.AudioReportState.AudioDecState[i].uint32_audio_real_recv_pkg = audioRecvPack;
            finalReportData.WebRTCQualityReq.AudioReportState.AudioDecState[i].uint32_audio_flow = audioRecvFlow;
            finalReportData.WebRTCQualityReq.AudioReportState.AudioDecState[i].uint32_audio_real_recv_br = audioRecvFlow * 8 / 2;
        }

        finalReportData.WebRTCQualityReq.AudioReportState.uint32_audio_real_recv_br = finalReportData.WebRTCQualityReq.AudioReportState.uint32_audio_flow * 8 / 2;
        finalReportData.WebRTCQualityReq.uint32_real_num = finalReportData.WebRTCQualityReq.AudioReportState.uint32_audio_real_recv_pkg + finalReportData.WebRTCQualityReq.VideoReportState.uint32_video_total_real_recv_pkg;
        finalReportData.WebRTCQualityReq.uint32_total_send_bps = finalReportData.WebRTCQualityReq.AudioReportState.uint32_audio_enc_pkg_br + finalReportData.WebRTCQualityReq.VideoReportState.uint32_video_snd_br;
        finalReportData.WebRTCQualityReq.uint32_total_recv_bps = finalReportData.WebRTCQualityReq.AudioReportState.uint32_audio_real_recv_br + finalReportData.WebRTCQualityReq.VideoReportState.uint32_video_rcv_br;
        global.preReportData = tmp;
        return finalReportData;
    }
};
Report.fn.handleTotalReportData = function (statsMap) {
    var global = this.global;
    var cpuMaxFrequency = 0;
    if (navigator && navigator.cpuMaxFrequency) {
        cpuMaxFrequency = navigator.cpuMaxFrequency;
    }
    var micStatus = 0;
    if (global.localStream) {
        var audioTracks = global.localStream.getAudioTracks();
        if (audioTracks && audioTracks[0] && audioTracks[0].muted) {
            micStatus = 3;
        } else {
            micStatus = 1;
        }
    }
    var finalReportData = {
        WebRTCQualityReq: {
            uint64_begine_utime: new Date().getTime(),
            uint64_end_utime: 0,
            uint32_real_num: 0, //音频总下行包
            uint32_delay: 0, // Conn-audio-1-0 googRtt
            uint32_CPU_curfreq: cpuMaxFrequency,
            uint32_total_send_bps: 0, //总上行码率
            uint32_total_recv_bps: 0,
            AudioReportState: {
                uint32_audio_enc_pkg_br: 0, //音频上行码率
                uint32_audio_real_recv_pkg: 0, //音频下行收包
                uint32_audio_flow: 0, //音频下行流量
                uint32_audio_real_recv_br: 0, //音频下行码率
                uint32_audio_delay: 0, //googCurrentDelayMs
                uint32_audio_jitter: 0, //googJitterBufferMs
                uint32_microphone_status: micStatus,
                AudioDecState: []
            },
            VideoReportState: {
                uint32_video_delay: 0, //googTargetDelayMs
                uint32_video_snd_br: 0, //视频上行码率
                uint32_video_total_real_recv_pkg: 0, //视频下行收包
                uint32_video_rcv_br: 0, //视频下行码率
                uint32_send_total_pkg: 0, //视频上行发包
                VideoEncState: [{
                    uint32_enc_width: 0,
                    uint32_enc_height: 0,
                    uint32_capture_fps: 0,
                    uint32_enc_fps: 0
                }],
                VideoDecState: []
            }
        }
    };
    for (var mapKey in statsMap) {
        var itemList = statsMap[mapKey];
        if (mapKey === 0 || mapKey === "0") {
            //统计上行
            itemList.forEach(function (value) {
                var id = value["id"];
                var mediaType = value["mediaType"];
                if (id.indexOf("ssrc") !== -1 && id.indexOf("send") !== -1) {
                    if (mediaType === "video") {
                        //视频上行
                        finalReportData.WebRTCQualityReq.VideoReportState.uint32_send_total_pkg = parseInt(value["packetsSent"] || 0);
                        finalReportData.WebRTCQualityReq.VideoReportState.VideoEncState[0].uint32_capture_fps = parseInt(value["googFrameRateInput"] || 0);
                        finalReportData.WebRTCQualityReq.VideoReportState.VideoEncState[0].uint32_enc_fps = parseInt(value["googFrameRateSent"] || 0);
                        finalReportData.WebRTCQualityReq.VideoReportState.VideoEncState[0].uint32_enc_width = parseInt(value["googFrameWidthSent"] || 0);
                        finalReportData.WebRTCQualityReq.VideoReportState.VideoEncState[0].uint32_enc_height = parseInt(value["googFrameHeightSent"] || 0);
                    } else {
                        //音频上行
                        finalReportData.WebRTCQualityReq.AudioReportState.uint32_audio_enc_pkg_br = parseInt(value["bytesSent"] || 0);
                    }
                }

                if (id.indexOf("bweforvideo") !== -1) {
                    var transmitBitrate = value["googTransmitBitrate"];
                    finalReportData.WebRTCQualityReq.VideoReportState.uint32_video_snd_br = parseInt(transmitBitrate || 0);
                }

                if (id.indexOf("Conn-audio-1-0") !== -1) {
                    finalReportData.WebRTCQualityReq.uint32_delay = parseInt(value["googRtt"] || 0);
                }
            });
        } else {
            //统计下行
            itemList.forEach(function (value) {
                var id = value["id"];
                var mediaType = value["mediaType"];
                if (id.indexOf("ssrc") !== -1 && id.indexOf("recv") !== -1) {
                    if (mediaType === "video") {
                        finalReportData.WebRTCQualityReq.VideoReportState.uint32_video_delay = parseInt(value["googTargetDelayMs"] || 0);
                        finalReportData.WebRTCQualityReq.VideoReportState.uint32_video_total_real_recv_pkg += parseInt(value["packetsReceived"] || 0);
                        finalReportData.WebRTCQualityReq.VideoReportState.uint32_video_rcv_br += parseInt(value["bytesReceived"] || 0);
                        var videoDec = {
                            uint32_video_recv_fps: 0,
                            uint32_video_recv_br: 0, //单路视频下行码率
                            uint32_video_real_recv_pkg: 0, //单路下行收包
                            uint32_dec_height: 0,
                            uint32_dec_width: 0,
                            uint32_video_jitter: 0,
                            uint64_sender_uin: "" //tinyid
                        };
                        videoDec.uint32_dec_height = parseInt(value["googFrameHeightReceived"] || 0);
                        videoDec.uint32_dec_width = parseInt(value["googFrameWidthReceived"] || 0);
                        videoDec.uint32_video_real_recv_pkg = parseInt(value["packetsReceived"] || 0);
                        videoDec.uint32_video_recv_fps = parseInt(value["googFrameRateReceived"] || 0);
                        videoDec.uint32_video_recv_br = parseInt(value["bytesReceived"] || 0);
                        videoDec.uint32_video_jitter = parseInt(value["googJitterBufferMs"] || 0);


                        videoDec.uint64_sender_uin = mapKey;

                        finalReportData.WebRTCQualityReq.VideoReportState.VideoDecState.push(videoDec);

                    } else {
                        finalReportData.WebRTCQualityReq.AudioReportState.uint32_audio_delay = parseInt(value["googCurrentDelayMs"] || 0);
                        finalReportData.WebRTCQualityReq.AudioReportState.uint32_audio_jitter = parseInt(value["googJitterBufferMs"] || 0);
                        finalReportData.WebRTCQualityReq.AudioReportState.uint32_audio_real_recv_pkg += parseInt(value["packetsReceived"] || 0);
                        finalReportData.WebRTCQualityReq.AudioReportState.uint32_audio_flow += parseInt(value["bytesReceived"] || 0);
                        finalReportData.WebRTCQualityReq.uint32_real_num += parseInt(value["packetsReceived"] || 0);

                        var audioItem = {
                            uint32_audio_delay: 0,
                            uint32_audio_jitter: 0,
                            uint32_audio_real_recv_pkg: 0,
                            uint32_audio_flow: 0,
                            uint32_audio_real_recv_br: 0,
                            uint64_sender_uin: ""
                        };

                        audioItem.uint32_audio_flow = parseInt(value["bytesReceived"] || 0);
                        audioItem.uint32_audio_delay = parseInt(value["googCurrentDelayMs"] || 0);
                        audioItem.uint32_audio_real_recv_pkg = parseInt(value["packetsReceived"] || 0);
                        audioItem.uint32_audio_jitter = parseInt(value["googJitterBufferMs"] || 0);
                        audioItem.uint64_sender_uin = mapKey;

                        finalReportData.WebRTCQualityReq.AudioReportState.AudioDecState.push(audioItem);

                    }
                }
            });
        }
    }

    //统计结束
    return this.parseFinalReport(finalReportData);
};


Report.fn.endEndReport = function (endResult) {
    var global = this.global
    try {
        if (!global.websocket || !global.websocket.socketid) {
            Log.RTCLog.warn("do not send endreason to server, the socketid is null!");
            return;
        }

        var sendData = this.createJsonFromTag(Constants.RTC_EVENT.ON_END_REPORT);
        sendData.data = {
            dwExitRoomTime: (new Date()).getTime(),
            dwEndResult: endResult,
            socketid: global.websocket.socketid
        };

        if (global.websocket) {
            global.websocket.send(JSON.stringify(sendData));
        }
    } catch (e) {
        Log.RTCLog.error("send end report data error : " + e.message);
    }
};

module.exports = Report;
/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(0)))

/***/ }),
/* 9 */
/***/ (function(module, exports) {

var DectectRTC = {
    TBS_MIN_VERSION: 43600,
    h264Support:false,
    checkTBSVersion: function() {
        var list = navigator.userAgent.split(" ");
        var isTBS = false;
        var TBSVersion = 0;
        for (var i = 0; i < list.length; i++) {
            var item = list[i];
            if (item.indexOf("TBS") !== -1 || item.indexOf("tbs") !== -1) {
                isTBS = true;
                var versionStr = item.split("/")[1];
                var version = parseInt(versionStr) || 0;
                    TBSVersion = version
            }
        }
        return {
            isTBS : isTBS,
            TBSversion : TBSVersion,
            isTBSValid: TBSVersion >= this.TBS_MIN_VERSION
        };
    },
    checkH264Support : function( callback ){
        var peer = new RTCPeerConnection(null);
        peer.createOffer({
        offerToReceiveAudio: 1,
        offerToReceiveVideo: 1
        }).then(function(data){
            if( data.sdp.toLowerCase().indexOf("h264") === -1 ){
                callback( false )
            }else{
                callback( true )
            }
            peer.close();
        },function(data){
            callback( false )
        });
    },

    support: function( opts, callback ){
        if( typeof opts === 'function'){
            this.doCheck({ screenshare: true }, opts)
        }else{
            this.doCheck( opts , callback)
        }
    },
    doCheck: function(opts, callback ){
        var isWebRTCSupported = false;
        ['RTCPeerConnection', 'webkitRTCPeerConnection', 'RTCIceGatherer'].forEach(function(item) {
            if (isWebRTCSupported) {
                return;
            }
            if (item in window) {
                isWebRTCSupported = true;
            }
        });
        var TBSInfo = this.checkTBSVersion();
        if( !TBSInfo.isTBS ){
            if( this.isFF() ){
                isWebRTCSupported = false
            }else if( this.isSafari() && navigator.platform.indexOf("Mac") ===-1 ){
                var iOSVersion = this.iOSVersion();
                if(iOSVersion && iOSVersion[1]>=11 && iOSVersion[2]>=1 ){

                }else{
                    isWebRTCSupported = false
                }
            }
        }
        
        var ret =  {
            support: isWebRTCSupported,
            isTBS : TBSInfo.isTBS,
            isTBSValid: TBSInfo.isTBSValid,
            TBSversion : TBSInfo.TBSversion,
            isSafari : this.isSafari(),
            iOSVersion : this.iOSVersion(),
            screenshare:false,
            isFF : this.isFF()
        }
        this.checkH264Support(function(support){
            ret.h264Support = support
            if( !support ){
                ret.support = false;
            }
            if( !opts.screenshare && callback){
                delete ret.screenshare;
                callback( ret )
                return;
            }
            var extensionId = opts.extensionId || null;
            ScreenChromeExtensionUtil.getChromeExtensionStatus(extensionId, function( extensionResult ) {
                if (extensionResult === 'installed-enabled') {
                    ScreenChromeExtensionUtil.isChromeExtensionAvailable(function(isAvailable) {
                        if (!isAvailable) {
                            // alert('检测没有通过，请先安装chrome屏幕分享插件');
                        } else {
                            // alert('检测通过，可以进入Demo');
                            ret.screenshare = true;
                        }
                        if( callback ){
                            callback( ret )
                        }
                    });
                } else {
                    if( callback ){
                        callback( ret )
                    }
                }
            });
        });
        return ret;
    },
    isTBS: function(){
        var result = this.checkTBSVersion();
        return result.isTBS;
    },
    isSafari: function(){
        return navigator.userAgent.toLowerCase().indexOf('safari/') > -1 &&  navigator.userAgent.toLowerCase().indexOf('chrome/') === -1;
    },
    iOSVersion: function(){
        var matches = (navigator.userAgent).match(/OS (\d+)_(\d+)_?(\d+)?/);
        return (matches && [
            parseInt(matches[1]),
            parseInt(matches[2]),
            parseInt(matches[3] || 0)
        ] || false)
    },
    isFF: function(){
        return navigator.userAgent.toLowerCase().indexOf("firefox") !== -1;
    },
    isChrome: function(){
        return /Chrome/.test(navigator.userAgent) && /Google Inc/.test(navigator.vendor);
    },
    detectMediaDevice: function( callback ){
        var hasAudio = false;
        var hasVideo = false;
        navigator.mediaDevices.enumerateDevices()
        .then(function(devices) {
            var VideoList = []
            devices.forEach(function(device) {
                if (device && device.kind === "videoinput" ) {
                    hasVideo = true;
                }else if (device && device.kind === "audioinput" ) {
                    hasAudio = true;
                }
            });
            if( callback){
                callback( {
                    hasAudio: hasAudio,
                    hasVideo: hasVideo
                } );
            }
        })
        .catch(function(err) {
            if( callback ){
                callback( {
                    hasAudio: hasAudio,
                    hasVideo: hasVideo
                } );
            }
        });

    }
}

module.exports = DectectRTC;



/***/ }),
/* 10 */,
/* 11 */,
/* 12 */,
/* 13 */,
/* 14 */,
/* 15 */,
/* 16 */,
/* 17 */,
/* 18 */,
/* 19 */,
/* 20 */,
/* 21 */,
/* 22 */,
/* 23 */,
/* 24 */,
/* 25 */,
/* 26 */,
/* 27 */,
/* 28 */,
/* 29 */
/***/ (function(module, exports, __webpack_require__) {

__webpack_require__(7);
__webpack_require__(30);
__webpack_require__(31);
__webpack_require__(32);
module.exports = __webpack_require__(33);


/***/ }),
/* 30 */
/***/ (function(module, exports) {

window.ScreenChromeExtensionUtil = {};
(function(util) {
  // Last time updated on: June 08, 2018

// Latest file can be found here: https://cdn.webrtc-experiment.com/Screen-Capturing.js

// Muaz Khan     - www.MuazKhan.com
// MIT License   - www.WebRTC-Experiment.com/licence
// Documentation - https://github.com/muaz-khan/Chrome-Extensions/tree/master/Screen-Capturing.js
// Demo          - https://www.webrtc-experiment.com/Screen-Capturing/

// ___________________
// Screen-Capturing.js

// Source code: https://github.com/muaz-khan/Chrome-Extensions/tree/master/desktopCapture
// Google AppStore installation path: https://chrome.google.com/webstore/detail/screen-capturing/ajhifddimkapgcifgcodmmfdlknahffk

// This JavaScript file is aimed to explain steps needed to integrate above chrome extension
// in your own webpages

// Usage:
// getScreenConstraints(function(screen_constraints) {
//    navigator.mediaDevices.getUserMedia({ video: screen_constraints }).then(onSuccess).catch(onFailure );
// });

// First Step: Download the extension, modify "manifest.json" and publish to Google AppStore
//             https://github.com/muaz-khan/Chrome-Extensions/tree/master/desktopCapture#how-to-publish-yourself

// Second Step: Listen for postMessage handler
// postMessage is used to exchange "sourceId" between chrome extension and you webpage.
// though, there are tons other options as well, e.g. XHR-signaling, websockets, etc.
window.addEventListener('message', function(event) {
    if (event.origin != window.location.origin) {
        return;
    }

    onMessageCallback(event.data);
});

// and the function that handles received messages

function onMessageCallback(data) {
    // "cancel" button is clicked
    if (data == 'PermissionDeniedError') {
        chromeMediaSource = 'PermissionDeniedError';
        if (screenCallback) return screenCallback('PermissionDeniedError');
        else throw new Error('PermissionDeniedError');
    }

    // extension notified his presence
    if (data == 'rtcmulticonnection-extension-loaded') {
        chromeMediaSource = 'desktop';
    }

    // extension shared temp sourceId
    if (data.sourceId && screenCallback) {
        screenCallback(sourceId = data.sourceId, data.canRequestAudioTrack === true);
    }
}

// global variables
var chromeMediaSource = 'screen';
var sourceId;
var screenCallback;

// this method can be used to check if chrome extension is installed & enabled.
function isChromeExtensionAvailable(callback) {
    if (!callback) return;

    if (chromeMediaSource == 'desktop') return callback(true);

    // ask extension if it is available
    window.postMessage('are-you-there', '*');

    setTimeout(function() {
        if (chromeMediaSource == 'screen') {
            callback(false);
        } else callback(true);
    }, 2000);
}

// this function can be used to get "source-id" from the extension
function getSourceId(callback) {
    if (!callback) throw '"callback" parameter is mandatory.';
    if(sourceId) return callback(sourceId);
    
    screenCallback = callback;
    window.postMessage('get-sourceId', '*');
}

// this function can be used to get "source-id" from the extension
function getCustomSourceId(arr, callback) {
    if (!arr || !arr.forEach) throw '"arr" parameter is mandatory and it must be an array.';
    if (!callback) throw '"callback" parameter is mandatory.';

    if(sourceId) return callback(sourceId);
    
    screenCallback = callback;
    window.postMessage({
        'get-custom-sourceId': arr
    }, '*');
}

// this function can be used to get "source-id" from the extension
function getSourceIdWithAudio(callback) {
    if (!callback) throw '"callback" parameter is mandatory.';
    if(sourceId) return callback(sourceId);
    
    screenCallback = callback;
    window.postMessage('audio-plus-tab', '*');
}

// this function can be used to get "source-id" from the extension
function getSourceIdWithCustom(sources, callback) {
    if (!callback) throw '"callback" parameter is mandatory.';
    if(sourceId) return callback(sourceId);
    screenCallback = callback;
    window.postMessage(sources, '*');
}
// this function can be used to get "source-id" from the extension
function cancelChooseDesktopMedia(callback) {
    console.error('lalalal')
    window.postMessage('cancel-choose-media','*');
}

var isFirefox = typeof window.InstallTrigger !== 'undefined';
var isOpera = !!window.opera || navigator.userAgent.indexOf(' OPR/') >= 0;
var isChrome = !!window.chrome && !isOpera;

function getChromeExtensionStatus(extensionid, callback) {
    if (isFirefox) return callback('not-chrome');

    if (arguments.length != 2) {
        callback = extensionid;
    }
    extensionid = extensionid || 'igbnnaaplbclljbpbhaplekapmfegkmg'; // default extension-id
    var image = document.createElement('img');
    image.src = 'chrome-extension://' + extensionid + '/qcloud.png';
    image.onload = function() {
        chromeMediaSource = 'screen';
        window.postMessage('are-you-there', '*');
        setTimeout(function() {
            if (chromeMediaSource == 'screen') {
                callback('installed-disabled');
            } else callback('installed-enabled');
        }, 2000);
    };
    image.onerror = function() {
        callback('not-installed');
    };
}

function getScreenConstraintsWithAudio(callback) {
    getScreenConstraints({
        type:'audio'
    },callback);
}

// this function explains how to use above methods/objects
function getScreenConstraints(opts,callback) {
    var type = opts && opts.type
    var firefoxScreenConstraints = {
        mozMediaSource: 'window',
        mediaSource: 'window'
    };

    if(isFirefox) return callback(null, firefoxScreenConstraints);
    // this statement defines getUserMedia constraints
    // that will be used to capture content of screen
    var screen_constraints = {
        mandatory: {
            chromeMediaSource: chromeMediaSource,
            maxWidth: screen.width > 1920 ? screen.width : 1920,
            maxHeight: screen.height > 1080 ? screen.height : 1080
        },
        optional: []
    };

    // this statement verifies chrome extension availability
    // if installed and available then it will invoke extension API
    // otherwise it will fallback to command-line based screen capturing API
    if (chromeMediaSource == 'desktop' && !sourceId) {
        if(type && type =='custom'){
            getSourceIdWithCustom(opts.source,function(sourceId, canRequestAudioTrack) {
                screen_constraints.mandatory.chromeMediaSourceId = sourceId;
                screen_constraints.canRequestAudioTrack = canRequestAudioTrack;
                callback(sourceId == 'PermissionDeniedError' ? sourceId : null, screen_constraints);
            });
        }
        else if(type && type =='audio') {
            getSourceIdWithAudio(function(sourceId, canRequestAudioTrack) {
                screen_constraints.mandatory.chromeMediaSourceId = sourceId;

                if(canRequestAudioTrack) {
                    screen_constraints.canRequestAudioTrack = true;
                }
                callback(sourceId == 'PermissionDeniedError' ? sourceId : null, screen_constraints);
            });
        }
        else {
            getSourceId(function(sourceId) {
                screen_constraints.mandatory.chromeMediaSourceId = sourceId;
                callback(sourceId == 'PermissionDeniedError' ? sourceId : null, screen_constraints);
            });
        }
        return;
    }

    // this statement sets gets 'sourceId" and sets "chromeMediaSourceId" 
    if (chromeMediaSource == 'desktop') {
        screen_constraints.mandatory.chromeMediaSourceId = sourceId;
    }

    // now invoking native getUserMedia API
    callback(null, screen_constraints);
}

  function resetGlobalData(){
    sourceId = null
    screenCallback = null
  }

  util.isChromeExtensionAvailable = isChromeExtensionAvailable;
  util.getScreenConstraints = getScreenConstraints;
  util.getChromeExtensionStatus = getChromeExtensionStatus;
  util.resetGlobalData = resetGlobalData
  util.cancelChooseDesktopMedia = cancelChooseDesktopMedia


  
})(ScreenChromeExtensionUtil);
 

/***/ }),
/* 31 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


// Last time updated: 2017-11-19 4:49:44 AM UTC

// _______________
// getStats v1.0.6

// Open-Sourced: https://github.com/muaz-khan/getStats

// --------------------------------------------------
// Muaz Khan     - www.MuazKhan.com
// MIT License   - www.WebRTC-Experiment.com/licence
// --------------------------------------------------

window.getStats = function(mediaStreamTrack, callback, interval) {

    var RTCPeerConnection = window.RTCPeerConnection || window.mozRTCPeerConnection || window.webkitRTCPeerConnection;

    if (typeof MediaStreamTrack === 'undefined') {
        MediaStreamTrack = {}; // todo?
    }
    

    var systemNetworkType = ((navigator.connection || {}).type || 'unknown').toString().toLowerCase();

    var getStatsResult = {
        encryption: 'sha-256',
        audio: {
            send: {
                tracks: [],
                codecs: [],
                availableBandwidth: 0,
                streams: 0
            },
            recv: {
                tracks: [],
                codecs: [],
                availableBandwidth: 0,
                streams: 0
            },
            bytesSent: 0,
            bytesReceived: 0
        },
        video: {
            send: {
                tracks: [],
                codecs: [],
                availableBandwidth: 0,
                streams: 0
            },
            recv: {
                tracks: [],
                codecs: [],
                availableBandwidth: 0,
                streams: 0
            },
            bytesSent: 0,
            bytesReceived: 0
        },
        bandwidth: {
            systemBandwidth: 0,
            sentPerSecond: 0,
            encodedPerSecond: 0,
            helper: {
                audioBytesSent: 0,
                videoBytestSent: 0
            },
            speed: 0
        },
        results: {},
        connectionType: {
            systemNetworkType: systemNetworkType,
            systemIpAddress: '192.168.1.2',
            local: {
                candidateType: [],
                transport: [],
                ipAddress: [],
                networkType: []
            },
            remote: {
                candidateType: [],
                transport: [],
                ipAddress: [],
                networkType: []
            }
        },
        resolutions: {
            send: {
                width: 0,
                height: 0
            },
            recv: {
                width: 0,
                height: 0
            }
        },
        internal: {
            audio: {
                send: {},
                recv: {}
            },
            video: {
                send: {},
                recv: {}
            },
            candidates: {}
        },
        nomore: function() {
            nomore = true;
        }
    };

    var getStatsParser = {
        checkIfOfferer: function(result) {
            if (result.type === 'googLibjingleSession') {
                getStatsResult.isOfferer = result.googInitiator;
            }
        }
    };

    var peer = this;

    if (arguments[0] instanceof RTCPeerConnection) {
        peer = arguments[0];

        if (!!navigator.mozGetUserMedia) {
            mediaStreamTrack = arguments[1];
            callback = arguments[2];
            interval = arguments[3];
        }

        if (!(mediaStreamTrack instanceof MediaStreamTrack) && !!navigator.mozGetUserMedia) {
            throw '2nd argument is not instance of MediaStreamTrack.';
        }
    }else if( this instanceof RTCPeerConnection ){
        mediaStreamTrack = this;
        callback = arguments[0];
        interval = arguments[1];
    } else if (!(mediaStreamTrack instanceof MediaStreamTrack) && !!navigator.mozGetUserMedia) {
        throw '1st argument is not instance of MediaStreamTrack.';
    }

    var nomore = false;

    function getStatsLooper() {
        getStatsWrapper(function(results) {
            results.forEach(function(result) {
                Object.keys(getStatsParser).forEach(function(key) {
                    if (typeof getStatsParser[key] === 'function') {
                        getStatsParser[key](result);
                    }
                });

                if (result.type !== 'local-candidate' && result.type !== 'remote-candidate' && result.type !== 'candidate-pair') {
                    // console.error('result', result);
                }
            });

            try {
                // failed|closed
                if (peer.iceConnectionState.search(/failed/gi) !== -1) {
                    nomore = true;
                }
            } catch (e) {
                nomore = true;
            }

            if (nomore === true) {
                if (getStatsResult.datachannel) {
                    getStatsResult.datachannel.state = 'close';
                }
                getStatsResult.ended = true;
            }

            // allow users to access native results
            getStatsResult.results = results;

            if (getStatsResult.audio && getStatsResult.video) {
                getStatsResult.bandwidth.speed = (getStatsResult.audio.bytesSent - getStatsResult.bandwidth.helper.audioBytesSent) + (getStatsResult.video.bytesSent - getStatsResult.bandwidth.helper.videoBytesSent);
                getStatsResult.bandwidth.helper.audioBytesSent = getStatsResult.audio.bytesSent;
                getStatsResult.bandwidth.helper.videoBytesSent = getStatsResult.video.bytesSent;
            }

            callback(getStatsResult);

            // second argument checks to see, if target-user is still connected.
            if (!nomore) {
                typeof interval != undefined && interval && setTimeout(getStatsLooper, interval || 1000);
            }
        });
    }

    // a wrapper around getStats which hides the differences (where possible)
    // following code-snippet is taken from somewhere on the github
    function getStatsWrapper(cb) {
        // if !peer or peer.signalingState == 'closed' then return;

        if (typeof window.InstallTrigger !== 'undefined') {
            peer.getStats(
                mediaStreamTrack,
                function(res) {
                    var items = [];
                    res.forEach(function(r) {
                        items.push(r);
                    });
                    cb(items);
                },
                cb
            );
        } else {
            peer.getStats(function(res) {
                var items = [];
                res.result().forEach(function(res) {
                    var item = {};
                    res.names().forEach(function(name) {
                        item[name] = res.stat(name);
                    });
                    item.id = res.id;
                    item.type = res.type;
                    item.timestamp = res.timestamp;
                    items.push(item);
                });
                cb(items);
            });
        }
    };

    getStatsParser.datachannel = function(result) {
        if (result.type !== 'datachannel') return;

        getStatsResult.datachannel = {
            state: result.state // open or connecting
        }
    };

    getStatsParser.googCertificate = function(result) {
        if (result.type == 'googCertificate') {
            getStatsResult.encryption = result.googFingerprintAlgorithm;
        }
    };

    var AUDIO_codecs = ['opus', 'isac', 'ilbc'];

    getStatsParser.checkAudioTracks = function(result) {
        if (!result.googCodecName || result.mediaType !== 'audio') return;

        if (AUDIO_codecs.indexOf(result.googCodecName.toLowerCase()) === -1) return;

        var sendrecvType = result.id.split('_').pop();

        if (getStatsResult.audio[sendrecvType].codecs.indexOf(result.googCodecName) === -1) {
            getStatsResult.audio[sendrecvType].codecs.push(result.googCodecName);
        }

        if (result.bytesSent) {
            var kilobytes = 0;
            if (!!result.bytesSent) {
                if (!getStatsResult.internal.audio[sendrecvType].prevBytesSent) {
                    getStatsResult.internal.audio[sendrecvType].prevBytesSent = result.bytesSent;
                }

                var bytes = result.bytesSent - getStatsResult.internal.audio[sendrecvType].prevBytesSent;
                getStatsResult.internal.audio[sendrecvType].prevBytesSent = result.bytesSent;

                kilobytes = bytes / 1024;
            }

            getStatsResult.audio[sendrecvType].availableBandwidth = kilobytes.toFixed(1);
        }

        if (result.bytesReceived) {
            var kilobytes = 0;
            if (!!result.bytesReceived) {
                if (!getStatsResult.internal.audio[sendrecvType].prevBytesReceived) {
                    getStatsResult.internal.audio[sendrecvType].prevBytesReceived = result.bytesReceived;
                }

                var bytes = result.bytesReceived - getStatsResult.internal.audio[sendrecvType].prevBytesReceived;
                getStatsResult.internal.audio[sendrecvType].prevBytesReceived = result.bytesReceived;

                kilobytes = bytes / 1024;
            }

            getStatsResult.audio[sendrecvType].availableBandwidth = kilobytes.toFixed(1);
        }

        if (getStatsResult.audio[sendrecvType].tracks.indexOf(result.googTrackId) === -1) {
            getStatsResult.audio[sendrecvType].tracks.push(result.googTrackId);
        }
    };

    var VIDEO_codecs = ['vp9', 'vp8', 'h264'];

    getStatsParser.checkVideoTracks = function(result) {
        if (!result.googCodecName || result.mediaType !== 'video') return;

        if (VIDEO_codecs.indexOf(result.googCodecName.toLowerCase()) === -1) return;

        // googCurrentDelayMs, googRenderDelayMs, googTargetDelayMs
        // transportId === 'Channel-audio-1'
        var sendrecvType = result.id.split('_').pop();

        if (getStatsResult.video[sendrecvType].codecs.indexOf(result.googCodecName) === -1) {
            getStatsResult.video[sendrecvType].codecs.push(result.googCodecName);
        }

        if (!!result.bytesSent) {
            var kilobytes = 0;
            if (!getStatsResult.internal.video[sendrecvType].prevBytesSent) {
                getStatsResult.internal.video[sendrecvType].prevBytesSent = result.bytesSent;
            }

            var bytes = result.bytesSent - getStatsResult.internal.video[sendrecvType].prevBytesSent;
            getStatsResult.internal.video[sendrecvType].prevBytesSent = result.bytesSent;

            kilobytes = bytes / 1024;
        }

        if (!!result.bytesReceived) {
            var kilobytes = 0;
            if (!getStatsResult.internal.video[sendrecvType].prevBytesReceived) {
                getStatsResult.internal.video[sendrecvType].prevBytesReceived = result.bytesReceived;
            }

            var bytes = result.bytesReceived - getStatsResult.internal.video[sendrecvType].prevBytesReceived;
            getStatsResult.internal.video[sendrecvType].prevBytesReceived = result.bytesReceived;

            kilobytes = bytes / 1024;
        }

        getStatsResult.video[sendrecvType].availableBandwidth = kilobytes.toFixed(1);

        if (result.googFrameHeightReceived && result.googFrameWidthReceived) {
            getStatsResult.resolutions[sendrecvType].width = result.googFrameWidthReceived;
            getStatsResult.resolutions[sendrecvType].height = result.googFrameHeightReceived;
        }

        if (result.googFrameHeightSent && result.googFrameWidthSent) {
            getStatsResult.resolutions[sendrecvType].width = result.googFrameWidthSent;
            getStatsResult.resolutions[sendrecvType].height = result.googFrameHeightSent;
        }

        if (getStatsResult.video[sendrecvType].tracks.indexOf(result.googTrackId) === -1) {
            getStatsResult.video[sendrecvType].tracks.push(result.googTrackId);
        }
    };

    getStatsParser.bweforvideo = function(result) {
        if (result.type !== 'VideoBwe') return;

        getStatsResult.bandwidth.availableSendBandwidth = result.googAvailableSendBandwidth;

        getStatsResult.bandwidth.googActualEncBitrate = result.googActualEncBitrate;
        getStatsResult.bandwidth.googAvailableSendBandwidth = result.googAvailableSendBandwidth;
        getStatsResult.bandwidth.googAvailableReceiveBandwidth = result.googAvailableReceiveBandwidth;
        getStatsResult.bandwidth.googRetransmitBitrate = result.googRetransmitBitrate;
        getStatsResult.bandwidth.googTargetEncBitrate = result.googTargetEncBitrate;
        getStatsResult.bandwidth.googBucketDelay = result.googBucketDelay;
        getStatsResult.bandwidth.googTransmitBitrate = result.googTransmitBitrate;
    };

    getStatsParser.candidatePair = function(result) {
        if (result.type !== 'googCandidatePair' && result.type !== 'candidate-pair') return;

        // result.googActiveConnection means either STUN or TURN is used.

        if (result.googActiveConnection == 'true') {
            // id === 'Conn-audio-1-0'
            // localCandidateId, remoteCandidateId

            // bytesSent, bytesReceived

            Object.keys(getStatsResult.internal.candidates).forEach(function(cid) {
                var candidate = getStatsResult.internal.candidates[cid];
                if (candidate.ipAddress.indexOf(result.googLocalAddress) !== -1) {
                    getStatsResult.connectionType.local.candidateType = candidate.candidateType;
                    getStatsResult.connectionType.local.ipAddress = candidate.ipAddress;
                    getStatsResult.connectionType.local.networkType = candidate.networkType;
                    getStatsResult.connectionType.local.transport = candidate.transport;
                }
                if (candidate.ipAddress.indexOf(result.googRemoteAddress) !== -1) {
                    getStatsResult.connectionType.remote.candidateType = candidate.candidateType;
                    getStatsResult.connectionType.remote.ipAddress = candidate.ipAddress;
                    getStatsResult.connectionType.remote.networkType = candidate.networkType;
                    getStatsResult.connectionType.remote.transport = candidate.transport;
                }
            });

            getStatsResult.connectionType.transport = result.googTransportType;

            var localCandidate = getStatsResult.internal.candidates[result.localCandidateId];
            if (localCandidate) {
                if (localCandidate.ipAddress) {
                    getStatsResult.connectionType.systemIpAddress = localCandidate.ipAddress;
                }
            }

            var remoteCandidate = getStatsResult.internal.candidates[result.remoteCandidateId];
            if (remoteCandidate) {
                if (remoteCandidate.ipAddress) {
                    getStatsResult.connectionType.systemIpAddress = remoteCandidate.ipAddress;
                }
            }
        }

        if (result.type === 'candidate-pair') {
            if (result.selected === true && result.nominated === true && result.state === 'succeeded') {
                // remoteCandidateId, localCandidateId, componentId
                var localCandidate = getStatsResult.internal.candidates[result.remoteCandidateId];
                var remoteCandidate = getStatsResult.internal.candidates[result.remoteCandidateId];

                // Firefox used above two pairs for connection
            }
        }
    };

    var LOCAL_candidateType = {};
    var LOCAL_transport = {};
    var LOCAL_ipAddress = {};
    var LOCAL_networkType = {};

    getStatsParser.localcandidate = function(result) {
        if (result.type !== 'localcandidate' && result.type !== 'local-candidate') return;
        if (!result.id) return;

        if (!LOCAL_candidateType[result.id]) {
            LOCAL_candidateType[result.id] = [];
        }

        if (!LOCAL_transport[result.id]) {
            LOCAL_transport[result.id] = [];
        }

        if (!LOCAL_ipAddress[result.id]) {
            LOCAL_ipAddress[result.id] = [];
        }

        if (!LOCAL_networkType[result.id]) {
            LOCAL_networkType[result.id] = [];
        }

        if (result.candidateType && LOCAL_candidateType[result.id].indexOf(result.candidateType) === -1) {
            LOCAL_candidateType[result.id].push(result.candidateType);
        }

        if (result.transport && LOCAL_transport[result.id].indexOf(result.transport) === -1) {
            LOCAL_transport[result.id].push(result.transport);
        }

        if (result.ipAddress && LOCAL_ipAddress[result.id].indexOf(result.ipAddress + ':' + result.portNumber) === -1) {
            LOCAL_ipAddress[result.id].push(result.ipAddress + ':' + result.portNumber);
        }

        if (result.networkType && LOCAL_networkType[result.id].indexOf(result.networkType) === -1) {
            LOCAL_networkType[result.id].push(result.networkType);
        }

        getStatsResult.internal.candidates[result.id] = {
            candidateType: LOCAL_candidateType[result.id],
            ipAddress: LOCAL_ipAddress[result.id],
            portNumber: result.portNumber,
            networkType: LOCAL_networkType[result.id],
            priority: result.priority,
            transport: LOCAL_transport[result.id],
            timestamp: result.timestamp,
            id: result.id,
            type: result.type
        };

        getStatsResult.connectionType.local.candidateType = LOCAL_candidateType[result.id];
        getStatsResult.connectionType.local.ipAddress = LOCAL_ipAddress[result.id];
        getStatsResult.connectionType.local.networkType = LOCAL_networkType[result.id];
        getStatsResult.connectionType.local.transport = LOCAL_transport[result.id];
    };

    var REMOTE_candidateType = {};
    var REMOTE_transport = {};
    var REMOTE_ipAddress = {};
    var REMOTE_networkType = {};

    getStatsParser.remotecandidate = function(result) {
        if (result.type !== 'remotecandidate' && result.type !== 'remote-candidate') return;
        if (!result.id) return;

        if (!REMOTE_candidateType[result.id]) {
            REMOTE_candidateType[result.id] = [];
        }

        if (!REMOTE_transport[result.id]) {
            REMOTE_transport[result.id] = [];
        }

        if (!REMOTE_ipAddress[result.id]) {
            REMOTE_ipAddress[result.id] = [];
        }

        if (!REMOTE_networkType[result.id]) {
            REMOTE_networkType[result.id] = [];
        }

        if (result.candidateType && REMOTE_candidateType[result.id].indexOf(result.candidateType) === -1) {
            REMOTE_candidateType[result.id].push(result.candidateType);
        }

        if (result.transport && REMOTE_transport[result.id].indexOf(result.transport) === -1) {
            REMOTE_transport[result.id].push(result.transport);
        }

        if (result.ipAddress && REMOTE_ipAddress[result.id].indexOf(result.ipAddress + ':' + result.portNumber) === -1) {
            REMOTE_ipAddress[result.id].push(result.ipAddress + ':' + result.portNumber);
        }

        if (result.networkType && REMOTE_networkType[result.id].indexOf(result.networkType) === -1) {
            REMOTE_networkType[result.id].push(result.networkType);
        }

        getStatsResult.internal.candidates[result.id] = {
            candidateType: REMOTE_candidateType[result.id],
            ipAddress: REMOTE_ipAddress[result.id],
            portNumber: result.portNumber,
            networkType: REMOTE_networkType[result.id],
            priority: result.priority,
            transport: REMOTE_transport[result.id],
            timestamp: result.timestamp,
            id: result.id,
            type: result.type
        };

        getStatsResult.connectionType.remote.candidateType = REMOTE_candidateType[result.id];
        getStatsResult.connectionType.remote.ipAddress = REMOTE_ipAddress[result.id];
        getStatsResult.connectionType.remote.networkType = REMOTE_networkType[result.id];
        getStatsResult.connectionType.remote.transport = REMOTE_transport[result.id];
    };

    getStatsParser.dataSentReceived = function(result) {
        if (!result.googCodecName || (result.mediaType !== 'video' && result.mediaType !== 'audio')) return;

        if (!!result.bytesSent) {
            getStatsResult[result.mediaType].bytesSent = parseInt(result.bytesSent);
        }

        if (!!result.bytesReceived) {
            getStatsResult[result.mediaType].bytesReceived = parseInt(result.bytesReceived);
        }
    };

    var SSRC = {
        audio: {
            send: [],
            recv: []
        },
        video: {
            send: [],
            recv: []
        }
    };

    getStatsParser.ssrc = function(result) {
        if (!result.googCodecName || (result.mediaType !== 'video' && result.mediaType !== 'audio')) return;
        if (result.type !== 'ssrc') return;
        var sendrecvType = result.id.split('_').pop();

        if (SSRC[result.mediaType][sendrecvType].indexOf(result.ssrc) === -1) {
            SSRC[result.mediaType][sendrecvType].push(result.ssrc)
        }

        getStatsResult[result.mediaType][sendrecvType].streams = SSRC[result.mediaType][sendrecvType].length;
    };

    getStatsLooper();

};


/***/ }),
/* 32 */
/***/ (function(module, exports) {



(function(){
        
    if( RTCPeerConnection ){
        RTCPeerConnection.prototype.getPeerStats = window.getStats;
    }



})();

/***/ }),
/* 33 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/* WEBPACK VAR INJECTION */(function(global) {

var Constants = __webpack_require__(1)
var WebRTCStat = __webpack_require__(34)
var PingUtil = __webpack_require__(35)
var Util = __webpack_require__(4)
var RTCUtil = __webpack_require__(36)
var Report = __webpack_require__(8)
var MediaUtil = __webpack_require__(38)
var Log = __webpack_require__(3)
var DetectRTC = __webpack_require__(9)
var WebSocketClient = __webpack_require__(39)
var StreamHandler = __webpack_require__(40)
var Browser = __webpack_require__(41)
var Emitter = __webpack_require__(42)
var mitt = __webpack_require__(43)
var _ = __webpack_require__(44)
var jparam = __webpack_require__(46);
var SoundMeter = __webpack_require__(47)
var isMobile = __webpack_require__(48)
WebRTCStat.init();

var onGetMaxTimeMs = function(data) {
    Log.RTCLog.info("onGetMaxTimeMs: " + JSON.stringify(data) );
};

var configValidation = function( config ,emitter ){
    var checkList = [
        ['userSig','sdkAppId','accountType'], //for normal 
        ['sdkAppId'] //for pre conn
    ];
    var invalid_list = [];
    checkList[config.preconn].forEach( function(item){
        if( typeof config[item] === 'undefined'){
            invalid_list.push( item );
        }
    })
    if( invalid_list.length > 0 ){
        var errorMsg = "WebRTC API init failed! config is incorrect! The following parameters is required!";
        console.error(errorMsg, invalid_list);
        emitter.emit("onInitResult",{
            errorCode: Constants.ERROR_CODE.PARAM_MISSING,
            error: "确定参数是否完整 [" + invalid_list + "]"
        });
        return false
    }
    return true
}

function WebRTCAPI( config , succ , fail ){
    var $self = this,
        emitter = this.emitter = mitt();
    var global =  this.global = {
        deviceInfo : {
            hasVideo : false,
            hasAudio : false
        },
        inited: false,
        enteredRoom: false,
        checkSigSeq : null,
        relayip : null,
        localip : null,
        signalip : null,
        ostype : null,
        cpunum : 0,
        cpuname : null,
        devicename : null,
        dataport : null,
        stunport : null,
        stunportList : null,
        websocket : null,
        peerConnections : {},
        remoteStreams : {},
        preReportData : null,
        remoteSdps : {},
        config : { },
        reportSto : null,
        reportTime : 0,
        roomid : -1,
        localStreamStatus:false,
        localStream : null,
        localMediaStatus: {
            audio: true,
            video: true
        },
        specifyConstraints : null,//是否由用户指定Constraints
        constraints: {
            audio: true,
            video: true 
        },
        constraintsList:[],
        offerSdpOption: {
            offerToReceiveAudio: true,
            offerToReceiveVideo: true,
            voiceActivityDetection: false
        },
        openIdMap: {},
        tinyIdMap: {},
        retryGetStats:{},
        destroy:false
    };
    config.preconn  = config.preconn ? 1 : 0;
    // 字段名映射
    // 统一兼容其他端
    config.openid = config.userID || config.userId || config.openid;
    config.sdkAppId = config.sdkAppID || config.sdkAppId;
    config.privMapEncrypt = config.privateMapKey || config.privMapEncrypt;
    config.privMap = config.privateMap || config.privMap;

    config.screen = config.screen || false;
    config.canvas = config.canvas || false;
    global.config = config;

    if( typeof config.wsRetryMaxTimes !== 'undefined'){
        Constants.WS_MAX_RETRY_COUNT = config.wsRetryMaxTimes
    }
    if( typeof config.wsRetryDist !== 'undefined'){
        Constants.WS_RETRY_DIST = config.wsRetryDist
    }

    if( typeof config.useCloud === 'undefined'  || config.useCloud){
        Constants.setHostname( "qcloud.rtc.qq.com" );
    }else{
        Constants.setHostname( "webrtc.qq.com" );
    }
    var env = Util.query("env");
    if( env ){
        var domain = env+".rtc.qq.com"
        Constants.setHostname( domain );
    }
    var version = Util.query("version");
    if( version ){
        Constants.InternalVersion = version
    }
    Log.printEnvironmentInfo( global );
    
    //配置debug模式
    if( config.debug ){
        Log.debug( config.debug )
    }

    this.callbacks = {};

    global.rtcReport = new Report( global, emitter )
    global.streamHandler = new StreamHandler( global , emitter)
    global.mediaUtil = new MediaUtil( global, emitter);
    global.rtcUtil = new RTCUtil( global, emitter);
    
    if( isMobile.any ){
        Constants.ConstraintsMode = 1;
    }

    if( !configValidation( config, emitter) ){
        return
    }

    this.onPeerConnectionAdd = function(data) {
        var info = {
            userId : data.srcopenid ? data.srcopenid : $self.getUserId(data.srctinyid),
            tinyid : data.srctinyid
        };
        if( config.peerAddNotify ){
            $self.emit('onPeerConnectionAdd',info)
        }else{
            $self.startRTC( data );
        }
    };
    this.onStartRTCResult = function( data ){
        if( data.errorCode === 0){
            if( $self.callbacks.startRTCSucc){
                $self.callbacks.startRTCSucc( data )
                $self.callbacks.startRTCSucc = null
            }
            if( data.srctinyid === 0){
                global.localStreamStatus = true;
            }
        }else{
            if( $self.callbacks.startRTCError){
                $self.callbacks.startRTCError( data )
                $self.callbacks.startRTCError = null
            }else{
                this.onErrorNotify( data )
            }
            Log.RTCLog.error( data )
        }
    }

    this.onCreateRoomResult = function( data ){
        if( data.errorCode === 0){
            if( $self.callbacks.createRoomSucc){
                $self.callbacks.createRoomSucc( data )
                $self.callbacks.createRoomSucc = null
            }
        }else{
            if( $self.callbacks.createRoomError){
                $self.callbacks.createRoomError( data )
                $self.callbacks.createRoomError = null
            }
            Log.RTCLog.error( data )
        }

        $self.emit('onCreateRoomResult', data);
    }
    

    if( succ ){
        this.connect( succ , fail )
    }
    

    this.onInitResult = function( data ){
        if (data && data.errorCode === 0) {
            $self.callbacks.initSucc && $self.callbacks.initSucc( data );
        }else{
            if( data.errorCode === -1){
                data.errorCode = Constants.ERROR_CODE.INIT_SDK_FAILED
            }
            $self.callbacks.initFail && $self.callbacks.initFail( data );
        }
        if(  $self.callbacks.initSucc ){
            $self.callbacks.initSucc = null;
            $self.callbacks.initFail = null;
        }
        $self.emit('onInitResult', data);
    }

    this.onRemoteStreamUpdate = function(data) {
        if( !data.openId ){
            var tinyId = data.videoId.split("_")[0]
            data.openId = $self.getUserId(tinyId)
        }
        data.userId = data.openId
        $self.emit('onRemoteStreamUpdate',data)
    };

    this.onIceConnectionBuild = function(data) {
        $self.emit('onIceConnectionBuild',data)
    };
    this.onErrorNotify = function( info ) {
        $self.emit('onErrorNotify', info )
    };
    this.onStreamNotify = function( info ) {
        $self.emit('onStreamNotify', info )
    };
    this.execCallback = function( info ) {
        if( $self.callbacks[info.name] ){
            $self.callbacks[info.name](info.data)
        }else{
            this.onErrorNotify( info )
        }
    };
    this.onRemoteStreamRemove = function(videoId) {
        var tinyId = videoId.split("_")[0]
        var info = {
            videoId: videoId,
            openId: $self.getUserId(tinyId),
            userId: $self.getUserId(tinyId)
        };
        $self.emit('onRemoteStreamRemove', info )
    };

    this.onPeerConnectionClose = function(data) {
        Log.RTCLog.info("onPeerConnectionClose : srctinyid = " + data.srctinyid);
        global.websocket.sessioninfo.peersdp[data.srctinyid + ""] = null;
        for (var i = 0; i < global.websocket.sessioninfo.srcids.length; i++) {
            if (global.websocket.sessioninfo.srcids[i] == data.srctinyid) {
                global.websocket.sessioninfo.srcids.splice(i, 1);
                break;
            }
        }
        var peerConnection = global.peerConnections[data.srctinyid];
        if (peerConnection) {
    
            for(var videoId in peerConnection.videoStreams)
            {
                Log.RTCLog.info("onPeerConnectionClose: videoId = " + videoId);
                // rtclistener.config.onRemoteStreamRemove(videoId);
                emitter.emit( 'onRemoteStreamRemove', videoId)
            }
    
            if (peerConnection.signalingState !== 'closed') {
                peerConnection.close();
            }
            peerConnection = null;
            delete global.peerConnections[data.srctinyid];
        }

        if(data.srctinyid == 0 ){
           global.streamHandler.releaseLocal();
        }
    };

    this.createPeerConnection = function(srctinyid) {
        Log.RTCLog.debug('createPeerConnection with srctinyid:' + srctinyid);
        var stun = Constants.GET_STUN();
        var optional = Constants.OPTIONAL;

        try {
            var peerConnection = global.tempPeerConnection ? global.tempPeerConnection : new RTCPeerConnection(stun, optional);
            global.tempPeerConnection = null,
            peerConnection.localCandidateList = [];
            peerConnection.isSdpSendOK = false;
            peerConnection.hasSendCandidate = false;
            global.peerConnections[srctinyid] = peerConnection;
            peerConnection.onicecandidate = function(e) {
                global.rtcUtil.onIceCandidate( e, srctinyid);
            };
            peerConnection.onaddstream = function(e) {
                Log.RTCLog.info("peerConnection.onaddstream:" + e.stream.id);
            };
            peerConnection.oniceconnectionstatechange = function(e) {
                global.rtcUtil.onIceConnectionStateChange( e, srctinyid);
            };
            peerConnection.ontrack = function(e) {
                Log.RTCLog.info("peerConnection.ontrack: streams.length=" + e.streams.length);
                global.rtcUtil.onAddTrack( e.streams[0], e.track.kind, srctinyid);
            };
            peerConnection.onremovestream = function(e) {
                Log.RTCLog.info("peerConnection.onremovestream:" + e.stream.id);
                global.rtcUtil.onRemoveStream( e.stream, srctinyid);
            };
            peerConnection.onsignalingstatechange = function(e) {
                Log.RTCLog.info("peerConnection.onsignalingstatechange:" + peerConnection.signalingState);
            };
            peerConnection.onicegatheringstatechange = function(e) {
                Log.RTCLog.info("peerConnection.onicegatheringstatechange : " + e.target.iceGatheringState);
                $self.emitter.emit("onUserDefinedWebRTCEventNotice", { "event": Constants.USER_DEFINED_EVENT.ON_ICE_GATHERING_STATE_CHANGE, info:e} );
            };
            peerConnection.onnegotiationneeded = function(e) {
                Log.RTCLog.info("peerConnection.onnegotiationneeded");
            };
            $self.emitter.emit("onUserDefinedWebRTCEventNotice", { "event": Constants.USER_DEFINED_EVENT.CREATE_PC_SUC} );
    
        } catch (e) {
            var errorMsg = "create peer connection failed!!! exception : " + e;
            $self.emitter.emit("onUserDefinedWebRTCEventNotice", { "event": Constants.USER_DEFINED_EVENT.CREATE_PC_FAILED, info:e} );
            Log.RTCLog.error(errorMsg);
            if (global.websocket) {
                global.rtcReport.send( Constants.RTC_EVENT.ON_CREATE_PEERCONNECTION_FAILED, errorMsg );
            }
            return false;
        }
        return true;
    };
 
    this.onWebSocketNotify = function( info ){
        $self.emit("onWebSocketNotify",info)
    }

    this.onWebSocketError = function(e){
        $self.quit();
        $self.onWebSocketNotify({
            errorCode: Constants.ERROR_CODE.WS_ERROR,
            errorMsg: "websocket error",
            extInfo: e
        });
    }
 
    this.onWebSocketClose = function(e){
        $self.quit();
        $self.onWebSocketNotify({
            errorCode: Constants.ERROR_CODE.WS_CLOSE,
            errorMsg: "websocket close",
            extInfo: e
        });
    }
    this.onIceConnectionClose = function( info ){
        $self.onErrorNotify({
            errorCode: Constants.ERROR_CODE.ON_ICE_CLOSE,
            errorMsg: "ice close",
            extInfo: info
        });
    }
    this.onIceConnectionBroken = function( info ){
        $self.onErrorNotify({
            errorCode: Constants.ERROR_CODE.ON_ICE_BROKEN,
            errorMsg: "ice broken",
            extInfo: info
        });
    }


    var emitterHandler = {};
    
    emitterHandler.onPeerConnectionAdd = this.onPeerConnectionAdd;
    emitterHandler.onPeerConnectionClose = this.onPeerConnectionClose;
    emitterHandler.onRemoteStreamRemove = this.onRemoteStreamRemove;
    emitterHandler.onRemoteStreamUpdate = this.onRemoteStreamUpdate;
    emitterHandler.onIceConnectionBuild = this.onIceConnectionBuild;
    emitterHandler.onInitResult = this.onInitResult;
    emitterHandler.onStartRTCResult = this.onStartRTCResult;
    emitterHandler.onCreateRoomResult = this.onCreateRoomResult;
    emitterHandler.onErrorNotify = this.onErrorNotify;
    emitterHandler.onStreamNotify = this.onStreamNotify;
    emitterHandler.execCallback = this.execCallback;
    emitterHandler.onWebSocketClose = this.onWebSocketClose;
    emitterHandler.onWebSocketNotify = this.onWebSocketNotify;
    emitterHandler.onIceConnectionBroken = this.onIceConnectionBroken;
    emitterHandler.onIceConnectionClose = this.onIceConnectionClose;

    emitter.on('*', function(type , e ){
        if( emitterHandler[type] ){
            emitterHandler[type](e);
        }else{
            $self.emit(type,e)
        }
    });
};


WebRTCAPI.fn = WebRTCAPI.prototype;

WebRTCAPI.fn.connect = function( succ , fail ){
    var global = this.global;
    var emitter = this.emitter;
    var config = global.config;
    var $self = this;
    if( global.inited ){
        console.error('already inited before ')
        return;
    }


    var stun = Constants.GET_STUN();
    var optional = Constants.OPTIONAL;

    if( succ ){
        this.callbacks.initSucc = succ
    }
    if( fail ){
        this.callbacks.initFail = fail
    }
    /* 
    if ( RTCPeerConnection ) {
        global.tempPeerConnection = new RTCPeerConnection(stun, optional);
        global.tempPeerConnection.tempCreateOffer = global.tempPeerConnection.createOffer( global.offerSdpOption );
        global.tempPeerConnection.tempCreateOffer.then( function(offer){
            console.error( 'offer', offer)
            global.tempPeerConnection.setLocalDescription( offer )
        })
    }
     */
    var initWebSocket = function() {
        try {
            //step 1 : init webrtc upload key step
            Log.uploadWebLog(global, "begin init websocket", null, Constants.KEY_TAG.WEBSOCKET_TAG);

            //set userSig appid identifer in url
            var identifier = encodeURIComponent(global.config.openid).replace(/'/g, "%27").replace(/"/g, "%22");
            var url = Constants.WS_URL + "?" + 
            jparam({
                sdkAppid: global.config.sdkAppId,
                identifier: identifier,
                userSig: global.config.userSig
            });
            if (global.websocket) {
                var msg = "create a websocket instance, but the old one does not destroy! close the old one!"
                try {
                    Log.uploadWebLog(global, msg, null, Constants.KEY_TAG.WEBSOCKET_TAG);
                    global.websocket.close();
                } catch (e) {
                    $self.emitter.emit('onErrorNotify',{
                        errorCode: Constants.ERROR_CODE.INIT_WS_FAILED,
                        errorMsg: msg
                    });
                }
                global.websocket = null;
            }

            // emitter.emit("onUserDefinedWebRTCEventNotice",Constants.USER_DEFINED_EVENT.WEBSOCKET_INIT, null)
            emitter.emit("onUserDefinedWebRTCEventNotice", { "event": Constants.USER_DEFINED_EVENT.WEBSOCKET_INIT} );

            global.websocket = new WebSocketClient( global );
            global.websocket.onmessage = wsonmessage;
            global.websocket.onopen = wsonopen;
            global.websocket.onclose = wsonclose;
            global.websocket.onerror = wsonerror;
            global.websocket.onneedreconnect = wsonneedreconnect;
            global.websocket.open(url);

        } catch (e) {
            var errorStr = "init web socket failed!!! exception = " + e.message;
            emitter.emit('onInitResult', {
                errorCode : Constants.ERROR_CODE.INIT_WS_FAILED,
                errorMsg : errorStr
            } )
            Log.uploadWebLog(global, errorStr, null, Constants.KEY_TAG.WEBSOCKET_BUILD_FAILED_TAG);
            Log.RTCLog.error(errorStr);
        }
    };



    var wsonopen = function() {
        var msg = "web socket init success"
        Log.uploadWebLog(global, msg, null, Constants.KEY_TAG.WEBSOCKET_TAG);
        Log.RTCLog.info( msg );
        global.inited = true
        emitter.emit("onWebSocketNotify",{
            errorCode: 0,
            errorMsg: msg
        })
    };
    var wsonneedreconnect = function (e) {
        if (global.websocket) {
            global.websocket.reconnect();
        }
    };

    var wsonclose = function(e) {
        var str = "websocket close! , code = " + e.code;
        Log.uploadWebLog(global, str, null, "WEBSOCKET");
        Log.RTCLog.warn(str);
        switch (e.code) {
            case 1000:
                break;
            case 1006:
                var msg = "Websocket close! Network is broken!";
                Log.uploadWebLog(global, msg, null, "WEBSOCKET");
                emitter.emit("onUserDefinedWebRTCEventNotice", { "event": Constants.USER_DEFINED_EVENT.ON_WEBSOCKET_CLOSE_BY_NETWORK_BROKEN, info:e} );
                break;
            default:
                break;
        }
        emitter.emit('onWebSocketClose', e)
    };

    var wsonerror = function(e) {
        var msg = "Websocket close with error reason ! Network is broken!";
        Log.uploadWebLog(global, msg, null, "WEBSOCKET");
        global.inited = false;
        global.enteredRoom = false;
        emitter.emit('onWebSocketError', e)
    };


    var wsonmessage = function(message) {
        if( global.destroy ){
            return;
        }
        var msg = message.data;
        var resJson = JSON.parse(msg);
        var cmd = resJson.cmd;
        Log.RTCLog.info("[websocket][recv]"+msg);
        var LOGTAG = "RECV_CMD_FROM_SIGNAL";
        Log.uploadWebLog(global, "WebRTCJSAPI receive cmd from signal server : cmd = " + cmd, null, LOGTAG);

        if (cmd === Constants.WS_CMD.CANDIDATE) {
            Log.uploadWebLog(global, "WebRTCJSAPI receive remote candidate from siganl server, srctinyid = " + resJson.srctinyid, null, LOGTAG);
            global.rtcUtil.onRemoteCandidate(resJson.content, resJson.srctinyid);
        } else if (cmd === Constants.WS_CMD.SDP) {
            Log.uploadWebLog(global, "WebRTCJSAPI receive remote sdp from siganl server, srctinyid = " + resJson.srctinyid, null, LOGTAG);
            if(Constants.InternalVersion < 1001 || parseInt(resJson.srctinyid || 0) === 0){
                global.rtcUtil.onRemoteSdp(resJson.content, resJson.srctinyid);
            }
        } else if (cmd === Constants.WS_CMD.MEDIA_CHANGE) {
            Log.uploadWebLog(global, "WebRTCJSAPI receive media change from siganl server", null, LOGTAG);
            onMediaChange(resJson.content);
        } else if (cmd === Constants.WS_CMD.QUIT_CHAT) {
            Log.uploadWebLog(global, "WebRTCJSAPI receive quit chat from siganl server, info = " + JSON.stringify(resJson), null, LOGTAG);
            $self.onQuitChat(resJson.content);
        } else if (cmd === Constants.WS_CMD.WS_INIT_OK) {
            if (!global.config.preconn) {
                global.relayip = resJson.content.relayip;
                global.localip = resJson.content.localip;
                global.dataport = resJson.content.dataport;
                global.stunport = resJson.content.stunport;
                global.checkSigSeq = resJson.content.checkSigSeq;
                global.stunportList = resJson.content.stunportList;
                if (!global.stunportList || global.stunportList.length <= 0) {
                    Constants.WEBRTC_STUN_SERVER = "stun:" + global.relayip + ":" + global.stunport;
                } else {
                    var webrtcStunList = [];
                    for (var i = 0 ; i < global.stunportList.length; i++) {
                        var port = global.stunportList[i];
                        var stunserver = "stun:" + global.relayip + ":" + port;
                        webrtcStunList.push(stunserver);
                    }
                    Constants.WEBRTC_STUN_SERVER = webrtcStunList;
                }

                if (resJson.content.cgiurl) {
                    Constants.WEBRTC_CGI_URL = resJson.content.cgiurl;
                }

                Log.RTCLog.info("WS_INIT_OK : data = " + JSON.stringify(resJson.content) + " , stun server = " + Constants.WEBRTC_STUN_SERVER);

                global.websocket.relayInfo.stunport = global.stunport;
                global.websocket.relayInfo.outterip = global.relayip;
                global.websocket.relayInfo.dataport = global.dataport;
                global.websocket.relayInfo.innerip = resJson.content.innerip;
                global.websocket.sessioninfo.openid = resJson.content.openid;
                global.websocket.sessioninfo.tinyid = resJson.content.tinyid;

            }
            global.config.tinyid = resJson.content.tinyid;
            global.config.openid = resJson.content.openid;
            global.websocket.socketid = resJson.content.socketid;
            global.signalip = resJson.content.signalip;
            if (resJson.content.cgiurl) {
                Constants.WEBRTC_CGI_URL = resJson.content.cgiurl;
            }

            Log.RTCLog.info("WS_INIT_OK : data = " + JSON.stringify(resJson.content) + " , stun server = " + Constants.WEBRTC_STUN_SERVER);

            
            var rc = resJson.content.rc;

            Log.uploadWebLog(global, "WebRTCJSAPI receive websocket init from siganl server, info = " + JSON.stringify(resJson.content), null, LOGTAG);

            if (rc === 1) {
                console.info("reconnect ok, now rebuild session!");
                var errorCode = global.rtcUtil.rebuildSession();
                if (!errorCode) {

                    try {
                        global.websocket.close();
                        global.websocket = null;
                    } catch (e) {
                        console.error(e);
                    }
                    emitter.emit('onInitResult', {
                        errorCode: Number(resJson.content.errorCode),
                        errorMsg : resJson.content.errorMsg
                    } )
                }
                return;
            }

            if (rc !== 1) {
                emitter.emit("onUserDefinedWebRTCEventNotice", { "event": Constants.USER_DEFINED_EVENT.WEBSOCKET_INIT_OK} );
                emitter.emit('onInitResult', {
                    errorCode : 0,
                    openid : resJson.content.openid,
                    tinyid : resJson.content.tinyid,
                    relayip : global.relayip,
                    innerip :resJson.content.innerip
                } )
            }

        } else if (cmd === Constants.WS_CMD.WS_INIT_FAILED) {
            Log.RTCLog.error("ws init failed !!!  ");
            Log.uploadWebLog(global, "WebRTCJSAPI receive websocket init failed from siganl server", null, LOGTAG);
            try {
                global.websocket.close();
                global.websocket = null;
            } catch (e) {
                console.error(e);
            }
            emitter.emit('onInitResult', {
                errorCode : Constants.ERROR_CODE.INIT_WS_FAILED,
                errorMsg : resJson.content.errorMsg,
                extInfo : resJson.content
            } )
        } else if (cmd === Constants.WS_CMD.CREATE_ROOM_RESULT) {
            var data = resJson.content;
            Log.uploadWebLog(global, "WebRTCJSAPI receive create room errorCode from siganl server, info = " + JSON.stringify(data), null, LOGTAG);
            if (data.ret !== 0) {
                var errorMsg = "create room error!!! e = " + data.error;
                Log.RTCLog.error( errorMsg );
                try {
                    global.websocket.close();
                    global.websocket = null;
                } catch (e) {
                    console.error(e);
                }
                $self.emitter.emit('onCreateRoomResult',{
                    errorCode: Constants.ERROR_CODE.ENTER_ROOM_ERROR,
                    errorMsg: errorMsg,
                    extInfo: data
                });
                return;
            }
            if(global.config.preconn){
                /*加入下发的relay相关信息处理*/
                global.websocket.socketid = data.data.relayInfo.socketid;
                global.relayip = data.data.relayInfo.relayip;
                global.localip = data.data.relayInfo.localip;
                global.signalip = data.data.relayInfo.signalip;
                global.dataport = data.data.relayInfo.dataport;
                global.stunport = data.data.relayInfo.stunport;
                global.checkSigSeq = data.data.relayInfo.checkSigSeq;
                global.stunportList = data.data.relayInfo.stunportList;
                if (!global.stunportList || global.stunportList.length <= 0) {
                    Constants.WEBRTC_STUN_SERVER = "stun:" + global.relayip + ":" + global.stunport;
                } else {
                    var webrtcStunList = [];
                    for (var i = 0 ; i < global.stunportList.length; i++) {
                        var port = global.stunportList[i];
                        var stunserver = "stun:" + global.relayip + ":" + port;
                        webrtcStunList.push(stunserver);
                    }
                    Constants.WEBRTC_STUN_SERVER = webrtcStunList;
                }
                global.websocket.relayInfo.stunport = global.stunport;
                global.websocket.relayInfo.outterip = global.relayip;
                global.websocket.relayInfo.dataport = global.dataport;
                global.websocket.relayInfo.innerip = data.data.relayInfo.innerip;
                global.websocket.sessioninfo.openid = data.data.relayInfo.openid;
                global.websocket.sessioninfo.tinyid = data.data.relayInfo.tinyid;
                global.config.openid = data.data.openid;
                /*下发的相关信息处理结束*/
                
            }

            global.roomid = data.data.roomid;
            global.config.tinyid = data.data.tinyid;
            global.config.srctinyid = data.data.srctinyid;
            global.openIdMap[data.data.tinyid] = data.data.openid;
            global.tinyIdMap[data.data.openid] = data.data.tinyid;

            global.websocket.sessioninfo.sessionid = global.roomid;
            global.websocket.hasConnect = true;
            //init end report
            global.rtcReport.initEndReport();

            if (data.data.videoability && global.specifyConstraints) {
                $self.updateConstraints(data.data.videoability , global.specifyConstraints);
            }else{
                $self.updateConstraints(data.data.videoability);
            }


            Log.RTCLog.info("create room ok!!! data = " + JSON.stringify(data.data));
            if (global.config.preconn) {
                emitter.emit('onCreateRoomResult',{
                    errorCode: 0,
                    relayip: global.relayip,
                    innerip: data.data.relayInfo.innerip,
                    tinyid: global.config.tinyid,
                    openid:global.config.openid
                });
            } else {
                emitter.emit('onCreateRoomResult',{
                    errorCode: 0
                });
            }

            global.reportTime = (new Date()).valueOf();
            Log.RTCLog.info("start quality report : time = " + global.reportTime);
            startQualityReport();
            if(global.config.closeLocalMedia){
                return;
            }
            $self.startPush();

        } else if (cmd === Constants.WS_CMD.NOTIFY_CREATE_PEER_CONNECTION) {
            emitter.emit("onUserDefinedWebRTCEventNotice", { "event": Constants.USER_DEFINED_EVENT.RECEIVE_CREATE_PEER} );
            var data = resJson.content;
            if(!global.remoteSdps[data.srctinyid]){
                global.remoteSdps[data.srctinyid] = data.remoteoffer;
            }
            Log.uploadWebLog(global, "WebRTCJSAPI receive create peerconnection from siganl server, info = " + JSON.stringify(data), null, LOGTAG);
            // if( true ){
            //     global.rtcUtil.addPeer(data.openid, data.tinyid, global.roomid, data.srctinyid, data.userSig, data.peerconnectionport);
            // }else{
                if (data.videoability) {
                    $self.updateConstraints(data.videoability);
                }
                Log.RTCLog.debug("add peer ok!!! data = " + JSON.stringify(data));
                if(data.srcopenid){
                    global.openIdMap[data.srctinyid] = data.srcopenid;
                    global.tinyIdMap[data.srcopenid] = data.srctinyid;
                }
                data.remoteSdp = global.remoteSdps[data.srctinyid]
                emitter.emit('onPeerConnectionAdd', data );
            // }
        } else if (cmd === Constants.WS_CMD.NOTIFY_CREATE_PEER_CONNECTION_RES) {
            emitter.emit("onUserDefinedWebRTCEventNotice", { "event": Constants.USER_DEFINED_EVENT.BEGIN_CREATE_PEER} );
            var data = resJson.content;
            Log.uploadWebLog(global, "WebRTCJSAPI receive create peerconnection res from siganl server, info = " + JSON.stringify(data), null, LOGTAG);
            //video control
            if (data.data.videoability) {
                $self.updateConstraints(data.data.videoability);
            }
            Log.RTCLog.debug("add peer ok!!! data = " + JSON.stringify(data.data));

            if(data.data.srcopenid){
                global.openIdMap[data.data.srctinyid] = data.data.srcopenid;
                global.tinyIdMap[data.data.srcopenid] = data.data.srctinyid;
            }
            data.data.remoteSdp = global.remoteSdps[data.data.srctinyid]

            $self.startRTC(data.data);

        } else if (cmd === Constants.WS_CMD.NOTIFY_CLOSE_PEER_CONNECTION) {
            var data = resJson.content;
            Log.uploadWebLog(global, "WebRTCJSAPI receive close peerconnection from siganl server, info = " + JSON.stringify(data), null, LOGTAG);
            emitter.emit('onPeerConnectionClose', data );
        }
        else if (cmd === Constants.WS_CMD.NOTIFY_CHANGE_CONSTRAINTS) {
            var data = resJson.content;
            Log.uploadWebLog(global, "WebRTCJSAPI receive change constraints from siganl server", null, LOGTAG);
            /* 
                var newConstraints = {
                "audio": global.constraints.audio,
                "video": {
                    width: { exact: parseInt(data.width) },
                    height: { exact: parseInt(data.height) },
                    frameRate: { exact: parseInt(data.frameRate) },
                }
                };
                if(global.constraints.video.deviceId) {
                newConstraints.video.deviceId = global.constraints.video.deviceId;
                }
            */
            var newConstraints = $self.updateConstraints([{
                VidWidth:parseInt(data.width),
                VidHeight: parseInt(data.height),
                frameRate:  parseInt(data.frameRate)
            }] , null);
            //主动更新的情况，不需要再处理constraints了
            if( global.manualUpdateRole ){
                global.manualUpdateRole = false;
                return;
            }
            $self.onChangeConstraints(newConstraints, false, true);
        }
        else if (cmd === Constants.WS_CMD.NOTIFY_SUB_VIDEO_STATE) {
            var data = resJson.content;
            Log.uploadWebLog(global, "WebRTCJSAPI receive notify sub video state from siganl server", null, LOGTAG);
            global.rtcUtil.onSubVideoState(data);
        }
        else if (cmd === Constants.WS_CMD.NOTIFY_UPDATE_AUDIO_SSRC) {
            var data = resJson.content;
            Log.uploadWebLog(global, "WebRTCJSAPI receive update audio ssrc from siganl server", null, LOGTAG);
            global.rtcUtil.onUpdateAudSsrc( data);
        }
        else if (cmd === Constants.WS_CMD.NOTIFY_UPDATE_VIDEO_SSRC) {
            var data = resJson.content;
            Log.uploadWebLog(global, "WebRTCJSAPI receive update video ssrc from siganl server", null, LOGTAG);
            global.rtcUtil.onUpdateVideoSsrc( data);
        }
        else if (cmd === Constants.WS_CMD.NOTIFY_MAX_TIMEMS) {
            var data = resJson.content;
            if( onGetMaxTimeMs ){
                onGetMaxTimeMs({
                    "maxAudTimeMs": data.maxAudTimeMs,
                    "maxVidTimeMs": data.maxVidTimeMs
                });
            }
        }
        else if (cmd === Constants.WS_CMD.NOTIFY_RECONNECT_DC) {
            var data = resJson.content;
            Log.uploadWebLog(global, "WebRTCJSAPI receive NOTIFY_RECONNECT_DC from siganl server", null, LOGTAG);
            this.recreateDataChannel();
        }
        else if (cmd === Constants.WS_CMD.CLOSE_PEER_RES) {
            var data = resJson.content;
            Log.uploadWebLog(global, "WebRTCJSAPI receive CLOSE_PEER_RES from siganl server", null, LOGTAG);
            if( data.ret){
                $self.emitter.emit('onPeerConnectionClose',{
                    srctinyid: 0 
                });
                global.localStreamStatus = false;
                $self.emitter.emit("execCallback",{
                    name:"stopRTCSucc",
                    data: {
                        errorCode: Constants.ERROR_CODE.SUCC,
                        errorMsg: "ok"
                    }
                });
            }else{
                $self.emitter.emit("execCallback",{
                    name:"stopRTCError",
                    data: {
                        errorCode: Constants.ERROR_CODE.STOP_RTC_FAILED,
                        errorMsg: "STOP_RTC_FAILED : " + JSON.stringify( resJson )
                    }
                });
            }
        }
    };

    function startQualityReport() {
        global.reportSto = setInterval(function(){
            global.rtcReport.quality()
        }, 2000);
    }

    var onMediaChange = function(info) {

    };
    this.onQuitChat = function(info) {
        Log.RTCLog.debug("onQuitChat , call onRelayTimeout");
        $self.quit(function(){
            if (info.type === 'kick') {
                $self.emitter.emit('onKickout',info)
            } else {
                $self.emitter.emit('onRelayTimeout',info)
            }
        });
    };


   
        
    if(config.preconn || !config.userSig){
        global.config.preconn = config.preconn || 0;
    } else {
        global.config.userSig = config.userSig;
        global.config.privMapEncrypt = config.privMapEncrypt;
        global.config.openid = config.openid;
        global.config.srctinyid = config.srctinyid;
    }
    global.config.sdkAppId = config.sdkAppId;
    global.config.accountType = config.accountType;
    global.config.closeLocalMedia = config.closeLocalMedia;
    global.config.videoActive = typeof config.video !=='undefined' ? config.video : true;
    global.config.audioActive = typeof config.audio !=='undefined' ? config.audio : true;
    
    // DetectRTC.support( function(support){
    //     if( !!support.support ){
    //         $self.emitter.emit("onErrorNotify",{
    //             errorCode: Constants.ERROR_CODE.NOT_SUPPORT,
    //             errorMsg: 'unsupport webrtc',
    //             extInfo: support
    //         })
    //         return;
    //     }
        DetectRTC.detectMediaDevice(function(data){
            global.deviceInfo = data;
            initWebSocket();
        });
    // });
}

WebRTCAPI.fn.getUserMedia = function( constraints, succ ,fail){
    var global = this.global
    global.mediaUtil.gum( { constraints : _.extend({audio:true,video:true}, constraints)}, function(data){
        succ(data.stream)
    }, function(error){
        fail(error)
    })
}


WebRTCAPI.fn.releaseStream = function( media ){
    media.getTracks().forEach(function(track) {
        track.stop();
    });
    media = null;
}

WebRTCAPI.fn.checkDevice = function(){
    return this.global.deviceInfo;
}

WebRTCAPI.fn.checkInit = function( notify ){
    var global = this.global;
    if( !global.inited && (typeof notify ==='undefined' || notify) ){
        var msg = "uninited , please make sure you have already init";
        Log.RTCLog.error( msg )
        this.emitter.emit("onErrorNotify",{
            errorCode: Constants.ERROR_CODE.NOT_INITED,
            errorMsg: msg
        })
    }
    return global.inited;
}

WebRTCAPI.fn.getLocalStream = function(opts, succ, fail) {
    if( typeof opts === 'function') succ = opts
    if( opts && opts.screen ){
        if( opts.screenSources ){
            opts.type = 'custom';
            opts.source = opts.screenSources
        }
        this.getMediaByScreenShare(  opts , succ, fail );
    }else{
        this.getMediaByCamera( opts, succ, fail );
    }
    
};


WebRTCAPI.fn.getMediaByCamera = function( opts, succ, fail ){
    var global = this.global;

    global.rtcReport.send( Constants.RTC_EVENT.ON_GET_USER_MEDIA );

    if (!global.deviceInfo.hasAudio || !global.config.audioActive) {
        global.constraints.audio = false;
    }
    if (/* !global.deviceInfo.hasVideo || */ !global.config.videoActive) {
        global.constraints.video = false;
    }
    var new_constraints = global.mediaUtil.packConstraints(global.constraints, opts , { frameRate : 20} )
    

    if( !new_constraints.video && !new_constraints.audio ) {return ;}

    global.mediaUtil.gumByMediaDevice( { constraints : new_constraints }, succ, fail)
}

WebRTCAPI.fn.getMediaByScreenShare = function(opts, succ , fail ){
    var global = this.global;
    global.rtcReport.send( Constants.RTC_EVENT.ON_GET_USER_MEDIA );
    ScreenChromeExtensionUtil.resetGlobalData();
    ScreenChromeExtensionUtil.getScreenConstraints( opts, function(error, screen_constraints) {
        if( error ){
            fail && fail({
                errorCode:Constants.ERROR_CODE.GET_USERMEDIA_FAILED,
                errorMsg: error,
                extInfo : { name : error}
            });
            ScreenChromeExtensionUtil.resetGlobalData();
            return;
        }
        //目前后台最大支持的分辨率是 1080P
        if( screen_constraints.mandatory.maxWidth >= 1920){
            screen_constraints.mandatory.maxWidth = 1920;
        }
        if( screen_constraints.mandatory.maxHeight >= 1080){
            screen_constraints.mandatory.maxHeight = 1080;
        }

        var final_constraints = {
          audio: opts.audioDevice || opts.audio || screen_constraints.canRequestAudioTrack,
          video: screen_constraints
        };
        final_constraints = global.mediaUtil.packConstraints(final_constraints, opts , { frameRate : 10} )
        opts.screenSources = opts.screenSources || ['screen', 'window', 'tab', 'audio']
        //如果没有让用户选择音频选项，默认音频开启
        if( !final_constraints.audio && opts.screenSources.indexOf("audio") === -1){
            final_constraints.audio = true;
        }
        if (/* !global.deviceInfo.hasAudio ||  */typeof global.config.audioActive !== 'undefined' && !global.config.audioActive) {
            final_constraints.audio = false;
        }
        global.mediaUtil.gumByScreen({constraints:final_constraints},succ,fail);
      },true);
};

WebRTCAPI.fn.changeLocalMedia = function(device, isOpen) {
    var isVideo = device === 'video' ? true : false;
    var global = this.global;
    Log.RTCLog.debug("change local media : is video : " + isVideo + " , is open = " + isOpen);
    if (!global.localStream) {
        Log.RTCLog.error("change local media failed! local media is null");
        return false;
    }
    if( isVideo ){
        global.localMediaStatus.video = isOpen;
    }else{
        global.localMediaStatus.audio = isOpen;
    }
    var tracks = null;
    var mediaType = 0;
    if (isVideo) {
        tracks = global.localStream.getVideoTracks();
        if (isOpen) {
            mediaType = Constants.MEDIA_CHANGE.OPEN_VIDEO;
        } else {
            mediaType = Constants.MEDIA_CHANGE.CLOSE_VIDEO;
        }
    } else {
        tracks = global.localStream.getAudioTracks();
        if (isOpen) {
            mediaType = Constants.MEDIA_CHANGE.OPEN_AUDIO;
        } else {
            mediaType = Constants.MEDIA_CHANGE.CLOSE_AUDIO;
        }
    }
    for (var i = 0; i < tracks.length; i++) {
        tracks[i].enabled = isOpen;
    }
    global.rtcReport.send( Constants.RTC_EVENT.ON_MEDIA_CHANGE,{
        mediatype: mediaType,
        device : device,
        switch : isOpen
    } );
    return true;
};



WebRTCAPI.fn.enterRoom = WebRTCAPI.fn.createRoom = function(opts, succ, error) {
    var global = this.global,
        $self = this;
        global.enteredRoom = true;
    if( !this.checkInit( false ) ){
        this.connect(function(){
            $self.createRoom( opts, succ, error)    
        });
        return;
    }
    if( succ ){
        $self.callbacks.createRoomSucc = succ;
    }
    if( error ){
        $self.callbacks.createRoomError = error;
    }

    if( opts.constraints ){
        this.setConstraints( opts.constraints )
    }

    if( typeof opts.screen !== 'undefined' ){
        global.config.screen = opts.screen;
        if( opts.screenRole ){
            global.config.screenRole = opts.screenRole
        }
    }

    
    if (global.config.preconn) {
        opts.openid = opts.userId || opts.openid
        //在创建房间时加入sig进行校验
        if (!opts.openid || !opts.userSig ||  !opts.accountType) {
            var errorMsg = "Create room failed! opts is incorrect! ";
            Log.uploadWebLog(global, errorMsg, null, "websocket_tag");
            $self.emitter.emit('onCreateRoomResult',{
                errorCode: Constants.ERROR_CODE.PARAM_MISSING,
                errorMsg: errorMsg
            });
            return;
        }
        global.config.userSig = opts.userSig || global.config.userSig;
        global.config.privMapEncrypt = opts.privateMapKey || opts.privMapEncrypt || global.config.privMapEncrypt;
        global.config.privMap = opts.privateMap || opts.privMap || global.config.privMap;
        global.config.openid = opts.openid || global.config.openid;
        global.config.accountType = opts.accountType || global.config.accountType;
        global.config.srctinyid = 0;
    }
    
    if (!global.inited ){
        var errorMsg = "Create room failed! did not inited yet ! ";
        Log.uploadWebLog(global, errorMsg, null, "websocket_tag");
        $self.emitter.emit('onCreateRoomResult',{
            errorCode: Constants.ERROR_CODE.NOT_INITED,
            errorMsg: errorMsg
        });
        return;
    }
    var roomid , role = "";
    if(typeof opts === 'object'){
        roomid = opts.roomID ||  opts.roomid ||  opts.roomId;
        role = opts.role;
    }else{
        roomid = opts;
    }
    if ( !Number.isInteger(Number(roomid))){
        console.error('[房间号](roomid) '+roomid+' 输入有误，请使用32位整数')
        return
    }

    
    if (!roomid || !role){
        var errorMsg = "Create room failed! opts incorrect! ";
        Log.uploadWebLog(global, errorMsg, null, "websocket_tag");
        $self.emitter.emit('onCreateRoomResult',{
            errorCode: Constants.ERROR_CODE.PARAM_MISSING
        });
        return;
    }

    global.roomid = roomid;
    var 
        openid = global.config.openid,
        tinyid = opts.tinyid || global.config.tinyid,
        roomid = roomid || global.config.roomid,
        role = opts.role || global.config.role,
        userSig = global.config.userSig,
        privMapEncrypt = opts.privateMapKey || opts.privMapEncrypt || global.config.privMapEncrypt,
        privMap = opts.privateMap || opts.privMap || global.config.privMap,
        peerconnectionport = global.config.peerconnectionport,
        pstnBizType = parseInt( opts.pstnBizType || 0),
        pstnPhoneNumber = opts.pstnPhoneNumber || null,
        recordId = opts.recordId || null,
        pureAudioPushMod = opts.pureAudioPushMod || null
        ;
    if(recordId && !Number.isInteger(Number(recordId)) ){
        console.error('[录制ID](recordId) '+recordId+' 输入有误，请使用32位整数')
        return
    }
    if(pureAudioPushMod && !Number.isInteger(Number(pureAudioPushMod)) ){
        pureAudioPushMod = Number(pureAudioPushMod)
        console.error('[纯音频推流类型](pureAudioPushMod) '+pureAudioPushMod+' 输入有误，请使用整数')
        return
    }


    Log.RTCLog.debug("open room : openid = " + openid + " , tinyid = " + tinyid + " ,  roomid = " + roomid);
    var sendData = global.rtcReport.createJsonFromTag( Constants.RTC_EVENT.ON_CREATE_ROOM );
    sendData.data = {
        openid: openid,
        tinyid: tinyid,
        peerconnectionport: peerconnectionport,
        roomid: String(roomid),
        sdkAppID: String(global.config.sdkAppId),
        socketid: global.websocket.socketid,
        userSig: userSig || global.config.userSig,
        privMapEncrypt: privMapEncrypt,
        privMap: privMap,
        relayip: global.websocket.relayInfo.innerip,
        dataport: global.dataport,
        stunport: global.stunport,
        checkSigSeq : global.checkSigSeq,
        pstnBizType: pstnBizType,
        pstnPhoneNumber: pstnPhoneNumber,
        recordId: recordId,
        pureAudioPushMod: pureAudioPushMod,
        role : role,
        jsSdkVersion : Constants.InternalVersion,
        browserVersion: Browser.client.name + "/" + Browser.client.version,
        closeLocalMedia: global.config.closeLocalMedia
    };
    //能力上报
    var reportData = WebRTCStat.ability(global.constraints);
    this.global.ostype = reportData.AbilityOption.GeneralLimit.str_os_verion;
    this.global.cpunum = parseInt(reportData.AbilityOption.GeneralLimit.CPULimit.uint32_CPU_num);
    this.global.cpuname = reportData.AbilityOption.GeneralLimit.CPULimit.str_CPU_name;
    sendData.report = reportData || null;
    if( this.global.websocket ){
        this.global.websocket.send(JSON.stringify(sendData));
    }else{
        $self.emitter.emit('onCreateRoomResult',{
            errorCode:Constants.ERROR_CODE.NOT_INITED,
            errorMsg:'websocket 尚未建立连接，请确认已经完成了初始化'
        });
        Log.RTCLog.error( 'websocket 尚未建立连接，请确认已经完成了初始化' )
    }
};

WebRTCAPI.fn.pushStream = function( stream ){
    var global = this.global
    var $self = this
    var peerConnection = global.peerConnections[0];
    if (peerConnection) {
        global.streamHandler.addLocal( peerConnection , stream);
    }
    $self.emitter.emit('onLocalStreamAdd',{
        stream : stream
    });
    global.rtcUtil.getSdp(0, function(errorCode, info) {
        if (errorCode !== 0) {
            var errorMsg = "get local sdp failed!!! e = " + info;
            Log.RTCLog.error(errorMsg);
            Log.uploadWebLog(global, errorMsg, null, Constants.KEY_TAG.RTC_LOG_TAG);
            $self.emitter.emit("onStartRTCResult",{
                errorCode: errorCode,
                errorMsg: errorMsg,
                srctinyid : 0
            });
            return;
        }
        global.rtcUtil.sendSdp(info, 0);
        $self.emitter.emit("onStartRTCResult",{
            errorCode: 0,
            errorMsg: "ok",
            srctinyid : 0
        });
    });
}
WebRTCAPI.fn.startPush = function(opt){
    var global = this.global
    var $self = this
    if (!this.createPeerConnection(0)) {
        Log.RTCLog.error("create peer connection failed!");
        error && error( Constants.ERROR_CODE.CREATE_PEERCONNECTION_FAILED)
        return;
    }
    if( !this.checkInit() ){
        return;
    }
    if( opt && opt.stream ){
        this.pushStream( opt.stream );
    }else{
        this.getLocalStream(opt, function (data) {
            if( global.destroy ){
                global.streamHandler.releaseLocal( stream )
            }
            $self.pushStream( data.stream )
        }, function( data ){
            var errorCode = data.errorCode;
            if (errorCode !== 0 || !data.stream) {
                var errorMsg = "get local stream failed! exception : " + data.errorMsg;
                Log.RTCLog.error(errorMsg);
                Log.uploadWebLog(global, errorMsg, null, Constants.KEY_TAG.RTC_LOG_TAG);
                global.rtcReport.send( Constants.RTC_EVENT.ON_GET_USER_MEDIA_FAILED, errorMsg);
                $self.emitter.emit("onStartRTCResult",{
                    errorCode: errorCode,
                    errorMsg: errorMsg,
                    srctinyid : 0,
                    extInfo: data.extInfo || null
                });
                return;
            }
        });
    }
}



WebRTCAPI.fn.startRTC = function( opt , succ , error) {
    var global = this.global
    var $self = this
    var srctinyid = 0;
    if( !this.checkInit() ){
        return;
    }
    opt = opt || {};
    if( opt ){
        if( opt.srctinyid ){
            srctinyid = opt.srctinyid
        }else if( opt.tinyid ){
            srctinyid = opt.tinyid
        }else if( opt.userId ){
            srctinyid = tinyIdMap[opt.userId]
        }
        //兼容现有用户的代码
        opt.role = opt.role || opt.screenRole || null;
        if( opt.role ){
            var _succ = succ ? succ : function(){};
            succ = function(){
                _succ();
                //临时办法，等后台发布后不需要setTimeout
                setTimeout(function(){
                    $self.changeSpearRole( opt.role , true)
                },1000)
            }
        }
    }
   

    if( succ ){
        $self.callbacks.startRTCSucc = succ;
    }
    if( error ){
        $self.callbacks.startRTCError = error;
    }
    if( srctinyid === 0 && global.localStreamStatus){
        console.error('请不要重复调用进房接口')
        return;
    }

    this.emitter.emit("onUserDefinedWebRTCEventNotice", { "event": Constants.USER_DEFINED_EVENT.BEGIN_START_WEBRTC} );
    Log.RTCLog.info("start webrtc : src tinyid = " + srctinyid);
    global.rtcReport.send( Constants.RTC_EVENT.ON_START_WEBRTC, {
        srctinyid : srctinyid
    });

    if (parseInt(srctinyid || 0) === 0) {
        this.startPush( opt );
    } else {
        if (!this.createPeerConnection(srctinyid)) {
            Log.RTCLog.error("create peer connection failed!");
            error && error( Constants.ERROR_CODE.CREATE_PEERCONNECTION_FAILED)
            return;
        }
        if(Constants.InternalVersion > 1000 && !opt.remoteSdp ){
            $self.emitter.emit("onStartRTCResult",{
                errorCode: Constants.ERROR_CODE.GET_ANSWER_SDP_FAILED,
                errorMsg: "get remote sdp failed!",
                srctinyid : srctinyid
            });
            return;
        }
        if( Constants.InternalVersion > 1000 ){
            global.rtcUtil.onRemoteSdp(opt.remoteSdp, srctinyid);
            global.rtcUtil.getAnswerSdp(srctinyid, function(errorCode, info) {
                if (errorCode !== 0) {
                    var errorMsg = "get remote sdp failed!!! e = " + info;
                    Log.RTCLog.error( errorMsg );
                    if( error ){
                        error({
                            errorCode: errorCode,
                            errorMsg: errorMsg,
                            srctinyid : srctinyid
                        });
                    }
                    $self.emitter.emit("onStartRTCResult",{
                        errorCode: errorCode,
                        errorMsg: errorMsg,
                        srctinyid : srctinyid
                    });
                    return;
                }
                global.rtcUtil.sendSdp(info, srctinyid);
                if( succ ){
                    succ({
                        errorCode: 0,
                        errorMsg: "ok",
                        srctinyid : srctinyid
                    });
                }
                $self.emitter.emit("onStartRTCResult",{
                    errorCode: 0,
                    errorMsg: "ok",
                    srctinyid : srctinyid
                });
            });
        }else{
            global.rtcUtil.getSdp(srctinyid, function(errorCode, info) {
                if (errorCode !== 0) {
                    var errorMsg = "get remote sdp failed!!! e = " + info;
                    Log.RTCLog.error();
                    if( error ){
                        error({
                            errorCode: errorCode,
                            errorMsg: errorMsg,
                            srctinyid : srctinyid
                        });
                    }
                    $self.emitter.emit("onStartRTCResult",{
                        errorCode: errorCode,
                        errorMsg: errorMsg,
                        srctinyid : srctinyid
                    });
                    return;
                }
                global.rtcUtil.sendSdp(info, srctinyid);
                if( succ ){
                    succ({
                        errorCode: 0,
                        errorMsg: "ok",
                        srctinyid : srctinyid
                    });
                }
                $self.emitter.emit("onStartRTCResult",{
                    errorCode: 0,
                    errorMsg: "ok",
                    srctinyid : srctinyid
                });
            });
        }
    }
};

WebRTCAPI.fn.getLocalMediaStream = function() {
    if( !this.checkInit()){
        return;
    }
    return this.global.localStream;
};

WebRTCAPI.fn.getLocalMediaStatus = function() {
    if( !this.checkInit()){
        return;
    }
    return this.global.localMediaStatus;
};
WebRTCAPI.fn.closeAudio = function() {
    if( !this.checkInit()){
        return;
    }
    return this.changeLocalMedia('audio', false);
};

WebRTCAPI.fn.closeVideo = function() {
    if( !this.checkInit()){
        return;
    }
    return this.changeLocalMedia('video', false);
};

WebRTCAPI.fn.openAudio = function() {
    if( !this.checkInit()){
        return;
    }
    return this.changeLocalMedia('audio', true);
};
WebRTCAPI.fn.openVideo = function() {
    if( !this.checkInit()){
        return;
    }
    return this.changeLocalMedia('video', true);
};

WebRTCAPI.fn.setConstraints = function( info ){
    this.updateConstraints({},info);
}

WebRTCAPI.fn.updateConstraints = function(videoCtrlAbility , ext) {
    var global = this.global

    if (videoCtrlAbility) {
        Log.RTCLog.info("videoCtrlAbility.length=" + videoCtrlAbility.length);
        if (videoCtrlAbility.length > 0) {
            var VidWidth =  (ext && ext.VidWidth) ||  videoCtrlAbility[0].VidWidth;
            var VidHeight = (ext && ext && ext.VidHeight) || videoCtrlAbility[0].VidHeight;
            var VidFr = (ext && ext && ext.VidFr) || videoCtrlAbility[0].VidFr;
            var CpuOverUseDetect = videoCtrlAbility[0].CpuOverUseDetect;
            var VidRatio = VidWidth/VidHeight;
            if( Constants.ConstraintsMode === 1 ){
                if (VidWidth > 0 && VidHeight > 0 && VidFr > 0) {
                    global.constraints = {
                        "audio": global.constraints.audio,
                        "video": _.extend(global.constraints.video,{                        
                            // frameRate : {exact: VidFr}
                            // ,googCpuOveruseDetection : false
                            // ,height : {exact: VidHeight}
                            // ,width : {exact: VidWidth} 
                        })
                    };
                }
            }else{
                var mandatory = {
                    minAspectRatio: VidRatio,
                    maxAspectRatio: VidRatio ,
                    maxWidth: VidWidth,
                    minWidth: VidWidth,
                    maxFrameRate:VidFr,
                    minFrameRate:VidFr,
                    googCpuOveruseDetection:CpuOverUseDetect ? true : false
                };
                if( global.constraints.video.mandatory ){
                    _.extend(global.constraints.video.mandatory,mandatory)
                }else if( global.constraints.video === true ){
                    global.constraints.video = {mandatory:mandatory}
                }
            }
        }
    }
    if( ext && ext.audio && ext.audio.deviceId ){
        // global.constraints.audio.deviceId = ext.audio.deviceId
        var exact = { exact: ext.audio.deviceId}
        if( typeof global.constraints.audio === 'object' ){
            global.constraints.audio.deviceId = exact;
        }else{
            global.constraints.audio = {
                deviceId : exact
            }
        }
    }
    if( ext && ext.video && ext.video.deviceId){
        if( Constants.ConstraintsMode === 1){
            if( typeof global.constraints.video === 'object' ){
                global.constraints.video.deviceId =  { exact: ext.video.deviceId};
            }else{
                global.constraints.video = {
                    deviceId:  { exact: ext.video.deviceId}
                }
            }
        }else{
            if( typeof global.constraints.video === 'object' && global.constraints.video.mandatory){
                global.constraints.video.mandatory.sourceId =  ext.video.deviceId;
            }else{
                global.constraints.video = {
                    mandatory: {
                        sourceId : ext.video.deviceId
                    }
                }
            }
        }
    }
    return global.constraints;
};

WebRTCAPI.fn.quit = function(succ , error) {
    try{
        var global = this.global;
        if (global.reportSto) {
            clearInterval(global.reportSto);
        }
        global.reportSto = null;
        global.preReportData = null;
        global.localStreamStatus = false;
        global.destroy = true;

        global.rtcReport.endEndReport(0);
        global.streamHandler.releaseLocal();
        if (global.peerConnections) {
            for (var key in global.peerConnections) {
                var item = global.peerConnections[key];
                if (item) {
                    if (item.signalingState !== 'closed') {
                        item.close();
                    }
                    item = null;
                }
            }
            global.peerConnections = {};
        }

        if (global.websocket) {
            global.websocket.close();
            global.websocket = null;
        }
        global.rtcUtil.clearGlobalValues( );
        
        if( succ ) { succ(); }
    }catch(e){
        if( error ) { error(); }
    }
};

WebRTCAPI.fn.changeSpearRole = function(role , manualUpdateRole) {
    var global = this.global;
    global.manualUpdateRole = manualUpdateRole || false;
    global.rtcReport.send( Constants.RTC_EVENT.ON_SPEAR_ROLE_CHANGE , {role:role});
};

WebRTCAPI.fn.getUserId = WebRTCAPI.fn.getOpenId = function(tinyid){
    var global = this.global;
    return global.openIdMap[tinyid] || null;
};


WebRTCAPI.fn.ping = function(times, callback){
    return new PingUtil(times, callback)
};

WebRTCAPI.fn.wsreconnect = function (sig) {
    var global = this.global
    // if (CURRENT_SERVER_TYPE === SERVER_TYPE.FOR_OPEN) {
    //     //这个接口只给edu开放
    //     Log.RTCLog.errorMsg("[WSRECONNECT]this interface can only use by edu");
    //     return false;
    // }
    if (!sig) {
        return false;
    }
    if (!global.websocket) {
        return false;
    }
    global.websocket.reconnect(sig);
    return true;
};

WebRTCAPI.fn.getMaxTimeMs = function(callback){
    Log.RTCLog.debug("request maximun timestamp");
    global.rtcReport.send( Constants.RTC_EVENT.ON_GET_MAX_TIMEMS , {role:role});
    onGetMaxTimeMs = callback
};



WebRTCAPI.fn.createDataChannel = function(){
    Log.RTCLog.debug('createDataChannel');
    var global = this.global
    var dcSrcTinyid = "1";
    this.createPeerConnection(dcSrcTinyid);
    var peerConnection = global.peerConnections[dcSrcTinyid];
    peerConnection.ondatachannel = function(event) {
        Log.RTCLog.info("ondatachannel: " + event);
    };

    Log.RTCLog.info("createDataChannel MyDataChannel");
    var dataChannel = peerConnection.createDataChannel('MyDataChannel',{reliable: false});

    dataChannel.onmessage = function (event) {
        Log.RTCLog.info("dataChannel received: " + event.data);
    };

    dataChannel.onopen = function () {
        Log.RTCLog.info("datachannel open");
    };

    dataChannel.onclose = function () {
        Log.RTCLog.info("datachannel close");
    };
    dataChannel.onerror = function () {
        Log.RTCLog.info("datachannel onerror");
    };

    peerConnection.dataChannel = dataChannel;

    //get sdp and send sdp
    var offerOption = global.offerSdpOption;
    peerConnection.createOffer(offerOption).then(function(offer) {
        peerConnection.setLocalDescription(offer);
    }).then(function() {
        var desc = peerConnection.localDescription;
        Log.RTCLog.info("dcPeerConnection get local sdp info : " + desc.sdp);
        var sendData = global.rtcReport.createJsonFromTag( Constants.RTC_EVENT.ON_PEER_SDP );
        sendData.roomid = global.roomid;
        sendData.usersig = global.config.userSig;
        sendData.sdkappid = global.config.sdkAppId;
        sendData.relayip = global.relayip;
        sendData.data = desc;
        sendData.srctinyid = dcSrcTinyid;
        global.websocket.send(JSON.stringify(sendData));
        //callback(0, desc);
    }).catch(function(reason) {
        Log.RTCLog.error("dcPeerConnection create offer failed : reason = " + reason);
        //callback(-10009, reason);
    });

    return true;
};


WebRTCAPI.fn.recreateDataChannel = function() {
    var global = this.global
    var dcSrcTinyid = "1";

    if (global.peerConnections[dcSrcTinyid] && global.peerConnections[dcSrcTinyid].signalingState !== 'closed')
    {
        global.peerConnections[dcSrcTinyid].close();
    }
    delete global.peerConnections[dcSrcTinyid];
    global.peerConnections[dcSrcTinyid] = null;

    this.createDataChannel();
};



WebRTCAPI.fn.sendDCData = function(data) {
    var global = this.global
    var dcSrcTinyid = "1";
    var peer = global.peerConnections[dcSrcTinyid];
    if(peer){
        peer.dataChannel.send(data);
    }
};




WebRTCAPI.fn.onChangeConstraints = function(newConstraints, isChangeAudio, isChangeVideo) {
    var global = this.global
    var emitter = this.emitter;
    Log.RTCLog.info("on change constraints newConstraints: " + JSON.stringify(newConstraints) );
    var srctinyid = 0;
    global.rtcUtil.updateLocalStream(newConstraints, isChangeAudio, isChangeVideo, function(errorCode, media) {
      if(errorCode === 0) { // 没有异常
        
        isChangeVideo && media.getVideoTracks().forEach(function(videoTrack) {
            var constraints = videoTrack.getConstraints();
            for(var key in constraints)
            {
                for(var subkey in constraints[key])
                {
                    Log.RTCLog.info("new key:" + key + "|" + subkey + " value:" + constraints[key][subkey]);
                }
            }
        });

        isChangeAudio && media.getAudioTracks().forEach(function(audioTrack) {
            var constraints = audioTrack.getConstraints();
            for(var key in constraints)
            {
                for(var subkey in constraints[key])
                {
                    Log.RTCLog.info("new key:" + key + "|" + subkey + " value:" + constraints[key][subkey]);
                }
            }
        });
      }

      emitter.emit('onLocalStreamAdd',{
          stream : global.localStream
      });

      global.rtcUtil.getSdp(srctinyid, function(errorCode, info) {
          if (errorCode !== 0) {
              Log.RTCLog.error("get local sdp failed!!! e = " + info);
              callback(errorCode);
              return;
          }
          Log.RTCLog.info("get new local sdp success!" );
          global.rtcUtil.sendUpdateSdp(info, srctinyid);
      });
    });
  };


// 获取音频设备
WebRTCAPI.fn.getDevices = function(callback) {
    navigator.mediaDevices.enumerateDevices()
    .then(function(devices) {
      var videoList = {}, audioList = {};
      devices.forEach(function(device) {
        if (device && device.kind === "audioinput" ) {
            audioList[device.deviceId] = device;
        }
        if (device && device.kind === "videoinput" ) {
            videoList[device.deviceId] = device;
        }
      });

      // 按摄像头优先考虑，将既是摄像头又是麦克风的设备，当作摄像头
      for(var p in videoList) {
        if(audioList[p]) {
          delete audioList[p];
        }
      }

      if( callback){
        callback({
            audio: Object.values(audioList),
            video: Object.values(videoList)
        });
        }
    })
    .catch(function(err) {
        callback(err);
    });
};

WebRTCAPI.fn.getVideoDevices = function(callback) {
    navigator.mediaDevices.enumerateDevices()
    .then(function(devices) {
        var videoList = []
        devices.forEach(function(device) {
            if (device && device.kind === "videoinput" ) {
                videoList.push( device )
            }
        });
        if( callback){
            callback( videoList );
        }
    })
    .catch(function(err) {
        callback(err)
    });
};

WebRTCAPI.fn.chooseVideoDevice = function( video ) {
    var global = this.global;
    var emitter = this.emitter;
    var srctinyid = 0;
    global.config.videoActive = true;
    
    if( global.localStream ){
        global.localStream.getTracks().forEach(function(track){
            track.stop();
        });
    }

    
    if( Constants.ConstraintsMode === 1){
        if( typeof global.constraints.video === 'object' ){
            global.constraints.video.deviceId =  { exact: video.deviceId};
        }else{
            global.constraints.video = {
                deviceId:  { exact: video.deviceId}
            }
        }
    }else{
        if( typeof global.constraints.video === 'object' && global.constraints.video.mandatory){
            global.constraints.video.mandatory.sourceId =  video.deviceId;
        }else{
            global.constraints.video = {
                mandatory: {
                    sourceId : video.deviceId
                }
            }
        }
    }

    if( !global.enteredRoom ){
        return
    }
    global.mediaUtil.gum({ constraints: global.constraints}, function( data ){
        var stream = data.stream;
        global.streamHandler.addLocal( global.peerConnections[0], stream);
        emitter.emit('onLocalStreamAdd',{
            stream : global.localStream
        });
        global.rtcUtil.getSdp(srctinyid, function(errorCode, info) {
            if (errorCode !== 0) {
                Log.RTCLog.error("get local sdp failed!!! e = " + info);
                callback(errorCode);
                return;
            }
            Log.RTCLog.info("get new local sdp success!" );
            global.rtcUtil.sendUpdateSdp(info, srctinyid);
        });
    },function(e){
        e.errorMsg = "get local stream failed! exception : " + e.errorMsg;
        emitter.emit("onErrorNotify",e)
    });
};

// 获取音频设备
WebRTCAPI.fn.getAudioDevices = function(callback) {
    navigator.mediaDevices.enumerateDevices()
    .then(function(devices) {
      var videoList = {}, audioList = {};
      devices.forEach(function(device) {
        if (device && device.kind === "audioinput" ) {
            audioList[device.deviceId] = device;
        }
        if (device && device.kind === "videoinput" ) {
            videoList[device.deviceId] = device;
        }
      });

      // 按摄像头优先考虑，将既是摄像头又是麦克风的设备，当作摄像头
      for(var p in videoList) {
        if(audioList[p]) {
          delete audioList[p];
        }
      }

      if( callback){
          callback( Object.values(audioList));
      }
    })
    .catch(function(err) {
        callback(err)
    });
};


// 获取音频输出设备
WebRTCAPI.fn.getSpeakerDevices = function(callback) {
    navigator.mediaDevices.enumerateDevices()
    .then(function(devices) {
      var videoList = {}, audioList = {};
      devices.forEach(function(device) {
        if (device && device.kind === "audiooutput" ) {
            audioList[device.deviceId] = device;
        }
      });
      if( callback){
          callback( Object.values(audioList));
      }
    })
    .catch(function(err) {
        callback(err)
    });
};

WebRTCAPI.fn.chooseAudioDevice = function( audio ) {
    var global = this.global;
    var emitter = this.emitter;
    var srctinyid = 0;
    global.config.audioActive = true;
    
    var exact = { exact: audio.deviceId}
    if( typeof global.constraints.audio === 'object' ){
        global.constraints.audio.deviceId = exact;
    }else{
        global.constraints.audio = {
            deviceId : exact
        }
    }
    // var vidConstraints = {"audio" : global.constraints.audio};
    // this.onChangeConstraints(vidConstraints, true, false);

    if( !global.enteredRoom ){
        return
    }

    this.onChangeConstraints( { video:false, audio: global.constraints.audio}, true, false );
};


WebRTCAPI.fn.chooseSpeakerDevice = function( mediaElement, speaker , succ,  fail ) {
    if (typeof mediaElement.sinkId !== 'undefined') {
        mediaElement.setSinkId( speaker.deviceId )
        .then(() => {
            succ && succ({
                errorCode: 0,
                errorMsg: "ok"
            });
        })
        .catch(error => {
            let errorMessage = error;
            if (error.name === 'SecurityError') {
                errorMessage = `You need to use HTTPS for selecting audio output device: ${error}`;
            }
            fail && fail({
                errorCode: Constants.ERROR_CODE.CHOOSE_SPEARK_FAILED,
                errorMsg: errorMessage
            });
        });
    } else {
        fail && fail({
            errorCode: Constants.ERROR_CODE.CHOOSE_SPEARK_FAILED,
            errorMsg: "media element has no sinkId"
        });
    }
};

WebRTCAPI.fn.stopRTC = function( opt , succ , error ) {
    var global = this.global
    var srctinyid =  0
    global.config.canvas = false;
    if( succ ){
        this.callbacks.stopRTCSucc = succ;
    }
    if( error ){
        this.callbacks.stopRTCError = error;
    }
    if( opt && opt.userId ){
        srctinyid = this.global.tinyIdMap[opt.userId]
        if( !srctinyid ) {
            this.emitter.emit("execCallback",{
                name:"stopRTCError",
                data: {
                    errorCode: Constants.ERROR_CODE.NOT_FOUND,
                    errorMsg: "没有找到对应的tinyid"
                }
            });
            return;
        }
    }
    if( srctinyid === 0){
        if (global.websocket) {        
            global.rtcReport.send( Constants.RTC_EVENT.ON_CLOSE_PEER);
        }
    }else{
        this.emitter.emit('onPeerConnectionClose',{
            srctinyid: srctinyid 
        });
    }
};

WebRTCAPI.fn.detectRTC = function( opts, callback ){
    return DetectRTC.support(opts,  callback );
}

WebRTCAPI.fn.debug = function( mode ){
    Log.debug( mode )
}


WebRTCAPI.fn.version = function( mode ){
    return Constants.Version;
}

WebRTCAPI.fn.getStats = function ( opts , succ , error) {
    var global = this.global
    var self = this
    var tinyId = 0;
    if( opts.userId ){
        tinyId = global.tinyIdMap[opts.userId];
    }
    var interval = opts.interval || null;
    if( global.peerConnections[tinyId] ){
        global.peerConnections[tinyId].getPeerStats( function( data ){
            succ( global.streamHandler.parseStats( data) )
        }, interval);
    }else{
        if( global.retryGetStats[tinyId] ){
            error && error({
                errorCode: Constants.ERROR_CODE.NOT_FOUND_PEER,
                errorMsg: 'not exist peerconnection with opts' + JSON.stringify(opts)
            });
            delete global.retryGetStats[tinyId];
        }else{
            global.retryGetStats[tinyId] = 1;
            //2秒后重试
            setTimeout( function(){
                self.getStats( opts, succ , error)
            },2000)
        }
    }
}

WebRTCAPI.fn.getErrorCode = function(){
    return Constants.ERROR_CODE;
}

WebRTCAPI.fn.updateStream = function( opts , succ , fail ){
    var global = this.global;
    var that = this;
    if( !opts.stream && typeof opts.stream != 'MediaStream'){
        console.error( 'stream 为必须参数，且类型为MediaStream ')
        return;
    }
    global.rtcUtil.updateStream( opts.stream, function(){
        if( opts.role ){
            that.changeSpearRole( opts.role  , true)
        }
        succ && succ();
    } , fail )
}

// WebRTCAPI.fn.applyConstraints = function(){
//     var support = navigator.mediaDevices.getSupportedConstraints();
//     console.debug(support)
//     return Log.debugout;
// }


WebRTCAPI.fn.bugout = function(){
    return Log.debugout;
}




WebRTCAPI.SoundMeter = function( opts ){
    return new SoundMeter( opts )
}


// sugar
WebRTCAPI.detectRTC = WebRTCAPI.fn.detectRTC
WebRTCAPI.debug = WebRTCAPI.fn.debug
WebRTCAPI.version = WebRTCAPI.fn.version



Emitter.mixin(WebRTCAPI);

window.WebRTCAPI = WebRTCAPI
module.exports = WebRTCAPI


/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(0)))

/***/ }),
/* 34 */
/***/ (function(module, exports) {



var WebRTCStat = {
    Info: {
        MediaList: [],
        Video: null
    },
    DataEnum: {
        terminal_type: ["mobile", "iphone", "ipad", "andriod phone", "pc", "windows pad ", "windows phone ", "android pad", "voip", "mac", "pstn"]
    },
    getTerminalType: function() {
        var keystring = "";
        var index = "";
        var agent = navigator.userAgent.toLowerCase();
        if (agent.indexOf("iphone")!== -1) {
            keystring = "iphone";
        } else if (agent.indexOf("android")!== -1) {
            keystring = "andriod phone";
        } else if (agent.indexOf("ipad")!== -1) {
            keystring = "ipad";
        } else if (agent.indexOf("macintosh")!== -1) {
            keystring = "mac"
        } else if (agent.indexOf("windows")!== -1) {
            keystring = "pc"
        } else {
            keystring = "pc"
        }
        this.DataEnum.terminal_type.forEach(function(item, idx) {
            if (item.toLowerCase().indexOf(keystring) !== -1) {
                index = idx + 1;
            }
        });
        return String(index);
    },
    //视频源类型
    // 1：摄像头
    // 2：播片
    // 3：捕捉屏幕
    // 4：android
    // 5：iPad
    // 6：iPhone
    getVideoSrcType: function() {
        var type = 1;
        var termType = parseInt(this.getTerminalType());
        var deviceName = this.DataEnum.terminal_type[termType - 1];
        if (deviceName === "andriod phone") {
            type = 4;
        } else if (deviceName === "ipad") {
            type = 5;
        } else if (deviceName === "iphone") {
            type = 6;
        }
        return type;
    },

    getDeviceInfo: function() {
        var self = this;
        navigator.mediaDevices.enumerateDevices()
            .then(function(devices) {
                devices.forEach(function(device) {
                    if (device.kind === "videoinput" && !self.Info.Video) {
                        self.Info.Video = {
                            kind: device.kind,
                            label: device.label,
                            id: device.deviceId
                        };
                    }
                });
            })
            .catch(function(err) {
                console.log(err.name + ": " + err.message);
            });
    },
    getExplore: function () {
        var Sys = {};
        var ua = navigator.userAgent.toLowerCase();
        var s;
        (s = ua.match(/rv:([\d.]+)\) like gecko/)) ? Sys.ie = s[1] :
            (s = ua.match(/msie ([\d\.]+)/)) ? Sys.ie = s[1] :
                (s = ua.match(/edge\/([\d\.]+)/)) ? Sys.edge = s[1] :
                    (s = ua.match(/firefox\/([\d\.]+)/)) ? Sys.firefox = s[1] :
                        (s = ua.match(/(?:opera|opr).([\d\.]+)/)) ? Sys.opera = s[1] :
                            (s = ua.match(/chrome\/([\d\.]+)/)) ? Sys.chrome = s[1] :
                                (s = ua.match(/version\/([\d\.]+).*safari/)) ? Sys.safari = s[1] : 0;

        if (Sys.ie){return ('IE: ' + Sys.ie);}
        if (Sys.edge){return ('EDGE: ' + Sys.edge);}
        if (Sys.firefox){return ('Firefox: ' + Sys.firefox);}
        if (Sys.chrome){return ('Chrome: ' + Sys.chrome);}
        if (Sys.opera){return ('Opera: ' + Sys.opera);}
        if (Sys.safari){return ('Safari: ' + Sys.safari);}
        return 'Unkonwn';
    },
    ability: function(constraints) {
        var connectionType = 0;
        if (navigator && navigator.connection && navigator.connection.type) {
            if (navigator.connection.type === "wifi") {
                connectionType = 1;
            } else if (navigator.connection.type === "cellular") {
                connectionType = 4;
            }
        }
        var cpuMaxFrequency = 0;
        if (navigator && navigator.cpuMaxFrequency) {
            cpuMaxFrequency = navigator.cpuMaxFrequency;
        }
        var totalMemory = 0;
        if (navigator && navigator.totalMemory) {
            totalMemory = navigator.totalMemory;
        }
        var cpuModelName = "";
        if (navigator && navigator.cpuModelName) {
            cpuModelName =  navigator.cpuModelName;
        }
        var pindex = parseInt(this.getTerminalType());
        var platform = this.DataEnum.terminal_type[pindex - 1];
        var versionDetail = "";
        try {
            versionDetail = this.getExplore();
        } catch (e) {

        }
        return {
            AbilityOption: {
                GeneralLimit: {
                    CPULimit: {
                        uint32_CPU_num: String(navigator.hardwareConcurrency || 0), //CPU核心数   ok
                        str_CPU_name : String(navigator.platform),
                        uint32_CPU_maxfreq : String(cpuMaxFrequency),
                        model : cpuModelName,
                        uint32_total_memory : String(totalMemory)
                    },
                    uint32_terminal_type: WebRTCStat.getTerminalType(), //终端类型，使用enum TERMINAL_TYPE
                    uint32_device_type: String(0), //机型、设备类型(比如iphone4、iphone5s)，只针对移动终端，pc不用填写
                    str_os_verion: platform, //操作系统类型、版本
                    uint32_link_type: String(1), //客户端接口机连接类型，1表示UDP，2表示TCP，0未知（旧版本没有上报此字段）
                    str_client_version: String(WebRTCAPI.version || "0"),
                    uint32_net_type : String(connectionType),
                    ua : navigator.userAgent,
                    version : versionDetail
                },
                VideoLimit: {
                    CameraLimit: {
                        str_camera_auth_name: WebRTCStat.Info.Video && WebRTCStat.Info.Video.label,
                        uint32_video_src_type: WebRTCStat.getVideoSrcType()

                    },
                    uint32_screen_width: String(window.screen.width), //屏幕宽
                    uint32_screen_height: String(window.screen.height) //屏幕高
                },
                SpeciParam: {
                    SpeciVidParam : {
                        uint32_spcivid_proto: String(3), //角色类型
                        uint32_spcivid_width: String(640),
                        uint32_spcivid_height: String(368),
                        uint32_spcivid_fps : String(20)
                    },
                    SpeciAudParam : {
                        uint32_spciaud_fs : String(48000),
                        uint32_spciaud_ch: String(2)
                    }
                }
            }
        };
    },
    isSupport : function () {
        var isWebRTCSupported = false;
        ['RTCPeerConnection', 'webkitRTCPeerConnection', 'mozRTCPeerConnection', 'RTCIceGatherer'].forEach(function(item) {
            if (isWebRTCSupported) {
                return;
            }

            if (item in window) {
                isWebRTCSupported = true;
            }
        });
        return isWebRTCSupported;
    },
    init: function() {
        if (this.isSupport()) {
            this.getDeviceInfo();
        }
    }
};

module.exports = WebRTCStat

/***/ }),
/* 35 */
/***/ (function(module, exports, __webpack_require__) {

var Constants = __webpack_require__(1)
var PingUtil = function(times , callback){
    var Count = 0;
    var CountTimes = times;
    var Res = [];
    var Ping = function(opt) {
        this.opt = opt || {};
        this.favicon = this.opt.favicon || "/favicon.ico";
        this.timeout = this.opt.timeout || 0;
    };
    Ping.prototype.ping = function(source, callback) {
        this.img = new Image();
        var timer;
        var start = new Date();
        this.img.onload = pingCheck;
        this.img.onerror = pingCheck;
        if (this.timeout) { timer = setTimeout(pingCheck, this.timeout); }
        function pingCheck(e) {
            if (timer) { clearTimeout(timer); }
            var pong = new Date() - start;

            if (typeof callback === "function") {
                if (e.type === "error") {
                    console.error("error loading resource");
                    return callback("error", pong);
                }
                return callback(null, pong);
            }
        }
        this.img.src = source + this.favicon + "?" + (+new Date()); // Trigger image load with cache
    };

    function doPing() {
        if( Count < CountTimes ) {
            Count ++ ;
            var p = new Ping();
            p.ping("https://"+Constants.HOST_NAME+":8687", function(err, data) {
                Res.push(data);
                doPing();
            });
        }else {
            if( Res.length == Count ){
                var ret = 0;
                for(var i = 0; i < Res.length; i++){
                    ret += Res[i];
                }
                callback( parseInt(ret / Res.length), Res );
            }else{
                setTimeout(doPing,100)
            }
        }
    }
    doPing();
};

module.exports = PingUtil;

/***/ }),
/* 36 */
/***/ (function(module, exports, __webpack_require__) {

var Log = __webpack_require__(3);
var Util = __webpack_require__(4);
var Constants = __webpack_require__(1);
var DetectRTC = __webpack_require__(9);
var RTCUtil = function (global, emitter) {
  this.global = global;
  this.emitter = emitter;
}
RTCUtil.fn = RTCUtil.prototype;

RTCUtil.fn.isSupportH264 = function (sdp) {
    var supportH264 = false;
    try {
      var sdpList = sdp.split("\r\n");
      for (var i = 0; i < sdpList.length; i++) {
        var sdpStr = sdpList[i];
        if (
          sdpStr.indexOf("a=rtpmap") !== -1 &&
          (sdpStr.indexOf("H264/") !== -1 || sdpStr.indexOf("h264/") !== -1)
        ) {
          supportH264 = true;
          break;
        }
      }
    } catch (e) {
      console.log(e);
    }
    return supportH264;
  },
  RTCUtil.fn.getIceCandidateType = function (candidate) {
    try {
      var str = candidate.candidate;
      var params = str.split(" ");
      return params[7];
    } catch (e) {
      // Log.RTCLog.error("Get Ice Candidate Type Error : e = " + e);
      return null;
    }
  },

  RTCUtil.fn.getSdp = function (srctinyid, callback) {
    var global = this.global
    var emitter = this.emitter
    var self = this
    if (!srctinyid) {
      srctinyid = 0;
    }

    var peerConnection = global.peerConnections[srctinyid];
    if (!peerConnection) {
      return;
    }
    var createOffer = peerConnection.tempCreateOffer || peerConnection.createOffer(global.offerSdpOption);
    createOffer.then(function (offer) {
        if (self.isSupportH264(offer.sdp)) {
          return peerConnection.setLocalDescription(offer);
        } else {
          emitter.emit('onIceConnectionBuild', {
            result: false,
            state: Constants.ICE_BUILD_STATE.SDP_FAILED
          });
          var errorStr = "this web browser do not support h264. srctinyid = " + srctinyid;
          Log.RTCLog.error(errorStr);
          Log.uploadWebLog(global, errorStr, null, Constants.KEY_TAG.SDP_TAG);

          global.rtcReport.send(Constants.RTC_EVENT.ON_NOT_SUPPORT_H264);
          callback(Constants.ERROR_CODE.GET_LOCALSDP_FAILED, errorStr);
        }
      })
      .then(function (e) {
        emitter.emit("onUserDefinedWebRTCEventNotice", {
          "event": Constants.USER_DEFINED_EVENT.GET_LOCAL_SDP_SUC,
          info: e
        });
        var desc = peerConnection.localDescription;
        // Log.RTCLog.info("get local sdp info : " + desc.sdp);
        callback(Constants.ERROR_CODE.SUCC, desc);
      })
      .catch(function (reason) {
        Log.RTCLog.error("create offer failed : reason = " + reason);
        callback(Constants.ERROR_CODE.GET_LOCALSDP_FAILED, reason);
      });
  };

RTCUtil.fn.updateRemoteSdp = function (srctinyid, newSdp) {
  var global = this.global
  var emitter = this.emitter

  if (parseInt(srctinyid || 0) == 0) {
    var errorMsg = "Receive update remote sdp, but srctinyid = 0!!!";
    Log.uploadWebLog(global, errorMsg, null, "UPDATE_REMOTE_SDP");
    return;
  }
  var peerConnection = global.peerConnections[srctinyid];

  if (!peerConnection) {
    var errorMsg =
      "onUpdateRemoteSdp, failed to get peerconnection. srctinyid = " +
      srctinyid;
    Log.RTCLog.error(errorMsg);
    Log.uploadWebLog(global, errorMsg, null, "UPDATE_REMOTE_SDP");
    emitter.emit("onUserDefinedWebRTCEventNotice", {
      "event": Constants.USER_DEFINED_EVENT.SET_REMOTE_SDP_FAILED,
      info: errorMsg
    });
    return;
  }

  Log.RTCLog.info(
    "onUpdateRemoteSdp peerConnection.localDescription:" +
    peerConnection.localDescription.sdp +
    "\r\n" +
    peerConnection.localDescription.type
  );
  Log.RTCLog.info(
    "onUpdateRemoteSdp peerConnection.remoteDescription:" +
    peerConnection.remoteDescription.sdp +
    "\r\n" +
    peerConnection.remoteDescription.type
  );
  Log.RTCLog.info(
    "onUpdateRemoteSdp new sdp :" + newSdp.sdp + "\r\n" + newSdp.type
  );


  if (Constants.InternalVersion < 1001) {
    newSdp.type = "pranswer";
  }
  peerConnection.setRemoteDescription(
    new RTCSessionDescription(newSdp),
    function () {
      if (srctinyid != 0) {
        global.websocket.sessioninfo.peersdp[srctinyid + ""] = newSdp.sdp;
      }
      Log.RTCLog.info("onUpdateRemoteSdp setRemoteDescription success!");
    },
    function () {
      Log.RTCLog.info("onUpdateRemoteSdp setRemoteDescription failed!");
    }
  );
};

RTCUtil.fn.onSubVideoState = function (data) {
  var global = this.global
  var emitter = this.emitter
  Log.RTCLog.info("onSubVideoState");
  if (parseInt(data.srctinyid || 0) == 0) return;

  /*加入主辅路判断逻辑*/
  var videoState = data.state;
  var localSubVidSsrc = parseInt(data.localSubVidSsrc);
  var streamType = (localSubVidSsrc >> 16) & 0xff;
  var videoId;
  if (streamType === Constants.STREAM_TYPE.MAIN) {
    videoId = data.srctinyid + "_" + Constants.STREAM_MISD.MAIN;
  } else {
    videoId = data.srctinyid + "_" + Constants.STREAM_MISD.AID;
  }
  var checkResult = {
    type: streamType,
    state: videoState,
    videoId: videoId
  };
  emitter.emit("onRemoteStreamStateChange", checkResult);

  /*主辅路判断逻辑结束*/
  var peerConnection = global.peerConnections[data.srctinyid];
  if (!peerConnection) {
    global.remoteSdps[data.srctinyid] = data.newSdp;
    return;
  }
  // 
  // data.newSdp.type = "pranswer";
  if (Constants.InternalVersion < 1001) {
    data.newSdp.type = "pranswer";
  }

  this.updateRemoteSdp(data.srctinyid, data.newSdp);
};

RTCUtil.fn.onUpdateAudSsrc = function (data) {
  var global = this.global
  var emitter = this.emitter
  Log.RTCLog.info("onUpdateAudSsrc");

  if (parseInt(data.srctinyid || 0) == 0) return;

  var peerConnection = global.peerConnections[data.srctinyid];

  if (!peerConnection) {
    var errorMsg =
      "onUpdateAudSsrc, failed to get peerconnection. srctinyid = " +
      srctinyid;
    emitter.emit("onErrorNotify", {
      errorCode: Constants.ERROR_CODE.UPDATE_AUDIO_SSRC_FAILED,
      errorMsg: errorMsg
    })
    return;
  }
  if (Constants.InternalVersion < 1001) {
    data.newSdp.type = "pranswer";
  }
  this.updateRemoteSdp(data.srctinyid, data.newSdp);
};

RTCUtil.fn.onUpdateVideoSsrc = function (data) {
  var global = this.global
  var emitter = this.emitter
  Log.RTCLog.info("onUpdateVideoSsrc:\r\n " + JSON.stringify(data));

  if (parseInt(data.srctinyid || 0) == 0) return;

  var peerConnection = global.peerConnections[data.srctinyid];

  if (!peerConnection) {
    var errorMsg = "onUpdateVideoSsrc, failed to get peerconnection. srctinyid = " + data.srctinyid;
    emitter.emit("onErrorNotify", {
      errorCode: Constants.ERROR_CODE.UPDATE_VIDEO_SSRC_FAILED,
      errorMsg: errorMsg
    })
    return;
  }
  if (Constants.InternalVersion < 1001) {
    data.newSdp.type = "pranswer";
  }
  this.updateRemoteSdp(data.srctinyid, data.newSdp);
};

RTCUtil.fn.rebuildSession = function () {
  var global = this.global
  try {
    console.log(
      "begin rebuild session!!!  size = " +
      global.websocket.sessioninfo.srcids.length
    );
    var sendData = global.rtcReport.createJsonFromTag(
      Constants.RTC_EVENT.ON_REBUILD_SESSION
    );
    sendData.data = {
      socketid: global.websocket.socketid,
      tinyid: global.websocket.sessioninfo.tinyid,
      appid: global.config.sdkAppId,
      openid: global.websocket.sessioninfo.openid,
      sessionid: global.websocket.sessioninfo.sessionid,
      sids: global.websocket.sessioninfo.srcids,
      relayInfo: global.websocket.relayInfo.innerip,
      remotesdp: global.websocket.sessioninfo.peersdp
    };
    global.websocket.send(JSON.stringify(sendData));
    return true;
  } catch (e) {
    console.error("rebuild session exception : ", e);
    return false;
  }
};
RTCUtil.fn.pickCandidate = function (pc, srctinyid) {
  if (pc.localCandidateList.length === 0) {
    return false;
  }

  var nice_choice = null;
  var backup_choice = null;
  pc.localCandidateList.forEach(function (item) {
    if (item.protocol.toLowerCase() === 'udp') {
      if (item.type.toLowerCase() === 'srflx') {
        nice_choice = {
          sdpMLineIndex: item.sdpMLineIndex,
          sdpMid: item.sdpMid,
          candidate: item.candidate
        };
      } else if (item.type.toLowerCase() === 'host' && !Util.isInnerIPFn(item.ip)) {
        backup_choice = {
          sdpMLineIndex: item.sdpMLineIndex,
          sdpMid: item.sdpMid,
          candidate: item.candidate
        };
      }
    }
  })
  return nice_choice || backup_choice || null;
}


RTCUtil.fn.onIceCandidate = function (e, srctinyid) {
  var global = this.global
  var pc = global.peerConnections[srctinyid];
  var candidate = e.candidate;
  if (!candidate) {
    Log.RTCLog.debug("Ice Candidate End!");
    this.sendLocalCandidate(pc, srctinyid);
    return;
  }
  Log.RTCLog.info("on ice candidate : sdpMLineIndex = " + candidate.sdpMLineIndex + " , sdpMid = " + candidate.sdpMid + " , candidate = " + candidate.candidate);
  if (candidate && candidate.candidate) {
    pc.localCandidateList.push(candidate);
  }
};

RTCUtil.fn.sendSdp = function (sdp, srctinyid) {
  var global = this.global
  var sendData = global.rtcReport.createJsonFromTag(Constants.RTC_EVENT.ON_PEER_SDP);
  sendData.data = sdp;
  sendData.srctinyid = srctinyid;
  global.websocket.send(JSON.stringify(sendData));
};

RTCUtil.fn.sendUpdateSdp = function (sdp, srctinyid) {
  var global = this.global
  var sendData = global.rtcReport.createJsonFromTag(
    Constants.RTC_EVENT.ON_UPDATE_PEER_SDP
  );
  sendData.data = sdp;
  sendData.srctinyid = srctinyid;
  global.websocket.send(JSON.stringify(sendData));
};

RTCUtil.fn.onAddTrack = function (stream, type, srctinyid) {
  var global = this.global
  Log.RTCLog.info(
    "onAddTrack, srctinyid:" +
    srctinyid +
    "stream.getVideoTracks().length=" +
    stream.getVideoTracks().length +
    "stream.getAudioTracks().length=" +
    stream.getAudioTracks().length
  );

  if (srctinyid != "0") {
    var peerConnection = global.peerConnections[srctinyid];
    if (peerConnection) {
      /*加入主辅路解析逻辑*/
      var sdp = peerConnection.remoteDescription.sdp;
      var splitAudio = sdp.split("a=mid:audio");
      var videoAndAudioArray;
      if (splitAudio.length > 1) {
        //不存在没有audio也没有video的情况
        videoAndAudioArray = splitAudio[1].split("a=mid:video"); //有audio过来，这时候再解析video
      } else {
        videoAndAudioArray = splitAudio[0].split("a=mid:video"); //没有audio，直接解析video
      }

      var audioArray = [];
      var videoArray = [];
      for (var i = 0; i < videoAndAudioArray.length; i++) {
        var strArray = videoAndAudioArray[i].split("\r\n");
        var count = strArray.length;
        var ssrc;
        for (var j = 0; j < count; j++) {
          if (i === 0) {
            //音频的处理
            if (strArray[j].indexOf("a=ssrc:") === 0) {
              //以这个标记开头
              ssrc = parseInt(strArray[j].split(" ")[0].split(":")[1]);
              if (!audioArray.includes(ssrc)) {
                audioArray.push(ssrc);
              }
            }
          } else {
            //视频处理逻辑
            if (strArray[j].indexOf("a=ssrc-group:") === 0) {
              //以这个标记开头
              ssrc = parseInt(strArray[j].split(" ")[1]);
              if (!videoArray.includes(ssrc)) {
                videoArray.push(ssrc);
              }
            }
          }
        }
      }

      /*ssrState里面，会有多路视频，所以返回对象格式*/
      var ssrcState = {
        video: {},
        audio: []
      };
      var index;
      for (index in audioArray) {
        ssrcState.audio.push((audioArray[index] >> 16) & 0xff);
      }
      var state, streamID;
      for (index in videoArray) {
        state = (videoArray[index] >> 16) & 0xff;
        if (state === Constants.STREAM_TYPE.MAIN) {
          streamID = srctinyid + "_" + Constants.STREAM_MISD.MAIN;
        } else if (state === Constants.STREAM_TYPE.AID) {
          streamID = srctinyid + "_" + Constants.STREAM_MISD.AID;
        }
        ssrcState.video[streamID] = state;
      }

      /*主辅路解析逻辑结束*/

      var videoId = srctinyid + "_" + stream.id;
      Log.RTCLog.info("onAddTrack, videoId:" + videoId);


      var openId = global.openIdMap[srctinyid] || null;

      var info = {
        stream: stream,
        videoId: videoId,
        type: type,
        ssrcState: ssrcState,
        openId: openId,
        videoType: ssrcState.video && ssrcState.video[videoId]
      }
      global.streamHandler.addRemote(peerConnection, info);
    }
  }
};

RTCUtil.fn.onIceConnectionStateChange = function (e, srctinyid) {
  var global = this.global
  var emitter = this.emitter
  emitter.emit(
    "onUserDefinedWebRTCEventNotice", {
      "event": Constants.USER_DEFINED_EVENT.ON_ICE_STATE_CHANGE,
      "info": e
    });
  Log.RTCLog.info(
    "on ice connection state change : iceConnectionState = " +
    e.target.iceConnectionState +
    " , iceGatheringState = " +
    e.target.iceGatheringState +
    " srctinyid = " +
    srctinyid
  );
  if (
    "completed" === e.target.iceConnectionState &&
    "completed" === e.target.iceGatheringState
  ) {
    var pc = global.peerConnections[srctinyid];
    global.rtcReport.send(Constants.RTC_EVENT.ON_ICE_COMPLETE, {
      localCandidateList: pc.localCandidateList
    });
  }

  if (
    e.target.iceConnectionState === "failed" ||
    e.target.iceGatheringState === "failed" ||
    e.target.iceConnectionState === "disconnected" ||
    e.target.iceGatheringState === "disconnected"
  ) {
    if (global.websocket) {
      var sendData = global.rtcReport.createJsonFromTag(
        Constants.RTC_EVENT.ON_ICE_BROKEN
      );
      sendData.data = {
        iceConnectionState: e.target.iceConnectionState,
        iceGatheringState: e.target.iceGatheringState,
        openid: global.config.openid,
        tinyid: global.config.tinyid,
        srctinyid: srctinyid
      };
      global.websocket.send(JSON.stringify(sendData));
    }
    emitter.emit("onIceConnectionBroken", e);
  } else if (
    e.target.iceConnectionState === "closed" ||
    e.target.iceGatheringState === "closed"
  ) {
    //   rtclistener.config.onIceConnectionClose();
    emitter.emit("onIceConnectionClose", e);
  }
};

RTCUtil.fn.onRemoveStream = function (stream, srctinyid) {
    var global = this.global;
    var emitter = this.emitter;
    Log.RTCLog.info("on remove stream : srctinyid = " + srctinyid);

    var peerConnection = global.peerConnections[srctinyid];
    if (peerConnection) {
      var videoId = srctinyid + "_" + stream.id;
      emitter.emit("onPeerStreamRemove", videoId);
    }
  },
  RTCUtil.fn.createVideoElement = function (id, opt) {
    var video = document.createElement("video");
    video.setAttribute("playsinline", "true");
    video.className = "video-item ";
    video.autoplay = true;
    video.muted = true;
    for (var a in opt) {
      video[a] = opt[a];
    }
    // document.querySelector("#" + id).appendChild(video);
    return video;
  };

RTCUtil.fn.createAudioElement = function (id, opt) {
  var audio = document.createElement("audio");
  audio.setAttribute("playsinline", "true");
  audio.className = "audio-item";
  audio.autoplay = true;
  for (var a in opt) {
    audio[a] = opt[a];
  }
  return audio;
};


RTCUtil.fn.updateStream = function (stream, succ, fail) {
  var global = this.global;
  var emitter = this.emitter;

  global.streamHandler.addLocal(global.peerConnections[0], stream)
  this.changeSenders(stream);
  emitter.emit('onLocalStreamAdd', {
    stream: stream
  });
  global.rtcUtil.getSdp(0, function (errorCode, info) {
    if (errorCode !== 0) {
      var msg = "get local sdp failed!!! e = " + info;
      console.error(msg);
      var errorNotify = {
        errorCode: Constants.ERROR_CODE.ON_GET_LOACL_SDP_FAILED,
        errorMsg: msg,
        extInfo: info
      };
      if (fail) {
        fail(errorNotify)
      } else {
        emitter.emit("onErrorNotify", errorNotify);
      }
      return;
    }
    global.rtcUtil.sendUpdateSdp(info, 0);
    if (succ) {
      succ();
    }
  });
};

RTCUtil.fn.removeTrack = function (media, type) {
  if (type === 'audio' || type === 'all') {
    media.getAudioTracks().forEach(function (audioTrack) {
      var constraints = audioTrack.getConstraints();
      for (var key in constraints) {
        for (var subkey in constraints[key]) {
          Log.RTCLog.info("old key:" + key + "|" + subkey + " value:" + constraints[key][subkey]);
        }
      }
      audioTrack.stop();
      media.removeTrack(audioTrack);
    });
  }

  if (type === 'video' || type === 'all') {
    media.getVideoTracks().forEach(function (videoTrack) {
      var constraints = videoTrack.getConstraints();
      for (var key in constraints) {
        for (var subkey in constraints[key]) {
          Log.RTCLog.info("old key:" + key + "|" + subkey + " value:" + constraints[key][subkey]);
        }
      }
      videoTrack.stop();
      media.removeTrack(videoTrack);
    });
  }
}



RTCUtil.fn.changeSenders = function (stream) {
  var global = this.global
  var peerConnection = global.peerConnections[0];

  var videoTracks = stream.getVideoTracks();
  var audioTracks = stream.getAudioTracks();
  if (peerConnection) {
    var senders = peerConnection.getSenders() || [];
    for (var i = 0, len = senders.length; i < len; i++) {
      var sender = senders[i];
      if (sender.track.kind === "video") {
        if (sender.replaceTrack && videoTracks.length > 0) {
          sender.replaceTrack(videoTracks[0]);
        } else {
          peerConnection.removeTrack(sender);
          if (videoTracks.length > 0) {
            peerConnection.addTrack(videoTracks[0], stream);
          }
        }
      } else if (sender.track.kind === "audio") {
        if (sender.replaceTrack && audioTracks.length > 0) {
          sender.replaceTrack(audioTracks[0]);
        } else {
          peerConnection.removeTrack(sender);
          if (audioTracks.length > 0) {
            peerConnection.addTrack(audioTracks[0], stream);
          }
        }
      }
    }
  }
  return;
}


/**
 * @param newConstraints 新的配置
 * @param isChangeAudio 是否重新改变麦克风
 * @param isChangeVideo 是否重新改变摄像头
 */
RTCUtil.fn.updateLocalStream = function (
  newConstraints,
  isChangeAudio,
  isChangeVideo,
  callback
) {
  var global = this.global
  if (global.hasRetryOpenCamera) {
    Log.RTCLog.warn(
      "update local stream : camera not support, try default constraints"
    );
    return;
  }
  if (global.config.screen && isChangeVideo) {
    callback(50002, '屏幕分享不能切换摄像头或者切换spear配置~');
    return;
  }
  /* 
  @ todo 使用 applyConstraints 更新视频流
  if( isChangeVideo && !isChangeAudio){
    global.localStream.getVideoTracks().forEach(function(track) {
      track.applyConstraints(newConstraints.video); 
    });
  }
  */


  var media = global.localStream.clone();
  if (isChangeVideo) {
    this.removeTrack(media, 'video')
  }

  if (isChangeAudio) {
    this.removeTrack(media, 'audio')
  }
  global.rtcReport.send(Constants.RTC_EVENT.ON_GET_USER_MEDIA);
  Log.RTCLog.info("get new user media,  newConstraints", newConstraints);


  navigator.mediaDevices.getUserMedia(newConstraints)
    .then(function (media) {
      Log.RTCLog.info("get new user media ok!!!  newConstraints");
      // 如果是切换了摄像头
      var videoTracks = media.getVideoTracks();
      if (isChangeVideo && videoTracks.length > 0) {
        media.addTrack(videoTracks[0]);
        var peerConnection = global.peerConnections[0];
        if (peerConnection) {
          var senders = peerConnection.getSenders() || [];
          for (var i = 0, len = senders.length; i < len; i++) {
            var sender = senders[i];
            if (sender.track.kind === "video") {
              if (sender.replaceTrack) {
                sender.replaceTrack(videoTracks[0]);
              } else {
                peerConnection.removeTrack(sender);
                peerConnection.addTrack(videoTracks[0], media);
              }
              break;
            }
          }
        }
      }
      // 如果是切换了麦克风
      var audioTracks = media.getAudioTracks();
      if (isChangeAudio && audioTracks.length > 0) {
        media.addTrack(audioTracks[0]);
        var peerConnection = global.peerConnections[0];
        if (peerConnection) {
          var senders = peerConnection.getSenders() || [];
          for (var i = 0, len = senders.length; i < len; i++) {
            var sender = senders[i];
            if (sender.track.kind === "audio") {
              if (sender.replaceTrack) {
                sender.replaceTrack(audioTracks[0]);
              } else {
                peerConnection.removeTrack(sender);
                peerConnection.addTrack(audioTracks[0], media);
              }
              break;
            }
          }
        }
      }
      if (isChangeVideo) {
        global.streamHandler.addLocal(global.peerConnections[0], media)
      }
      callback(0, media);
    })
    .catch(function (error) {
      callback(Constants.ERROR_CODE.GET_USERMEDIA_FAILED, error);
    });
};

RTCUtil.fn.onRemoteCandidate = function (remoteCandidate, srctinyid) {
  var global = this.global
  var emitter = this.emitter
  Log.RTCLog.info(
    "on peer candidate : remote candidate = " +
    JSON.stringify(remoteCandidate) +
    " ,srctinyid " +
    srctinyid
  );
  srctinyid = global.config.tinyid === srctinyid ? 0 : srctinyid;
  var peerConnection = global.peerConnections[srctinyid || 0];

  if (!peerConnection) {
    var errorMsg =
      "on remote candidate , failed to get peerconnection. srctinyid = " +
      srctinyid;
    Log.RTCLog.error(errorMsg);

    global.rtcReport.send(Constants.RTC_EVENT.ON_GET_SRC_PEER_CONNECTION_FAILED, errorMsg);
    emitter.emit(
      "onUserDefinedWebRTCEventNotice", {
        "event": Constants.USER_DEFINED_EVENT.SET_REMOTE_CANDIDATE_FAILED,
        "info": null
      });
    emitter.emit('onIceConnectionBuild', {
      result: false,
      state: Constants.ICE_BUILD_STATE.CANDIDATE_FAILED
    });
    return;
  }

  peerConnection.addIceCandidate(
    remoteCandidate,
    function (e) {
      Log.RTCLog.info("add ice candidate ok");

      emitter.emit(
        "onUserDefinedWebRTCEventNotice", {
          "event": Constants.USER_DEFINED_EVENT.SET_REMOTE_CANDIDATE_SUC,
          "info": e
        });
      //set srcids in websocket
      Log.RTCLog.warn(
        "push src tiny id in src list, tinyid = " +
        global.config.tinyid +
        " , src tinyid = " +
        srctinyid
      );
      global.websocket.sessioninfo.srcids.push(srctinyid + "");
      global.rtcReport.send(Constants.RTC_EVENT.ON_SET_REMOTE_CANDIDATE_SUC, peerConnection.localCandidateList);
      emitter.emit('onIceConnectionBuild', {
        result: true,
        state: Constants.ICE_BUILD_STATE.SUC
      });
    },
    function (e) {
      emitter.emit(
        "onUserDefinedWebRTCEventNotice", {
          "event": Constants.USER_DEFINED_EVENT.SET_REMOTE_CANDIDATE_FAILED,
          "info": e
        });
      emitter.emit('onIceConnectionBuild', {
        result: false,
        state: Constants.ICE_BUILD_STATE.CANDIDATE_FAILED,
        info: e
      });
      var errorMsg = "add remote candidate failed!  exception = " + e;
      Log.RTCLog.error(errorMsg);
      if (global.websocket) {
        var sendData = global.rtcReport.createJsonFromTag(
          Constants.RTC_EVENT.ON_SET_REMOTE_CANDIDATE_FAILED
        );
        sendData.data = {
          errorMsg: errorMsg,
          openid: global.config.openid,
          tinyid: global.config.tinyid,
          sessionid: global.roomid
        };
        global.websocket.send(JSON.stringify(sendData));
      }
    }
  );
};

RTCUtil.fn.sendLocalCandidate = function (pc, srctinyid) {
  var self = this;
  if (pc.isSdpSendOK && !pc.hasSendCandidate) {
    var global = this.global
    var emitter = this.emitter
    var candidate = this.pickCandidate(pc, srctinyid)
    if (candidate) {
      pc.hasSendCandidate = true;
      var sendData = global.rtcReport.createJsonFromTag(
        Constants.RTC_EVENT.ON_PEER_CANDIDATE
      );
      sendData.data = candidate
      sendData.srctinyid = srctinyid || "0";
      global.websocket.send(JSON.stringify(sendData));
    } else {
      //candidate 失败
      var errorMsg = "get local candidate failed With candidate list = " + JSON.stringify(pc.localCandidateList);
      Log.RTCLog.error( errorMsg );
      emitter.emit("onErrorNotify", {
        errorCode: Constants.ERROR_CODE.GET_LOCAL_CANDIDATE_FAILED,
        errorMsg: errorMsg
      })
      emitter.emit("onUserDefinedWebRTCEventNotice", {
        event: Constants.USER_DEFINED_EVENT.GET_LOCAL_STUN_IP_FAILED,
        info: pc.localCandidateList
      });
      emitter.emit('onIceConnectionBuild', {
        event: false,
        state: Constants.ICE_BUILD_STATE.GET_STUN_IP_FAILED,
        info: pc.localCandidateList
      });
      global.rtcReport.send(Constants.RTC_EVENT.ON_GET_LOCAL_CANDIDATE_FAILED, {
        stunserver: Constants.WEBRTC_STUN_SERVER,
        localCandidateList: pc.localCandidateList
      });
    }
  }
};

RTCUtil.fn.onRemoteSdp = function (remoteSdp, srctinyid) {
  var self = this;
  var global = this.global
  var emitter = this.emitter
  Log.RTCLog.info(
    "srctinyid:" + srctinyid + " on remote sdp : ", remoteSdp
  );
  srctinyid = global.config.tinyid === srctinyid ? 0 : srctinyid;
  var peerConnection = global.peerConnections[srctinyid];

  if (!peerConnection) {
    var errorMsg =
      "on remote sdp , failed to get peerconnection. srctinyid = " +
      srctinyid;
    Log.RTCLog.error(errorMsg);

    global.rtcReport.send(Constants.RTC_EVENT.ON_GET_SRC_PEER_CONNECTION_FAILED, errorMsg);
    emitter.emit(
      "onUserDefinedWebRTCEventNotice", {
        "event": Constants.USER_DEFINED_EVENT.SET_REMOTE_SDP_FAILED,
        "info": errorMsg
      });
    emitter.emit('onIceConnectionBuild', {
      result: false,
      state: Constants.ICE_BUILD_STATE.SDP_FAILED,
      info: e
    });
    return;
  }

  if (srctinyid != 0 && Constants.InternalVersion < 1001) {
    remoteSdp.type = "pranswer";
  }

  if( DetectRTC.isFF() ){
    remoteSdp.sdp = remoteSdp.sdp.replace(/BUNDLE audio video/gim, "BUNDLE sdparta_0 sdparta_1");
    remoteSdp.sdp = remoteSdp.sdp.replace(/mid:audio/gim, "mid:sdparta_0");
    remoteSdp.sdp = remoteSdp.sdp.replace(/mid:video/gim, "mid:sdparta_1");
  }
  console.debug( remoteSdp)

  peerConnection.setRemoteDescription(
    new RTCSessionDescription(remoteSdp),
    function () {
      emitter.emit("onUserDefinedWebRTCEventNotice", {
        "event": Constants.USER_DEFINED_EVENT.SET_REMOTE_SDP_SUC,
        info: null
      });
      if (srctinyid != 0) {
        global.websocket.sessioninfo.peersdp[srctinyid + ""] = remoteSdp.sdp;
      }
      peerConnection.isSdpSendOK = true;
      global.rtcReport.send(Constants.RTC_EVENT.ON_SET_REMOTE_SDP_SUC);
      self.sendLocalCandidate(peerConnection, srctinyid);
    },
    function (e) {
      emitter.emit("onUserDefinedWebRTCEventNotice", {
        "event": Constants.USER_DEFINED_EVENT.SET_REMOTE_SDP_FAILED,
        info: e
      });
      emitter.emit('onIceConnectionBuild', {
        result: false,
        state: Constants.ICE_BUILD_STATE.SDP_FAILED,
        info: e
      });
      try {
        var errorMsg = "on set remote sdp failed , exception = " + e.message;
        if (global.websocket) {
          var sendData = global.rtcReport.createJsonFromTag(
            Constants.RTC_EVENT.ON_SET_REMOTE_SDP_FAILED
          );
          sendData.data = {
            errorMsg: errorMsg,
            tinyid: global.config.tinyid,
            openid: global.config.openid,
            sessionid: global.roomid
          };
          global.websocket.send(JSON.stringify(sendData));
        }
        Log.RTCLog.error(errorMsg);
        emitter.emit("execCallback", {
          name: "startRTCError",
          data: {
            errorCode: Constants.ERROR_CODE.SET_REMOTE_SDP_FAILED,
            errorMsg: errorMsg
          }
        });

      } catch (e) {
        Log.RTCLog.info(e);
      }
    }
  );
};

RTCUtil.fn.addPeer = function (
  openid,
  tinyid,
  roomid,
  srctinyid,
  userSig,
  peerconnectionport
) {
  var global = this.global
  var data = {
    openid: openid,
    tinyid: tinyid,
    srctinyid: srctinyid,
    peerconnectionport: peerconnectionport,
    roomid: roomid,
    sdkAppID: String(global.config.sdkAppId),
    socketid: global.websocket.socketid,
    userSig: userSig || global.config.userSig,
    relayip: global.websocket.relayInfo.innerip,
    dataport: global.dataport,
    stunport: global.stunport
  };
  Log.RTCLog.debug("add peer : openid = " + JSON.stringify(data));
  global.rtcReport.send(Constants.RTC_EVENT.ON_CREATE_PEER, data)
  return true;
};

RTCUtil.fn.clearGlobalValues = function () {
  var global = this.global
  global.config = {
    sdkAppId: "",
    openid: "",
    tinyid: "",
    srctinyid: "",
    userSig: "",
    privMapEncrypt: "",
    accountType: ""
  };
  global.constraints = {
    "audio": true,
    "video": true
  };
  global.deviceInfo = {
    "audio": false,
    "video": false
  };
  global.checkSigSeq = null;
  global.reportTime = 0;
  global.specifyConstraints = null;
  global.hasRetryOpenCamera = false;
  global.inited = false;
  global.enteredRoom = false;
  global.roomid = 0;
  global.remoteSdps = {};
};

RTCUtil.fn.getAnswerSdp = function (srctinyid, callback) {
  var global = this.global
  if (!srctinyid) {
    srctinyid = 0;
  }
  var peerConnection = global.peerConnections[srctinyid];
  if (peerConnection) {
    peerConnection.createAnswer().then(function (answerSdp) {
      peerConnection.setLocalDescription(answerSdp);
      callback(0, answerSdp);

    }).catch(function (reason) {
      Log.RTCLog.error("create answer failed : reason = " + reason);
      callback(Constants.ERROR_CODE.GET_ANSWER_SDP_FAILED, reason);
    });
  }
};

module.exports = RTCUtil;

/***/ }),
/* 37 */
/***/ (function(module, exports) {

/*

    debugout.js
    by @inorganik
    
*/

// save all the console.logs
function debugout() {
	var self = this;

	// OPTIONS
	self.realTimeLoggingOn = true; // log in real time (forwards to console.log)
	self.useTimestamps = false; // insert a timestamp in front of each log
	self.useLocalStorage = false; // store the output using window.localStorage() and continuously add to the same log each session
	self.recordLogs = true; // set to false after you're done debugging to avoid the log eating up memory
	self.autoTrim = true; // to avoid the log eating up potentially endless memory
	self.maxLines = 2500; // if autoTrim is true, this many most recent lines are saved
	self.tailNumLines = 100; // how many lines tail() will retrieve
	self.logFilename = 'debugout.txt'; // filename of log downloaded with downloadLog()

	// vars
	self.depth = 0;
	self.parentSizes = [0];
	self.currentResult = '';
	self.startTime = new Date();
	self.output = '';

	this.version = function() { return '0.5.0' }

	/*
		USER METHODS
	*/	
	this.getLog = function() {
		var retrievalTime = new Date();
		// if recording is off, so dev knows why they don't have any logs
		if (!self.recordLogs) {
			self.log('[debugout.js] log recording is off.');
		}
		// if using local storage, get values
		if (self.useLocalStorage) {
			var saved = window.localStorage.getItem('debugout.js');
			if (saved) {
				saved = JSON.parse(saved);
				self.startTime = new Date(saved.startTime);
				self.output = saved.log;
				retrievalTime = new Date(saved.lastLog);
			}
		}
		return self.output
			+ '\n---- Log retrieved: '+retrievalTime+' ----\n'
			+ self.formatSessionDuration(self.startTime, retrievalTime);
	}
	// accepts optional number or uses the default for number of lines
	this.tail = function(numLines) {
		var numLines = numLines || self.tailLines;
		return self.trimLog(self.getLog(), numLines);
	}
	// accepts a string to search for
	this.search = function(string) {
		var lines = self.output.split('\n');
		var rgx = new RegExp(string);
		var matched = [];
		// can't use a simple Array.prototype.filter() here
		// because we need to add the line number
		for (var i = 0; i < lines.length; i++) {
			var addr = '['+i+'] ';
			if (lines[i].match(rgx)) {
				matched.push(addr + lines[i]);
			}
		}
		var result = matched.join('\n');
		if (result.length == 0) result = 'Nothing found for "'+string+'".';
		return result
	}
	// accepts the starting line and how many lines after the starting line you want
	this.getSlice = function(lineNumber, numLines) {
		var lines = self.output.split('\n');
		var segment = lines.slice(lineNumber, lineNumber + numLines);
		return segment.join('\n');
	}
	// immediately downloads the log - for desktop browser use
	this.downloadLog = function() {
	    var file = "data:text/plain;charset=utf-8,";
	    var logFile = self.getLog();
	    var encoded = encodeURIComponent(logFile);
	    file += encoded;
	    var a = document.createElement('a');
	    a.href = file;
	    a.target   = '_blank';
	    a.download = self.logFilename;
	    document.body.appendChild(a);
	    a.click();
	    a.remove();
	}
	// clears the log
	this.clear = function() {
		var clearTime = new Date();
		self.output = '---- Log cleared: '+clearTime+' ----\n';
		if (self.useLocalStorage) {
			// local storage
			var saveObject = {
				startTime: self.startTime,
				log: self.output,
				lastLog: clearTime
			}
			saveObject = JSON.stringify(saveObject);
			window.localStorage.setItem('debugout.js', saveObject);
		}
		if (self.realTimeLoggingOn) console.log('[debugout.js] clear()');
	}
	// records a log
	this.log = function(obj) {
		// log in real time
		if (self.realTimeLoggingOn) console.log(obj);
		// record log
		var type = self.determineType(obj);
		if (type != null && self.recordLogs) {
			var addition = self.formatType(type, obj);
			// timestamp, formatted for brevity
			if (self.useTimestamps) {
				var logTime = new Date();
				self.output += self.formatTimestamp(logTime);
			}
			self.output += addition+'\n';
			if (self.autoTrim) self.output = self.trimLog(self.output, self.maxLines);
			// local storage
			if (self.useLocalStorage) {
				var last = new Date();
				var saveObject = {
					startTime: self.startTime,
					log: self.output,
					lastLog: last
				}
				saveObject = JSON.stringify(saveObject);
				window.localStorage.setItem('debugout.js', saveObject);
			}
		}
		self.depth = 0;
		self.parentSizes = [0];
		self.currentResult = '';
	}
	/*
		METHODS FOR CONSTRUCTING THE LOG
	*/

	// like typeof but classifies objects of type 'object'
	// kept separate from formatType() so you can use at your convenience!
	this.determineType = function(object) {
		if (object != null) {
			var typeResult;
			var type = typeof object;
			if (type == 'object') {
				var len = object.length;
				if (len == null) {
					if (typeof object.getTime == 'function') {
						typeResult = 'Date';
					}
					else if (typeof object.test == 'function') {
						typeResult = 'RegExp';
					}
					else {
						typeResult = 'Object';
					}
				} else {
					typeResult = 'Array';
				}
			} else {
				typeResult = type;
			}
			return typeResult;
		} else {
			return null;
		}
	}
	// format type accordingly, recursively if necessary
	this.formatType = function(type, obj) {
		switch(type) {
			case 'Object' :
				self.currentResult += '{\n';
				self.depth++;
				self.parentSizes.push(self.objectSize(obj));
				var i = 0;
				for (var prop in obj) {
					self.currentResult += self.indentsForDepth(self.depth);
					self.currentResult += prop + ': ';
					var subtype = self.determineType(obj[prop]);
					var subresult = self.formatType(subtype, obj[prop]);
					if (subresult) {
						self.currentResult += subresult;
						if (i != self.parentSizes[self.depth]-1) self.currentResult += ',';
						self.currentResult += '\n';
					} else {
						if (i != self.parentSizes[self.depth]-1) self.currentResult += ',';
						self.currentResult += '\n';
					}
					i++;
				}
				self.depth--;
				self.parentSizes.pop();
				self.currentResult += self.indentsForDepth(self.depth);
				self.currentResult += '}';
				if (self.depth == 0) return self.currentResult;
				break;
			case 'Array' :
				self.currentResult += '[';
				self.depth++;
				self.parentSizes.push(obj.length);
				for (var i = 0; i < obj.length; i++) {
					var subtype = self.determineType(obj[i]);
					if (subtype == 'Object' || subtype == 'Array') self.currentResult += '\n' + self.indentsForDepth(self.depth);
					var subresult = self.formatType(subtype, obj[i]);
					if (subresult) {
						self.currentResult += subresult;
						if (i != self.parentSizes[self.depth]-1) self.currentResult += ', ';
						if (subtype == 'Array') self.currentResult += '\n';
					} else {
						if (i != self.parentSizes[self.depth]-1) self.currentResult += ', ';
						if (subtype != 'Object') self.currentResult += '\n';
						else if (i == self.parentSizes[self.depth]-1) self.currentResult += '\n';
					}
				}
				self.depth--;
				self.parentSizes.pop();
				self.currentResult += ']';
				if (self.depth == 0) return self.currentResult;
				break;
			case 'function' :
				obj += '';
				var lines = obj.split('\n');
				for (var i = 0; i < lines.length; i++) {
					if (lines[i].match(/\}/)) self.depth--;
					self.currentResult += self.indentsForDepth(self.depth);
					if (lines[i].match(/\{/)) self.depth++;
					self.currentResult += lines[i] + '\n';
				}
				return self.currentResult;
				break;
			case 'RegExp' :
				return '/'+obj.source+'/';
				break;
			case 'Date' :
			case 'string' : 
				if (self.depth > 0 || obj.length == 0) {
					return '"'+obj+'"';
				} else {
					return obj;
				}
			case 'boolean' :
				if (obj) return 'true';
				else return 'false';
			case 'number' :
				return obj+'';
				break;
		}
	}
	this.indentsForDepth = function(depth) {
		var str = '';
		for (var i = 0; i < depth; i++) {
			str += '\t';
		}
		return str;
	}
	this.trimLog = function(log, maxLines) {
		var lines = log.split('\n');
		if (lines.length > maxLines) {
			lines = lines.slice(lines.length - maxLines);
		}
		return lines.join('\n');
	}
	this.lines = function() {
		return self.output.split('\n').length;
	}
	// calculate testing time
	this.formatSessionDuration = function(startTime, endTime) {
		var msec = endTime - startTime;
		var hh = Math.floor(msec / 1000 / 60 / 60);
		var hrs = ('0' + hh).slice(-2);
		msec -= hh * 1000 * 60 * 60;
		var mm = Math.floor(msec / 1000 / 60);
		var mins = ('0' + mm).slice(-2);
		msec -= mm * 1000 * 60;
		var ss = Math.floor(msec / 1000);
		var secs = ('0' + ss).slice(-2);
		msec -= ss * 1000;
		return '---- Session duration: '+hrs+':'+mins+':'+secs+' ----'
	}
	this.formatTimestamp = function(timestamp) {
		var year = timestamp.getFullYear();
		var date = timestamp.getDate();
		var month = ('0' + (timestamp.getMonth() +1)).slice(-2);
		var hrs = Number(timestamp.getHours()); 
		var mins = ('0' + timestamp.getMinutes()).slice(-2);
		var secs = ('0' + timestamp.getSeconds()).slice(-2);
		return '['+ year + '-' + month + '-' + date + ' ' + hrs + ':' + mins + ':'+secs + ']: ';
	}
	this.objectSize = function(obj) {
	    var size = 0, key;
	    for (key in obj) {
	        if (obj.hasOwnProperty(key)) size++;
	    }
	    return size;
	}

	/*
		START/RESUME LOG
	*/
	if (self.useLocalStorage) {
		var saved = window.localStorage.getItem('debugout.js');
		if (saved) {
			saved = JSON.parse(saved);
			self.output = saved.log;
			var start = new Date(saved.startTime);
			var end = new Date(saved.lastLog);
			self.output += '\n---- Session end: '+saved.lastLog+' ----\n';
			self.output += self.formatSessionDuration(start, end);
			self.output += '\n\n';
		}
	} 
	self.output += '---- Session started: '+self.startTime+' ----\n\n';
}


module.exports = debugout

/***/ }),
/* 38 */
/***/ (function(module, exports, __webpack_require__) {

var Constants = __webpack_require__(1)
var DetectRTC = __webpack_require__(9)
var Log = __webpack_require__(3)
var Report = __webpack_require__(8)

var MediaUtil = function (global, emitter) {
    this.global = global;
    this.emitter = emitter;
}
MediaUtil.fn = MediaUtil.prototype;
MediaUtil.fn.init = function( global, emitter ){
    this.global = global
    this.emitter = emitter;
    this.hasRetryOpenCamera = false;
},
MediaUtil.fn.gum = function( opts, succ, fail ){
    var global = this.global
    var self = this;
    if( opts.constraints ){
        Log.RTCLog.info("try to get user media! global.constraints:" + JSON.stringify(opts.constraints));
        Log.uploadWebLog(global, "try to get user media! global.constraints:" + JSON.stringify(opts.constraints), null, Constants.KEY_TAG.RTC_LOG_TAG);
    }
    console.debug('constraints',opts.constraints)
    navigator.mediaDevices.getUserMedia( opts.constraints ).then(function (stream) {
        if( succ ){
            self.hasRetryOpenCamera = false;
            succ( {
                errorCode:0,
                stream : stream
            } )
            
            global.constraintsList.push(  {
                result: "ok" , 
                constraint: JSON.stringify( opts.constraints )
            }  )
            Log.RTCLog.info("get user media ok! global.constraints:" + JSON.stringify(opts.constraints));
            Log.uploadWebLog(global, "get user media ok! global.constraints:" + JSON.stringify(opts.constraints), null, Constants.KEY_TAG.RTC_LOG_TAG);
        }
    }).catch(function (error) {
        var needRetry = typeof opts.needRetry !=='undefined' ? opts.needRetry : true
        if (!needRetry || self.hasRetryOpenCamera || error.name ==='NotFoundError' || error.name === 'NotSupportedError') {
            if( global ){
                var errorMsg = "get user media failed : error = " + error.name + " global.constraints:" + JSON.stringify(opts.constraints);
                Log.RTCLog.error(errorMsg);
                Log.uploadWebLog(global, errorMsg, null, Constants.KEY_TAG.RTC_LOG_TAG);
                global.rtcReport.send( Constants.RTC_EVENT.ON_GET_USER_MEDIA_FAILED, errorMsg);
                global.constraintsList.push(  {
                    result: errorMsg , 
                    constraint: JSON.stringify( opts.constraints )
                }  )
            }
            if( error.name === 'NotSupportedError' ){
                console.error("获取音视频设备必须在https域名或localhost下访问")
            }

            error.constraint = error.constraint || opts.constraints
            fail && fail({
                errorCode:Constants.ERROR_CODE.GET_USERMEDIA_FAILED,
                errorMsg:errorMsg,
                extInfo: error
            });
        } else {
            if( global ){
                var errorMsg = "get user media failed, error = " + error.name  + " opts.constraints:" + JSON.stringify(opts.constraints) + "; RetryOpenCamera";
                Log.RTCLog.warn(errorMsg);
                Log.uploadWebLog(global, errorMsg, null, Constants.KEY_TAG.RTC_LOG_TAG);
                global.rtcReport.send( Constants.RTC_EVENT.ON_GET_USER_MEDIA_FAILED, errorMsg);
                
                global.constraintsList.push(  {
                    result: errorMsg , 
                    constraint: JSON.stringify( opts.constraints )
                }  )
            }
            opts.constraints.video = true;
            self.hasRetryOpenCamera = true;
            self.gum({constraints: opts.constraints}, succ, fail);
        }
    });
};

MediaUtil.fn.gumByScreen = function(opts, succ, fail){
    var global = this.global
    var emitter = this.emitter
    var screen_constraints = opts.constraints
    //获取屏幕分享
    console.debug('constraints',opts.constraints)
    var promises = [ Promise.resolve( navigator.mediaDevices.getUserMedia(_.extend({},screen_constraints,{audio:false})) ) ];
    //根据配置决定是否获取麦克风
    if( screen_constraints.audio){
        var constraint = {audio: true };
        if( screen_constraints.audio.deviceId ){
            constraint = {
                audio: {
                    deviceId : { exact: screen_constraints.audio.deviceId}
                }
            };
        }
        promises.push( Promise.resolve( navigator.mediaDevices.getUserMedia( constraint ) ) )
    }
    Promise.all( promises ).then(function(streams) {
        global.constraintsList.push(  {
            result:"ok", 
            constraint: JSON.stringify( screen_constraints )
        }  )
        var stream = streams[0];
        if(streams.length > 1) {
            stream.addTrack(streams[1].getAudioTracks()[0]);
        }
        
        var info = "get user media ok! screen_constraints:" + JSON.stringify(screen_constraints) + '; constraints:' + JSON.stringify(opts.constraints);
        Log.RTCLog.info(info);
        Log.uploadWebLog(info, null, Constants.KEY_TAG.RTC_LOG_TAG);
        
        global.rtcReport.send( Constants.RTC_EVENT.ON_GET_USER_MEDIA_OK, screen_constraints );
        succ && succ({
            errorCode: 0,
            stream: stream
        });
    }, function(error) {
        var errorMsg = "get user media failed : error = " + error.message + "screen_constraints" + JSON.stringify(screen_constraints) + " global.constraints:" + JSON.stringify(global.constraints);
        Log.RTCLog.error(errorMsg);
        Log.uploadWebLog(errorMsg, null, Constants.KEY_TAG.RTC_LOG_TAG);

        global.constraintsList.push(  {
            result: errorMsg , 
            constraint: JSON.stringify( screen_constraints )
        }  )
        global.rtcReport.send( Constants.RTC_EVENT.ON_GET_USER_MEDIA_FAILED, errorMsg);
        fail && fail({
            errorCode:Constants.ERROR_CODE.GET_USERMEDIA_FAILED,
            errorMsg:errorMsg,
            extInfo: error
        });
        if( !fail){
            emitter.emit("onErrorNotify", {
              errorCode: Constants.ERROR_CODE.GET_USERMEDIA_FAILED,
              errorMsg: errorMsg,
              extInfo: error
            })
        }
    });
};

MediaUtil.fn.gumByMediaDevice = function(opts, succ, fail){
    var global = this.global
    var emitter = this.emitter

    this.gum( opts, function( data ){
        var stream = data.stream
        global.rtcReport.send( Constants.RTC_EVENT.ON_GET_USER_MEDIA_OK, opts.constraints);
        succ && succ({
            errorCode:0,
            stream:stream
        });
    }, function(error){
        fail && fail(error);
        if( !fail){
            emitter.emit("onErrorNotify", {
              errorCode: Constants.ERROR_CODE.GET_USERMEDIA_FAILED,
              errorMsg: errorMsg,
              extInfo: error
            })
        }
    })
};
/* 
    生成 constraints

    opts 会带的信息包括
       | audio         | Boolean |否 | 是否采集音频，默认true  |
        | video         | Boolean |否 | 是否采集视频，默认true   |
        | screen         | Boolean |否 | 是否采集屏幕分享 ,默认false   |
        | screenSources | string   |否 | 屏幕分享采集的媒介 用半角逗号隔开， 可选选项包括  screen window tab audio |
        | attributes         | Object |否 | 推流相关配置的属性 |
        | videoDevice         | Device |否 | 指定设备，getVideoDevices 获取的device item   |
        | audioDevice         | Device |否 | 指定设备，getVideoDevices 获取的audio item   |
        | needRetry         | Boolean |否 | 使用参数配置获取失败时，是否允许降级去掉配置重试 ,默认为true | 
    
    
        1.屏幕分享:
            配置帧率
            配置分辨率
        2.摄像头：

*/

MediaUtil.fn.packConstraints = function( constraints, opts, ext){
    var new_constraints = _.clone(constraints)
    if( opts && opts.screen ){
        new_constraints.video.mandatory.maxFrameRate = (opts.attributes && (opts.attributes.maxFrameRate || opts.attributes.frameRate)) ||  ext.frameRate || null
        new_constraints.video.mandatory.minFrameRate =  (opts.attributes && (opts.attributes.minFrameRate || opts.attributes.frameRate)) ||  ext.frameRate || null
        return new_constraints
    }
    if( opts ){
        new_constraints = {
            audio: typeof opts.audio !== 'undefined' ? opts.audio : true,
            video: typeof opts.video !== 'undefined' ? opts.video : true
        };
    }

    var global  = this.global;
    if (DetectRTC.isSafari()) {
        if( new_constraints.video && new_constraints.video.deviceId ){
            new_constraints = {
                "audio": global.config.audioActive,
                "video": {
                    deviceId : new_constraints.video.deviceId
                }
            };
        }else{
            new_constraints = {
                "audio": global.config.audioActive,
                "video": global.config.videoActive
            };
        }
    }else{
        if( opts && opts.audioDevice && opts.audioDevice.deviceId ){
            // new_constraints.audioDevice.deviceId = opts.audioDevice.deviceId
            var exact = { exact: opts.audioDevice.deviceId}
            if( typeof new_constraints.audio === 'object' ){
                new_constraints.audio.deviceId = exact;
            }else{
                new_constraints.audio = {
                    deviceId : exact
                }
            }
        }
        if( opts && opts.videoDevice && opts.videoDevice.deviceId){
            if( Constants.ConstraintsMode === 1 ){
                if( typeof new_constraints.video === 'object'){
                    new_constraints.video.deviceId = opts.videoDevice.deviceId;
                }else{
                    new_constraints.video.deviceId = opts.videoDevice.deviceId
                    new_constraints.video = {
                        deviceId: opts.videoDevice.deviceId
                    }
                }
            }else{
                if( typeof new_constraints.video === 'object'){
                    new_constraints.video.mandatory.sourceId =  opts.videoDevice.deviceId;
                }else{
                    new_constraints.video = {
                        mandatory: {
                            sourceId : opts.videoDevice.deviceId
                        }
                    }
                }
            }
        }
    }
    if (new_constraints.video && opts && opts.video != false && opts.attributes) {
        if( !new_constraints.video.mandatory ){
            if( typeof new_constraints.video !== 'object'){
                new_constraints.video = {};
            }
            new_constraints.video.mandatory = {
                maxWidth : null,
                minWidth : null,
                maxHeight : null,
                minHeight : null,
                maxFrameRate : null,
                minFrameRate : null
            };
        }
        new_constraints.video.mandatory.maxWidth = (opts.attributes && (opts.attributes.maxWidth || opts.attributes.width)) ||  null
        new_constraints.video.mandatory.minWidth =  (opts.attributes && (opts.attributes.minWidth || opts.attributes.width)) || null
        new_constraints.video.mandatory.maxHeight = (opts.attributes && (opts.attributes.maxHeight || opts.attributes.height)) ||  null
        new_constraints.video.mandatory.minHeight =  (opts.attributes && (opts.attributes.minHeight || opts.attributes.height)) || null
        new_constraints.video.mandatory.maxFrameRate = (opts.attributes && (opts.attributes.maxFrameRate || opts.attributes.frameRate)) ||  ext.frameRate || null
        new_constraints.video.mandatory.minFrameRate =  (opts.attributes && (opts.attributes.minFrameRate || opts.attributes.frameRate)) ||  ext.frameRate || null
        for(var a in new_constraints.video.mandatory){
            if(!new_constraints.video.mandatory[a]){
                delete new_constraints.video.mandatory[a];
            }
            if( new_constraints.video.mandatory.minAspectRatio && new_constraints.video.mandatory.maxHeight ){
                delete new_constraints.video.mandatory.maxHeight;
                delete new_constraints.video.mandatory.minHeight;
            }
        }
    }
    return new_constraints;
}
module.exports = MediaUtil;

/***/ }),
/* 39 */
/***/ (function(module, exports, __webpack_require__) {

/* WEBPACK VAR INJECTION */(function(global) {var Log = __webpack_require__(3)
var Constants = __webpack_require__(1)

function WebSocketClient( global ) {
    this.instance = null;
    this.retryCount = Constants.WS_MAX_RETRY_COUNT;
    this.url = null;
    this.hasConnect = false;
    this.relayInfo = {
        innerip : null,
        outterip : null,
        dataport : 0,
        stunport : 0
    };
    this.sessioninfo = {
        openid : null,
        tinyid : null,
        srcids : [],
        sessionid : 0,
        peersdp : {}
    };
    this.reconnectTimer = null;
    this.global = global
}

WebSocketClient.prototype.open = function (url, orignalUrl) {

    var global = this.global;
    var that = this;
    Log.uploadWebLog(global, "[WebSocketClient : begin connection websocket server, url = ] " + url, null, "WebSocketTag");
    var ourl = orignalUrl || url;
    this.url = ourl;
    if (this.instance) {
        try {
            Log.uploadWebLog(global, "[WebSocketClient : old instance is not close! close it before create the new one! old readyState = ]" + this.instance.readyState + " , old url = " + this.instance.url, null, "WebSocketTag");
            this.instance.onclose = function(){};
            this.instance.close(4011);
            this.instance = null;
        } catch (e) {
            Log.uploadWebLog(global, "[WebSocketClient close last instance error : ]" + e.message, null, "WebSocketTag");
        }
    }
    this.instance = new WebSocket(url);
    this.instance.onopen = function () {
        Log.uploadWebLog(global, "[WebSocketClient instance is open success!!!]", null, "WebSocketTag");
        that.hasConnect = true;
        that.retryCount = Constants.WS_MAX_RETRY_COUNT;
        that.onopen();
    };
    this.instance.onerror = function (e) {
        Log.uploadWebLog(global, "[WebSocketClient instance onerror! url = ]" + e.currentTarget.url, null, "WebSocketTag");
        that.onerror(e);
    };
    this.instance.onclose = function (e) {
        Log.uploadWebLog(global, "[WebSocketClient instance close!, code = ]" + e.code + " , url = " + e.currentTarget.url, null, "WebSocketTag");
        switch (e.code) {
            case 1000:
            case 1006:
                that.onclose(e);
                break;
            case 1001:
            case 1002:
            case 1003:
            case 1004:
            case 1005:
            case 1007:
            case 1008:
            case 1009:
            case 1010:
            case 1011:
            case 1012:
            case 1013:
            case 1014:
            case 1015:
            case 4010:
            case 4011:
                if (that.retryCount <= 0) {
                    that.onclose(e);
                } else {
                    that.onneedreconnect(e);
                }
                break;
            default:
                that.onclose(e);
                break;
        }
    };
    this.instance.onmessage = function (e) {
        that.onmessage(e);
    };
};

WebSocketClient.prototype.onopen = function () {
    console.info("WebSocketClient : onopen ", arguments);
};

WebSocketClient.prototype.onmessage = function (data) {

};

WebSocketClient.prototype.onerror = function (e) {
    console.error("WebSocketClient : onerror ", arguments);
};

WebSocketClient.prototype.onclose = function (e) {
    console.warn("WebSocketClient : onclose", arguments);
};

WebSocketClient.prototype.onneedreconnect = function (e) {
    this.reconnect( this.global.config.userSig );
};

WebSocketClient.prototype.close = function () {
    Log.uploadWebLog(global, "[WebSocketClient --> on close!]");
    clearTimeout(this.reconnectTimer);
    if (this.instance) {
        this.instance.close(1000);
        this.instance = null;
    }
    this.hasConnect = false;
    this.url = null;
    this.relayInfo = {
        innerip : null,
        outterip : null,
        dataport : 0,
        stunport : 0
    };
    this.sessioninfo = {
        openid : null,
        tinyid : null,
        srcids : [],
        peersdp : {}
    };
};


WebSocketClient.prototype.reconnect = function (sig) {
    Log.uploadWebLog(global, "[WebSocketClient --> begin reconnect!!! sig = ]" + sig);
    console.warn("websocketclient try reconnect!");
    var that = this;
    if (sig) {
        this.url = this.replaceURLValue(this.url, "userSig", sig);
    }
    var dist = Constants.WS_RETRY_DIST * (Constants.WS_MAX_RETRY_COUNT - that.retryCount + 1);
    this.reconnectTimer = setTimeout(function () {
        if (that.retryCount <= 0) {
            that.close();
            return;
        }
        that.retryCount --;
        Log.uploadWebLog(global, "[WebSocketClient --> reconnectting!!!]");
        console.warn("websocketclient reconnecting");
        if (!that.hasConnect) {
            that.open(that.url);
        } else {
            var finalurl = that.url + "&iip=" + that.relayInfo.innerip + "&dp=" + that.relayInfo.dataport + "&oip=" + that.relayInfo.outterip + "&sp=" + that.relayInfo.stunport + "&rc=1";
            that.open(finalurl, that.url);
        }
    }, dist > 3000 ? dist : 3000);
};

WebSocketClient.prototype.send = function (msg) {
    if (this.instance && this.instance.readyState == this.instance.OPEN ) {
        Log.debugout.log("[INFO][websocket][send]" + msg)
        this.instance.send(msg);
    }
};

WebSocketClient.prototype.replaceURLValue = function (url, paramName, replaceWith) {
    var re = eval('/('+ paramName+'=)([^&]*)/gi');
    return url.replace(re, paramName + '=' + replaceWith);
};



module.exports = WebSocketClient


/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(0)))

/***/ }),
/* 40 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var Constants = __webpack_require__(1)
var Report = __webpack_require__(8)


function addStreamStopListener(stream, callback) {
    var streamEndedEvent = 'ended';
    if ('oninactive' in stream) {
        streamEndedEvent = 'inactive';
    }
    stream.preventEvent = 0;
    stream.addEventListener(streamEndedEvent, function() {
        if( stream.preventEvent ) return;
        callback({type: 'stream' });
        // callback = function() {};
    }, false);
    stream.getAudioTracks().forEach(function(track) {
        track.addEventListener('ended', function() {
            if( stream.preventEvent ) return;
            callback( {type: 'audio' });
            // callback = function() {};
        }, false);
    });
    stream.getVideoTracks().forEach(function(track) {
        track.addEventListener('ended', function() {
            if( stream.preventEvent ) return;
            callback({type: 'video' });
            // callback = function() {};
        }, false);
    });
}



var StreamHandler = function (global, emitter) {
    this.global = global;
    this.emitter = emitter;
}
StreamHandler.fn = StreamHandler.prototype;

StreamHandler.fn.init = function( global , emitter ){
    this.global = global
    this.emitter = emitter
};

StreamHandler.fn.addLocal = function( peer , stream){
    var global = this.global;
    var emitter = this.emitter;

    this.releaseLocal();
    if( global.localStream){
        peer.removeStream( global.localStream );
    }
    global.localStream = stream;
    peer.addStream( stream );
    //重置静音设置
    this.reformLocal();
    emitter.emit("onStreamNotify",{
        isLocal: true,
        event: "onadd",
        stream: stream
    })
    addStreamStopListener(stream, function(info){
        var data = {
            isLocal: true,
            event: 'inactive',
            stream: stream,
            type: info.type
        };
        emitter.emit("onStreamNotify",data)
        global.rtcReport.send( Constants.RTC_EVENT.ON_STREAM_NOTIFY, data);
    });
};


StreamHandler.fn.releaseLocal = function( stream ){
    var global = this.global;
    if( !stream ){
        stream = global.localStream;
    }
    if( stream ){
        stream.preventEvent = 1;
        stream.getTracks().forEach(function(track) {
            track.stop();
        });
        stream = null;
    }
};

StreamHandler.fn.reformLocal = function(){
    var global = this.global;
    var stream = global.localStream;
    var status = global.localMediaStatus;
    if( stream ){
        this.setVideoEnabledAttribute( stream, status.video )
        this.setAudioEnabledAttribute( stream, status.audio )
    }
};


StreamHandler.fn.addRemote = function( peer, info ){
    var global = this.global;
    var emitter = this.emitter;

    emitter.emit("onRemoteStreamUpdate", info );
    var stream = info.stream;
    var streamEndedEvent = 'ended';
    if ('oninactive' in stream) {
        streamEndedEvent = 'inactive';
    }
    if(!peer.videoStreams){
        peer.videoStreams = {};
    }
    peer.videoStreams[info.videoId] = info.stream;
    emitter.emit("onStreamNotify",{
        isLocal: false,
        event: 'onadd',
        stream: stream,
        userId: info.userId,
        videoId: info.videoId,
        type: info.type
    })
    stream.addEventListener(streamEndedEvent , function(e){
        emitter.emit("onStreamNotify",{
            isLocal: false,
            event: streamEndedEvent,
            stream: stream,
            userId: info.userId,
            videoId: info.videoId,
            type: info.type
        })
    });
    stream.getTracks()[0].onended = function(event){
        emitter.emit("onStreamNotify",{
            isLocal: false,
            event: 'onended',
            stream: stream,
            userId: info.userId,
            videoId: info.videoId,
            type: info.type
        })
    }
};
StreamHandler.fn.setVideoEnabledAttribute = function( stream , enabled ){
    var tracks = stream.getVideoTracks();
    if( tracks && tracks.length > 0 ){
        for (var i = 0; i < tracks.length; i++) {
            tracks[i].enabled = enabled;
        }
    }
};
StreamHandler.fn.setAudioEnabledAttribute = function( stream , enabled ){
    var tracks = stream.getAudioTracks();
    if( tracks && tracks.length > 0 ){
        for (var i = 0; i < tracks.length; i++) {
            tracks[i].enabled = enabled;
        }
    }
};

StreamHandler.fn.parseStats = function( result ){
    /* 
    var videoData = {
        packetsSent: 0 , //发送的包
        packetsLost:0,  //发送的丢包数
        bytesSent: 0,   //发送的字节
        bytesReceived 
        frameRate: 
    }; */
    // to access native "results" array
    result.results.forEach(function(item) {
        if (item.type === 'ssrc' ) {
            var isVideo = item.mediaType === 'video'; // audio or video
            var isSender = item.id.indexOf('_send') !== -1; // sender or receiver
            if( isSender ){
                if( isVideo ){
                    result.video.ssrc = item.ssrc;//发送的包
                    result.video.codec = item.googCodecName;
                    result.video.packetsSent = item.packetsSent;//发送的包
                    result.video.packetsLost = item.packetsLost;  //发送的丢包数
                    result.video.width = item.googFrameWidthSent;
                    result.video.height = item.googFrameHeightSent;
                }else{
                    result.audio.ssrc = item.ssrc;//发送的包
                    result.audio.codec = item.googCodecName;
                    result.audio.packetsSent = item.packetsSent;//发送的包
                    result.audio.delay = item.googRtt  || 0;
                }
            }else{
                if( isVideo ){
                    result.video.ssrc = item.ssrc;//发送的包
                    result.video.codec = item.googCodecName;
                    result.video.packetsReceived = item.packetsReceived;//发送的包
                    result.video.packetsLost = item.packetsLost;  //发送的丢包数
                    result.video.width = item.googFrameWidthSent;
                    result.video.height = item.googFrameHeightSent;
                }else{
                    result.audio.ssrc = item.ssrc;//发送的包
                    result.audio.codec = item.googCodecName;
                    result.audio.packetsReceived = item.packetsReceived;//发送的包
                    result.audio.packetsLost = item.packetsLost;//发送的包
                    result.audio.delay = item.googRtt || 0;
                }
            }
        }
    });
    return result;
};



module.exports = StreamHandler;

/***/ }),
/* 41 */
/***/ (function(module, exports) {


var document = window.document,
    navigator = window.navigator,
    agent = navigator.userAgent.toLowerCase(),
//IE8+支持.返回浏览器渲染当前文档所用的模式
//IE6,IE7:undefined.IE8:8(兼容模式返回7).IE9:9(兼容模式返回7||8)
//IE10:10(兼容模式7||8||9)
    IEMode = document.documentMode,
//chorme
    chrome = window.chrome || false ,
    System = {
        //user-agent
        agent : agent,
        //是否为IE
        isIE : /msie/.test(agent),
        //是否为IE
        isIPhone : /iphone/.test(agent),
        //Gecko内核
        isGecko: agent.indexOf( "gecko" )> 0 && agent.indexOf( "like gecko" )< 0 ,
        //webkit内核
        isWebkit: agent.indexOf( "webkit" )> 0 ,
        //是否为标准模式
        isStrict: document.compatMode === "CSS1Compat" ,
        //是否支持subtitle
        supportSubTitle:function(){
            return "track" in document.createElement( "track" );
        },
        //是否支持scoped
        supportScope:function(){
            return "scoped" in document.createElement( "style" );
        },
        //获取IE的版本号
        ieVersion:function(){
            try {
                return agent.match(/msie ([\d.]+)/)[ 1 ] || 0 ;
            } catch (e) {
                return IEMode;
            }
        },
        //Opera版本号
        operaVersion:function(){
            try {
                if (window.opera) {
                    return agent.match(/opera.([\d.]+)/)[ 1 ];
                } else if (agent.indexOf( "opr" ) > 0 ) {
                    return agent.match(/opr\/([\d.]+)/)[ 1 ];
                }
            } catch (e) {
                
                return 0 ;
            }
        },
        //描述:version过滤.如31.0.252.152 只保留31.0
        versionFilter:function(){
            if (arguments.length === 1 && typeof arguments[ 0 ] === "string" ) {
                var version = arguments[ 0 ];
                start = version.indexOf( "." );
                if (start> 0 ){
                    end = version.indexOf( "." ,start+ 1 );
                    if (end !== - 1 ) {
                        return version.substr( 0 ,end);
                    }
                }
                return version;
            } else if (arguments.length === 1 ) {
                return arguments[ 0 ];
            }
            return 0 ;
        }
    };

try {
    //浏览器类型(IE、Opera、Chrome、Safari、Firefox)
    System.type = System.isIE? "ie" :
        window.opera || (agent.indexOf( "opr" ) > 0 )? "opera" :
            (agent.indexOf( "chrome" )> 0 )? "chrome" :
                //safari也提供了专门的判定方式
                window.openDatabase? "safari" :
                    (agent.indexOf( "firefox" )> 0 )? "firefox" :
                        'unknow' ;

    //版本号
    System.version = (System.type === "ie" )?System.ieVersion():
        (System.type === "firefox" )?agent.match(/firefox\/([\d.]+)/)[ 1 ]:
            (System.type === "chrome" )?agent.match(/chrome\/([\d.]+)/)[ 1 ]:
                (System.type === "opera" )?System.operaVersion():
                    (System.type === "safari" )?agent.match(/version\/([\d.]+)/)[ 1 ]:
                        "0" ;

    //浏览器外壳
    System.shell=function(){
        //遨游浏览器
        if (agent.indexOf( "maxthon" ) > 0 ) {
            System.version = agent.match(/maxthon\/([\d.]+)/)[ 1 ] || System.version ;
            return "maxthon" ;
        }
        //QQ浏览器
        if (agent.indexOf( "qqbrowser" ) > 0 ) {
            System.version = agent.match(/qqbrowser\/([\d.]+)/)[ 1 ] || System.version ;
            return "qqbrowser" ;
        }

        //搜狗浏览器
        if ( agent.indexOf( "se 2.x" )> 0 ) {
            return 'sougou' ;
        }

        //Chrome:也可以使用window.chrome && window.chrome.webstore判断
        if (chrome && System.type !== "opera" ) {
            var external = window.external,
                clientInfo = window.clientInformation,
            //客户端语言:zh-cn,zh.360下面会返回undefined
                clientLanguage = clientInfo.languages;

            //猎豹浏览器:或者agent.indexOf("lbbrowser")>0
            if ( external && 'LiebaoGetVersion' in external) {
                return 'liebao' ;
            }
            //百度浏览器
            if (agent.indexOf( "bidubrowser" )> 0 ) {
                System.version = agent.match(/bidubrowser\/([\d.]+)/)[ 1 ] ||
                    agent.match(/chrome\/([\d.]+)/)[ 1 ];
                return "baidu" ;
            }
            //360极速浏览器和360安全浏览器
            if ( System.supportSubTitle() && typeof clientLanguage === "undefined" ) {
                //object.key()返回一个数组.包含可枚举属性和方法名称
                var storeKeyLen = Object.keys(chrome.webstore).length,
                    v8Locale = "v8Locale" in window;
                return storeKeyLen > 1 ? '360qucik' : '360secure' ;
            }
            return "chrome" ;
        }
        return System.type;
    };

    //浏览器名称(如果是壳浏览器,则返回壳名称)
    System.name = System.shell();
    //对版本号进行过滤过处理
    System.version = System.versionFilter(System.version);

} catch (e) {
    
}

module.exports = {
    client: System
};

/***/ }),
/* 42 */
/***/ (function(module, exports) {

/*
WildEmitter.js is a slim little event emitter by @henrikjoreteg largely based
on @visionmedia's Emitter from UI Kit.

Why? I wanted it standalone.

I also wanted support for wildcard emitters like this:

emitter.on('*', function (eventName, other, event, payloads) {

});

emitter.on('somenamespace*', function (eventName, payloads) {

});

Please note that callbacks triggered by wildcard registered events also get
the event name as the first argument.
*/

module.exports = WildEmitter;

function WildEmitter() { }

WildEmitter.mixin = function (constructor) {
    var prototype = constructor.prototype || constructor;

    prototype.isWildEmitter= true;

    // Listen on the given `event` with `fn`. Store a group name if present.
    prototype.on = function (event, groupName, fn) {
        this.callbacks = this.callbacks || {};
        var hasGroup = (arguments.length === 3),
            group = hasGroup ? arguments[1] : undefined,
            func = hasGroup ? arguments[2] : arguments[1];
        func._groupName = group;
        (this.callbacks[event] = this.callbacks[event] || []).push(func);
        return this;
    };

    // Adds an `event` listener that will be invoked a single
    // time then automatically removed.
    prototype.once = function (event, groupName, fn) {
        var self = this,
            hasGroup = (arguments.length === 3),
            group = hasGroup ? arguments[1] : undefined,
            func = hasGroup ? arguments[2] : arguments[1];
        function on() {
            self.off(event, on);
            func.apply(this, arguments);
        }
        this.on(event, group, on);
        return this;
    };

    // Unbinds an entire group
    prototype.releaseGroup = function (groupName) {
        this.callbacks = this.callbacks || {};
        var item, i, len, handlers;
        for (item in this.callbacks) {
            handlers = this.callbacks[item];
            for (i = 0, len = handlers.length; i < len; i++) {
                if (handlers[i]._groupName === groupName) {
                    //console.log('removing');
                    // remove it and shorten the array we're looping through
                    handlers.splice(i, 1);
                    i--;
                    len--;
                }
            }
        }
        return this;
    };

    // Remove the given callback for `event` or all
    // registered callbacks.
    prototype.off = function (event, fn) {
        this.callbacks = this.callbacks || {};
        var callbacks = this.callbacks[event],
            i;

        if (!callbacks) return this;

        // remove all handlers
        if (arguments.length === 1) {
            delete this.callbacks[event];
            return this;
        }

        // remove specific handler
        i = callbacks.indexOf(fn);
        callbacks.splice(i, 1);
        if (callbacks.length === 0) {
            delete this.callbacks[event];
        }
        return this;
    };

    /// Emit `event` with the given args.
    // also calls any `*` handlers
    prototype.emit = function (event) {
        this.callbacks = this.callbacks || {};
        var args = [].slice.call(arguments, 1),
            callbacks = this.callbacks[event],
            specialCallbacks = this.getWildcardCallbacks(event),
            i,
            len,
            item,
            listeners;

        if (callbacks) {
            listeners = callbacks.slice();
            for (i = 0, len = listeners.length; i < len; ++i) {
                if (!listeners[i]) {
                    break;
                }
                listeners[i].apply(this, args);
            }
        }

        if (specialCallbacks) {
            len = specialCallbacks.length;
            listeners = specialCallbacks.slice();
            for (i = 0, len = listeners.length; i < len; ++i) {
                if (!listeners[i]) {
                    break;
                }
                listeners[i].apply(this, [event].concat(args));
            }
        }

        return this;
    };

    // Helper for for finding special wildcard event handlers that match the event
    prototype.getWildcardCallbacks = function (eventName) {
        this.callbacks = this.callbacks || {};
        var item,
            split,
            result = [];

        for (item in this.callbacks) {
            split = item.split('*');
            if (item === '*' || (split.length === 2 && eventName.slice(0, split[0].length) === split[0])) {
                result = result.concat(this.callbacks[item]);
            }
        }
        return result;
    };

};

WildEmitter.mixin(WildEmitter);


/***/ }),
/* 43 */
/***/ (function(module, exports, __webpack_require__) {

!function(n,e){ true?module.exports=e():"function"==typeof define&&define.amd?define(e):n.mitt=e()}(this,function(){function n(n){return n=n||Object.create(null),{on:function(e,t){(n[e]||(n[e]=[])).push(t)},off:function(e,t){n[e]&&n[e].splice(n[e].indexOf(t)>>>0,1)},emit:function(e,t){(n[e]||[]).slice().map(function(n){n(t)}),(n["*"]||[]).slice().map(function(n){n(e,t)})}}}return n});
//# sourceMappingURL=mitt.umd.js.map

/***/ }),
/* 44 */
/***/ (function(module, exports, __webpack_require__) {

/* WEBPACK VAR INJECTION */(function(global, module) {var __WEBPACK_AMD_DEFINE_RESULT__;/**
 * @license
 * Lodash (Custom Build) <https://lodash.com/>
 * Build: `lodash core -o ./dist/lodash.core.js`
 * Copyright JS Foundation and other contributors <https://js.foundation/>
 * Released under MIT license <https://lodash.com/license>
 * Based on Underscore.js 1.8.3 <http://underscorejs.org/LICENSE>
 * Copyright Jeremy Ashkenas, DocumentCloud and Investigative Reporters & Editors
 */
;(function() {

  /** Used as a safe reference for `undefined` in pre-ES5 environments. */
  var undefined;

  /** Used as the semantic version number. */
  var VERSION = '4.17.5';

  /** Error message constants. */
  var FUNC_ERROR_TEXT = 'Expected a function';

  /** Used to compose bitmasks for value comparisons. */
  var COMPARE_PARTIAL_FLAG = 1,
      COMPARE_UNORDERED_FLAG = 2;

  /** Used to compose bitmasks for function metadata. */
  var WRAP_BIND_FLAG = 1,
      WRAP_PARTIAL_FLAG = 32;

  /** Used as references for various `Number` constants. */
  var INFINITY = 1 / 0,
      MAX_SAFE_INTEGER = 9007199254740991;

  /** `Object#toString` result references. */
  var argsTag = '[object Arguments]',
      arrayTag = '[object Array]',
      asyncTag = '[object AsyncFunction]',
      boolTag = '[object Boolean]',
      dateTag = '[object Date]',
      errorTag = '[object Error]',
      funcTag = '[object Function]',
      genTag = '[object GeneratorFunction]',
      numberTag = '[object Number]',
      objectTag = '[object Object]',
      proxyTag = '[object Proxy]',
      regexpTag = '[object RegExp]',
      stringTag = '[object String]';

  /** Used to match HTML entities and HTML characters. */
  var reUnescapedHtml = /[&<>"']/g,
      reHasUnescapedHtml = RegExp(reUnescapedHtml.source);

  /** Used to detect unsigned integer values. */
  var reIsUint = /^(?:0|[1-9]\d*)$/;

  /** Used to map characters to HTML entities. */
  var htmlEscapes = {
    '&': '&amp;',
    '<': '&lt;',
    '>': '&gt;',
    '"': '&quot;',
    "'": '&#39;'
  };

  /** Detect free variable `global` from Node.js. */
  var freeGlobal = typeof global == 'object' && global && global.Object === Object && global;

  /** Detect free variable `self`. */
  var freeSelf = typeof self == 'object' && self && self.Object === Object && self;

  /** Used as a reference to the global object. */
  var root = freeGlobal || freeSelf || Function('return this')();

  /** Detect free variable `exports`. */
  var freeExports = typeof exports == 'object' && exports && !exports.nodeType && exports;

  /** Detect free variable `module`. */
  var freeModule = freeExports && typeof module == 'object' && module && !module.nodeType && module;

  /*--------------------------------------------------------------------------*/

  /**
   * Appends the elements of `values` to `array`.
   *
   * @private
   * @param {Array} array The array to modify.
   * @param {Array} values The values to append.
   * @returns {Array} Returns `array`.
   */
  function arrayPush(array, values) {
    array.push.apply(array, values);
    return array;
  }

  /**
   * The base implementation of `_.findIndex` and `_.findLastIndex` without
   * support for iteratee shorthands.
   *
   * @private
   * @param {Array} array The array to inspect.
   * @param {Function} predicate The function invoked per iteration.
   * @param {number} fromIndex The index to search from.
   * @param {boolean} [fromRight] Specify iterating from right to left.
   * @returns {number} Returns the index of the matched value, else `-1`.
   */
  function baseFindIndex(array, predicate, fromIndex, fromRight) {
    var length = array.length,
        index = fromIndex + (fromRight ? 1 : -1);

    while ((fromRight ? index-- : ++index < length)) {
      if (predicate(array[index], index, array)) {
        return index;
      }
    }
    return -1;
  }

  /**
   * The base implementation of `_.property` without support for deep paths.
   *
   * @private
   * @param {string} key The key of the property to get.
   * @returns {Function} Returns the new accessor function.
   */
  function baseProperty(key) {
    return function(object) {
      return object == null ? undefined : object[key];
    };
  }

  /**
   * The base implementation of `_.propertyOf` without support for deep paths.
   *
   * @private
   * @param {Object} object The object to query.
   * @returns {Function} Returns the new accessor function.
   */
  function basePropertyOf(object) {
    return function(key) {
      return object == null ? undefined : object[key];
    };
  }

  /**
   * The base implementation of `_.reduce` and `_.reduceRight`, without support
   * for iteratee shorthands, which iterates over `collection` using `eachFunc`.
   *
   * @private
   * @param {Array|Object} collection The collection to iterate over.
   * @param {Function} iteratee The function invoked per iteration.
   * @param {*} accumulator The initial value.
   * @param {boolean} initAccum Specify using the first or last element of
   *  `collection` as the initial value.
   * @param {Function} eachFunc The function to iterate over `collection`.
   * @returns {*} Returns the accumulated value.
   */
  function baseReduce(collection, iteratee, accumulator, initAccum, eachFunc) {
    eachFunc(collection, function(value, index, collection) {
      accumulator = initAccum
        ? (initAccum = false, value)
        : iteratee(accumulator, value, index, collection);
    });
    return accumulator;
  }

  /**
   * The base implementation of `_.values` and `_.valuesIn` which creates an
   * array of `object` property values corresponding to the property names
   * of `props`.
   *
   * @private
   * @param {Object} object The object to query.
   * @param {Array} props The property names to get values for.
   * @returns {Object} Returns the array of property values.
   */
  function baseValues(object, props) {
    return baseMap(props, function(key) {
      return object[key];
    });
  }

  /**
   * Used by `_.escape` to convert characters to HTML entities.
   *
   * @private
   * @param {string} chr The matched character to escape.
   * @returns {string} Returns the escaped character.
   */
  var escapeHtmlChar = basePropertyOf(htmlEscapes);

  /**
   * Creates a unary function that invokes `func` with its argument transformed.
   *
   * @private
   * @param {Function} func The function to wrap.
   * @param {Function} transform The argument transform.
   * @returns {Function} Returns the new function.
   */
  function overArg(func, transform) {
    return function(arg) {
      return func(transform(arg));
    };
  }

  /*--------------------------------------------------------------------------*/

  /** Used for built-in method references. */
  var arrayProto = Array.prototype,
      objectProto = Object.prototype;

  /** Used to check objects for own properties. */
  var hasOwnProperty = objectProto.hasOwnProperty;

  /** Used to generate unique IDs. */
  var idCounter = 0;

  /**
   * Used to resolve the
   * [`toStringTag`](http://ecma-international.org/ecma-262/7.0/#sec-object.prototype.tostring)
   * of values.
   */
  var nativeObjectToString = objectProto.toString;

  /** Used to restore the original `_` reference in `_.noConflict`. */
  var oldDash = root._;

  /** Built-in value references. */
  var objectCreate = Object.create,
      propertyIsEnumerable = objectProto.propertyIsEnumerable;

  /* Built-in method references for those with the same name as other `lodash` methods. */
  var nativeIsFinite = root.isFinite,
      nativeKeys = overArg(Object.keys, Object),
      nativeMax = Math.max;

  /*------------------------------------------------------------------------*/

  /**
   * Creates a `lodash` object which wraps `value` to enable implicit method
   * chain sequences. Methods that operate on and return arrays, collections,
   * and functions can be chained together. Methods that retrieve a single value
   * or may return a primitive value will automatically end the chain sequence
   * and return the unwrapped value. Otherwise, the value must be unwrapped
   * with `_#value`.
   *
   * Explicit chain sequences, which must be unwrapped with `_#value`, may be
   * enabled using `_.chain`.
   *
   * The execution of chained methods is lazy, that is, it's deferred until
   * `_#value` is implicitly or explicitly called.
   *
   * Lazy evaluation allows several methods to support shortcut fusion.
   * Shortcut fusion is an optimization to merge iteratee calls; this avoids
   * the creation of intermediate arrays and can greatly reduce the number of
   * iteratee executions. Sections of a chain sequence qualify for shortcut
   * fusion if the section is applied to an array and iteratees accept only
   * one argument. The heuristic for whether a section qualifies for shortcut
   * fusion is subject to change.
   *
   * Chaining is supported in custom builds as long as the `_#value` method is
   * directly or indirectly included in the build.
   *
   * In addition to lodash methods, wrappers have `Array` and `String` methods.
   *
   * The wrapper `Array` methods are:
   * `concat`, `join`, `pop`, `push`, `shift`, `sort`, `splice`, and `unshift`
   *
   * The wrapper `String` methods are:
   * `replace` and `split`
   *
   * The wrapper methods that support shortcut fusion are:
   * `at`, `compact`, `drop`, `dropRight`, `dropWhile`, `filter`, `find`,
   * `findLast`, `head`, `initial`, `last`, `map`, `reject`, `reverse`, `slice`,
   * `tail`, `take`, `takeRight`, `takeRightWhile`, `takeWhile`, and `toArray`
   *
   * The chainable wrapper methods are:
   * `after`, `ary`, `assign`, `assignIn`, `assignInWith`, `assignWith`, `at`,
   * `before`, `bind`, `bindAll`, `bindKey`, `castArray`, `chain`, `chunk`,
   * `commit`, `compact`, `concat`, `conforms`, `constant`, `countBy`, `create`,
   * `curry`, `debounce`, `defaults`, `defaultsDeep`, `defer`, `delay`,
   * `difference`, `differenceBy`, `differenceWith`, `drop`, `dropRight`,
   * `dropRightWhile`, `dropWhile`, `extend`, `extendWith`, `fill`, `filter`,
   * `flatMap`, `flatMapDeep`, `flatMapDepth`, `flatten`, `flattenDeep`,
   * `flattenDepth`, `flip`, `flow`, `flowRight`, `fromPairs`, `functions`,
   * `functionsIn`, `groupBy`, `initial`, `intersection`, `intersectionBy`,
   * `intersectionWith`, `invert`, `invertBy`, `invokeMap`, `iteratee`, `keyBy`,
   * `keys`, `keysIn`, `map`, `mapKeys`, `mapValues`, `matches`, `matchesProperty`,
   * `memoize`, `merge`, `mergeWith`, `method`, `methodOf`, `mixin`, `negate`,
   * `nthArg`, `omit`, `omitBy`, `once`, `orderBy`, `over`, `overArgs`,
   * `overEvery`, `overSome`, `partial`, `partialRight`, `partition`, `pick`,
   * `pickBy`, `plant`, `property`, `propertyOf`, `pull`, `pullAll`, `pullAllBy`,
   * `pullAllWith`, `pullAt`, `push`, `range`, `rangeRight`, `rearg`, `reject`,
   * `remove`, `rest`, `reverse`, `sampleSize`, `set`, `setWith`, `shuffle`,
   * `slice`, `sort`, `sortBy`, `splice`, `spread`, `tail`, `take`, `takeRight`,
   * `takeRightWhile`, `takeWhile`, `tap`, `throttle`, `thru`, `toArray`,
   * `toPairs`, `toPairsIn`, `toPath`, `toPlainObject`, `transform`, `unary`,
   * `union`, `unionBy`, `unionWith`, `uniq`, `uniqBy`, `uniqWith`, `unset`,
   * `unshift`, `unzip`, `unzipWith`, `update`, `updateWith`, `values`,
   * `valuesIn`, `without`, `wrap`, `xor`, `xorBy`, `xorWith`, `zip`,
   * `zipObject`, `zipObjectDeep`, and `zipWith`
   *
   * The wrapper methods that are **not** chainable by default are:
   * `add`, `attempt`, `camelCase`, `capitalize`, `ceil`, `clamp`, `clone`,
   * `cloneDeep`, `cloneDeepWith`, `cloneWith`, `conformsTo`, `deburr`,
   * `defaultTo`, `divide`, `each`, `eachRight`, `endsWith`, `eq`, `escape`,
   * `escapeRegExp`, `every`, `find`, `findIndex`, `findKey`, `findLast`,
   * `findLastIndex`, `findLastKey`, `first`, `floor`, `forEach`, `forEachRight`,
   * `forIn`, `forInRight`, `forOwn`, `forOwnRight`, `get`, `gt`, `gte`, `has`,
   * `hasIn`, `head`, `identity`, `includes`, `indexOf`, `inRange`, `invoke`,
   * `isArguments`, `isArray`, `isArrayBuffer`, `isArrayLike`, `isArrayLikeObject`,
   * `isBoolean`, `isBuffer`, `isDate`, `isElement`, `isEmpty`, `isEqual`,
   * `isEqualWith`, `isError`, `isFinite`, `isFunction`, `isInteger`, `isLength`,
   * `isMap`, `isMatch`, `isMatchWith`, `isNaN`, `isNative`, `isNil`, `isNull`,
   * `isNumber`, `isObject`, `isObjectLike`, `isPlainObject`, `isRegExp`,
   * `isSafeInteger`, `isSet`, `isString`, `isUndefined`, `isTypedArray`,
   * `isWeakMap`, `isWeakSet`, `join`, `kebabCase`, `last`, `lastIndexOf`,
   * `lowerCase`, `lowerFirst`, `lt`, `lte`, `max`, `maxBy`, `mean`, `meanBy`,
   * `min`, `minBy`, `multiply`, `noConflict`, `noop`, `now`, `nth`, `pad`,
   * `padEnd`, `padStart`, `parseInt`, `pop`, `random`, `reduce`, `reduceRight`,
   * `repeat`, `result`, `round`, `runInContext`, `sample`, `shift`, `size`,
   * `snakeCase`, `some`, `sortedIndex`, `sortedIndexBy`, `sortedLastIndex`,
   * `sortedLastIndexBy`, `startCase`, `startsWith`, `stubArray`, `stubFalse`,
   * `stubObject`, `stubString`, `stubTrue`, `subtract`, `sum`, `sumBy`,
   * `template`, `times`, `toFinite`, `toInteger`, `toJSON`, `toLength`,
   * `toLower`, `toNumber`, `toSafeInteger`, `toString`, `toUpper`, `trim`,
   * `trimEnd`, `trimStart`, `truncate`, `unescape`, `uniqueId`, `upperCase`,
   * `upperFirst`, `value`, and `words`
   *
   * @name _
   * @constructor
   * @category Seq
   * @param {*} value The value to wrap in a `lodash` instance.
   * @returns {Object} Returns the new `lodash` wrapper instance.
   * @example
   *
   * function square(n) {
   *   return n * n;
   * }
   *
   * var wrapped = _([1, 2, 3]);
   *
   * // Returns an unwrapped value.
   * wrapped.reduce(_.add);
   * // => 6
   *
   * // Returns a wrapped value.
   * var squares = wrapped.map(square);
   *
   * _.isArray(squares);
   * // => false
   *
   * _.isArray(squares.value());
   * // => true
   */
  function lodash(value) {
    return value instanceof LodashWrapper
      ? value
      : new LodashWrapper(value);
  }

  /**
   * The base implementation of `_.create` without support for assigning
   * properties to the created object.
   *
   * @private
   * @param {Object} proto The object to inherit from.
   * @returns {Object} Returns the new object.
   */
  var baseCreate = (function() {
    function object() {}
    return function(proto) {
      if (!isObject(proto)) {
        return {};
      }
      if (objectCreate) {
        return objectCreate(proto);
      }
      object.prototype = proto;
      var result = new object;
      object.prototype = undefined;
      return result;
    };
  }());

  /**
   * The base constructor for creating `lodash` wrapper objects.
   *
   * @private
   * @param {*} value The value to wrap.
   * @param {boolean} [chainAll] Enable explicit method chain sequences.
   */
  function LodashWrapper(value, chainAll) {
    this.__wrapped__ = value;
    this.__actions__ = [];
    this.__chain__ = !!chainAll;
  }

  LodashWrapper.prototype = baseCreate(lodash.prototype);
  LodashWrapper.prototype.constructor = LodashWrapper;

  /*------------------------------------------------------------------------*/

  /**
   * Assigns `value` to `key` of `object` if the existing value is not equivalent
   * using [`SameValueZero`](http://ecma-international.org/ecma-262/7.0/#sec-samevaluezero)
   * for equality comparisons.
   *
   * @private
   * @param {Object} object The object to modify.
   * @param {string} key The key of the property to assign.
   * @param {*} value The value to assign.
   */
  function assignValue(object, key, value) {
    var objValue = object[key];
    if (!(hasOwnProperty.call(object, key) && eq(objValue, value)) ||
        (value === undefined && !(key in object))) {
      baseAssignValue(object, key, value);
    }
  }

  /**
   * The base implementation of `assignValue` and `assignMergeValue` without
   * value checks.
   *
   * @private
   * @param {Object} object The object to modify.
   * @param {string} key The key of the property to assign.
   * @param {*} value The value to assign.
   */
  function baseAssignValue(object, key, value) {
    object[key] = value;
  }

  /**
   * The base implementation of `_.delay` and `_.defer` which accepts `args`
   * to provide to `func`.
   *
   * @private
   * @param {Function} func The function to delay.
   * @param {number} wait The number of milliseconds to delay invocation.
   * @param {Array} args The arguments to provide to `func`.
   * @returns {number|Object} Returns the timer id or timeout object.
   */
  function baseDelay(func, wait, args) {
    if (typeof func != 'function') {
      throw new TypeError(FUNC_ERROR_TEXT);
    }
    return setTimeout(function() { func.apply(undefined, args); }, wait);
  }

  /**
   * The base implementation of `_.forEach` without support for iteratee shorthands.
   *
   * @private
   * @param {Array|Object} collection The collection to iterate over.
   * @param {Function} iteratee The function invoked per iteration.
   * @returns {Array|Object} Returns `collection`.
   */
  var baseEach = createBaseEach(baseForOwn);

  /**
   * The base implementation of `_.every` without support for iteratee shorthands.
   *
   * @private
   * @param {Array|Object} collection The collection to iterate over.
   * @param {Function} predicate The function invoked per iteration.
   * @returns {boolean} Returns `true` if all elements pass the predicate check,
   *  else `false`
   */
  function baseEvery(collection, predicate) {
    var result = true;
    baseEach(collection, function(value, index, collection) {
      result = !!predicate(value, index, collection);
      return result;
    });
    return result;
  }

  /**
   * The base implementation of methods like `_.max` and `_.min` which accepts a
   * `comparator` to determine the extremum value.
   *
   * @private
   * @param {Array} array The array to iterate over.
   * @param {Function} iteratee The iteratee invoked per iteration.
   * @param {Function} comparator The comparator used to compare values.
   * @returns {*} Returns the extremum value.
   */
  function baseExtremum(array, iteratee, comparator) {
    var index = -1,
        length = array.length;

    while (++index < length) {
      var value = array[index],
          current = iteratee(value);

      if (current != null && (computed === undefined
            ? (current === current && !false)
            : comparator(current, computed)
          )) {
        var computed = current,
            result = value;
      }
    }
    return result;
  }

  /**
   * The base implementation of `_.filter` without support for iteratee shorthands.
   *
   * @private
   * @param {Array|Object} collection The collection to iterate over.
   * @param {Function} predicate The function invoked per iteration.
   * @returns {Array} Returns the new filtered array.
   */
  function baseFilter(collection, predicate) {
    var result = [];
    baseEach(collection, function(value, index, collection) {
      if (predicate(value, index, collection)) {
        result.push(value);
      }
    });
    return result;
  }

  /**
   * The base implementation of `_.flatten` with support for restricting flattening.
   *
   * @private
   * @param {Array} array The array to flatten.
   * @param {number} depth The maximum recursion depth.
   * @param {boolean} [predicate=isFlattenable] The function invoked per iteration.
   * @param {boolean} [isStrict] Restrict to values that pass `predicate` checks.
   * @param {Array} [result=[]] The initial result value.
   * @returns {Array} Returns the new flattened array.
   */
  function baseFlatten(array, depth, predicate, isStrict, result) {
    var index = -1,
        length = array.length;

    predicate || (predicate = isFlattenable);
    result || (result = []);

    while (++index < length) {
      var value = array[index];
      if (depth > 0 && predicate(value)) {
        if (depth > 1) {
          // Recursively flatten arrays (susceptible to call stack limits).
          baseFlatten(value, depth - 1, predicate, isStrict, result);
        } else {
          arrayPush(result, value);
        }
      } else if (!isStrict) {
        result[result.length] = value;
      }
    }
    return result;
  }

  /**
   * The base implementation of `baseForOwn` which iterates over `object`
   * properties returned by `keysFunc` and invokes `iteratee` for each property.
   * Iteratee functions may exit iteration early by explicitly returning `false`.
   *
   * @private
   * @param {Object} object The object to iterate over.
   * @param {Function} iteratee The function invoked per iteration.
   * @param {Function} keysFunc The function to get the keys of `object`.
   * @returns {Object} Returns `object`.
   */
  var baseFor = createBaseFor();

  /**
   * The base implementation of `_.forOwn` without support for iteratee shorthands.
   *
   * @private
   * @param {Object} object The object to iterate over.
   * @param {Function} iteratee The function invoked per iteration.
   * @returns {Object} Returns `object`.
   */
  function baseForOwn(object, iteratee) {
    return object && baseFor(object, iteratee, keys);
  }

  /**
   * The base implementation of `_.functions` which creates an array of
   * `object` function property names filtered from `props`.
   *
   * @private
   * @param {Object} object The object to inspect.
   * @param {Array} props The property names to filter.
   * @returns {Array} Returns the function names.
   */
  function baseFunctions(object, props) {
    return baseFilter(props, function(key) {
      return isFunction(object[key]);
    });
  }

  /**
   * The base implementation of `getTag` without fallbacks for buggy environments.
   *
   * @private
   * @param {*} value The value to query.
   * @returns {string} Returns the `toStringTag`.
   */
  function baseGetTag(value) {
    return objectToString(value);
  }

  /**
   * The base implementation of `_.gt` which doesn't coerce arguments.
   *
   * @private
   * @param {*} value The value to compare.
   * @param {*} other The other value to compare.
   * @returns {boolean} Returns `true` if `value` is greater than `other`,
   *  else `false`.
   */
  function baseGt(value, other) {
    return value > other;
  }

  /**
   * The base implementation of `_.isArguments`.
   *
   * @private
   * @param {*} value The value to check.
   * @returns {boolean} Returns `true` if `value` is an `arguments` object,
   */
  var baseIsArguments = noop;

  /**
   * The base implementation of `_.isDate` without Node.js optimizations.
   *
   * @private
   * @param {*} value The value to check.
   * @returns {boolean} Returns `true` if `value` is a date object, else `false`.
   */
  function baseIsDate(value) {
    return isObjectLike(value) && baseGetTag(value) == dateTag;
  }

  /**
   * The base implementation of `_.isEqual` which supports partial comparisons
   * and tracks traversed objects.
   *
   * @private
   * @param {*} value The value to compare.
   * @param {*} other The other value to compare.
   * @param {boolean} bitmask The bitmask flags.
   *  1 - Unordered comparison
   *  2 - Partial comparison
   * @param {Function} [customizer] The function to customize comparisons.
   * @param {Object} [stack] Tracks traversed `value` and `other` objects.
   * @returns {boolean} Returns `true` if the values are equivalent, else `false`.
   */
  function baseIsEqual(value, other, bitmask, customizer, stack) {
    if (value === other) {
      return true;
    }
    if (value == null || other == null || (!isObjectLike(value) && !isObjectLike(other))) {
      return value !== value && other !== other;
    }
    return baseIsEqualDeep(value, other, bitmask, customizer, baseIsEqual, stack);
  }

  /**
   * A specialized version of `baseIsEqual` for arrays and objects which performs
   * deep comparisons and tracks traversed objects enabling objects with circular
   * references to be compared.
   *
   * @private
   * @param {Object} object The object to compare.
   * @param {Object} other The other object to compare.
   * @param {number} bitmask The bitmask flags. See `baseIsEqual` for more details.
   * @param {Function} customizer The function to customize comparisons.
   * @param {Function} equalFunc The function to determine equivalents of values.
   * @param {Object} [stack] Tracks traversed `object` and `other` objects.
   * @returns {boolean} Returns `true` if the objects are equivalent, else `false`.
   */
  function baseIsEqualDeep(object, other, bitmask, customizer, equalFunc, stack) {
    var objIsArr = isArray(object),
        othIsArr = isArray(other),
        objTag = objIsArr ? arrayTag : baseGetTag(object),
        othTag = othIsArr ? arrayTag : baseGetTag(other);

    objTag = objTag == argsTag ? objectTag : objTag;
    othTag = othTag == argsTag ? objectTag : othTag;

    var objIsObj = objTag == objectTag,
        othIsObj = othTag == objectTag,
        isSameTag = objTag == othTag;

    stack || (stack = []);
    var objStack = find(stack, function(entry) {
      return entry[0] == object;
    });
    var othStack = find(stack, function(entry) {
      return entry[0] == other;
    });
    if (objStack && othStack) {
      return objStack[1] == other;
    }
    stack.push([object, other]);
    stack.push([other, object]);
    if (isSameTag && !objIsObj) {
      var result = (objIsArr)
        ? equalArrays(object, other, bitmask, customizer, equalFunc, stack)
        : equalByTag(object, other, objTag, bitmask, customizer, equalFunc, stack);
      stack.pop();
      return result;
    }
    if (!(bitmask & COMPARE_PARTIAL_FLAG)) {
      var objIsWrapped = objIsObj && hasOwnProperty.call(object, '__wrapped__'),
          othIsWrapped = othIsObj && hasOwnProperty.call(other, '__wrapped__');

      if (objIsWrapped || othIsWrapped) {
        var objUnwrapped = objIsWrapped ? object.value() : object,
            othUnwrapped = othIsWrapped ? other.value() : other;

        var result = equalFunc(objUnwrapped, othUnwrapped, bitmask, customizer, stack);
        stack.pop();
        return result;
      }
    }
    if (!isSameTag) {
      return false;
    }
    var result = equalObjects(object, other, bitmask, customizer, equalFunc, stack);
    stack.pop();
    return result;
  }

  /**
   * The base implementation of `_.isRegExp` without Node.js optimizations.
   *
   * @private
   * @param {*} value The value to check.
   * @returns {boolean} Returns `true` if `value` is a regexp, else `false`.
   */
  function baseIsRegExp(value) {
    return isObjectLike(value) && baseGetTag(value) == regexpTag;
  }

  /**
   * The base implementation of `_.iteratee`.
   *
   * @private
   * @param {*} [value=_.identity] The value to convert to an iteratee.
   * @returns {Function} Returns the iteratee.
   */
  function baseIteratee(func) {
    if (typeof func == 'function') {
      return func;
    }
    if (func == null) {
      return identity;
    }
    return (typeof func == 'object' ? baseMatches : baseProperty)(func);
  }

  /**
   * The base implementation of `_.lt` which doesn't coerce arguments.
   *
   * @private
   * @param {*} value The value to compare.
   * @param {*} other The other value to compare.
   * @returns {boolean} Returns `true` if `value` is less than `other`,
   *  else `false`.
   */
  function baseLt(value, other) {
    return value < other;
  }

  /**
   * The base implementation of `_.map` without support for iteratee shorthands.
   *
   * @private
   * @param {Array|Object} collection The collection to iterate over.
   * @param {Function} iteratee The function invoked per iteration.
   * @returns {Array} Returns the new mapped array.
   */
  function baseMap(collection, iteratee) {
    var index = -1,
        result = isArrayLike(collection) ? Array(collection.length) : [];

    baseEach(collection, function(value, key, collection) {
      result[++index] = iteratee(value, key, collection);
    });
    return result;
  }

  /**
   * The base implementation of `_.matches` which doesn't clone `source`.
   *
   * @private
   * @param {Object} source The object of property values to match.
   * @returns {Function} Returns the new spec function.
   */
  function baseMatches(source) {
    var props = nativeKeys(source);
    return function(object) {
      var length = props.length;
      if (object == null) {
        return !length;
      }
      object = Object(object);
      while (length--) {
        var key = props[length];
        if (!(key in object &&
              baseIsEqual(source[key], object[key], COMPARE_PARTIAL_FLAG | COMPARE_UNORDERED_FLAG)
            )) {
          return false;
        }
      }
      return true;
    };
  }

  /**
   * The base implementation of `_.pick` without support for individual
   * property identifiers.
   *
   * @private
   * @param {Object} object The source object.
   * @param {string[]} paths The property paths to pick.
   * @returns {Object} Returns the new object.
   */
  function basePick(object, props) {
    object = Object(object);
    return reduce(props, function(result, key) {
      if (key in object) {
        result[key] = object[key];
      }
      return result;
    }, {});
  }

  /**
   * The base implementation of `_.rest` which doesn't validate or coerce arguments.
   *
   * @private
   * @param {Function} func The function to apply a rest parameter to.
   * @param {number} [start=func.length-1] The start position of the rest parameter.
   * @returns {Function} Returns the new function.
   */
  function baseRest(func, start) {
    return setToString(overRest(func, start, identity), func + '');
  }

  /**
   * The base implementation of `_.slice` without an iteratee call guard.
   *
   * @private
   * @param {Array} array The array to slice.
   * @param {number} [start=0] The start position.
   * @param {number} [end=array.length] The end position.
   * @returns {Array} Returns the slice of `array`.
   */
  function baseSlice(array, start, end) {
    var index = -1,
        length = array.length;

    if (start < 0) {
      start = -start > length ? 0 : (length + start);
    }
    end = end > length ? length : end;
    if (end < 0) {
      end += length;
    }
    length = start > end ? 0 : ((end - start) >>> 0);
    start >>>= 0;

    var result = Array(length);
    while (++index < length) {
      result[index] = array[index + start];
    }
    return result;
  }

  /**
   * Copies the values of `source` to `array`.
   *
   * @private
   * @param {Array} source The array to copy values from.
   * @param {Array} [array=[]] The array to copy values to.
   * @returns {Array} Returns `array`.
   */
  function copyArray(source) {
    return baseSlice(source, 0, source.length);
  }

  /**
   * The base implementation of `_.some` without support for iteratee shorthands.
   *
   * @private
   * @param {Array|Object} collection The collection to iterate over.
   * @param {Function} predicate The function invoked per iteration.
   * @returns {boolean} Returns `true` if any element passes the predicate check,
   *  else `false`.
   */
  function baseSome(collection, predicate) {
    var result;

    baseEach(collection, function(value, index, collection) {
      result = predicate(value, index, collection);
      return !result;
    });
    return !!result;
  }

  /**
   * The base implementation of `wrapperValue` which returns the result of
   * performing a sequence of actions on the unwrapped `value`, where each
   * successive action is supplied the return value of the previous.
   *
   * @private
   * @param {*} value The unwrapped value.
   * @param {Array} actions Actions to perform to resolve the unwrapped value.
   * @returns {*} Returns the resolved value.
   */
  function baseWrapperValue(value, actions) {
    var result = value;
    return reduce(actions, function(result, action) {
      return action.func.apply(action.thisArg, arrayPush([result], action.args));
    }, result);
  }

  /**
   * Compares values to sort them in ascending order.
   *
   * @private
   * @param {*} value The value to compare.
   * @param {*} other The other value to compare.
   * @returns {number} Returns the sort order indicator for `value`.
   */
  function compareAscending(value, other) {
    if (value !== other) {
      var valIsDefined = value !== undefined,
          valIsNull = value === null,
          valIsReflexive = value === value,
          valIsSymbol = false;

      var othIsDefined = other !== undefined,
          othIsNull = other === null,
          othIsReflexive = other === other,
          othIsSymbol = false;

      if ((!othIsNull && !othIsSymbol && !valIsSymbol && value > other) ||
          (valIsSymbol && othIsDefined && othIsReflexive && !othIsNull && !othIsSymbol) ||
          (valIsNull && othIsDefined && othIsReflexive) ||
          (!valIsDefined && othIsReflexive) ||
          !valIsReflexive) {
        return 1;
      }
      if ((!valIsNull && !valIsSymbol && !othIsSymbol && value < other) ||
          (othIsSymbol && valIsDefined && valIsReflexive && !valIsNull && !valIsSymbol) ||
          (othIsNull && valIsDefined && valIsReflexive) ||
          (!othIsDefined && valIsReflexive) ||
          !othIsReflexive) {
        return -1;
      }
    }
    return 0;
  }

  /**
   * Copies properties of `source` to `object`.
   *
   * @private
   * @param {Object} source The object to copy properties from.
   * @param {Array} props The property identifiers to copy.
   * @param {Object} [object={}] The object to copy properties to.
   * @param {Function} [customizer] The function to customize copied values.
   * @returns {Object} Returns `object`.
   */
  function copyObject(source, props, object, customizer) {
    var isNew = !object;
    object || (object = {});

    var index = -1,
        length = props.length;

    while (++index < length) {
      var key = props[index];

      var newValue = customizer
        ? customizer(object[key], source[key], key, object, source)
        : undefined;

      if (newValue === undefined) {
        newValue = source[key];
      }
      if (isNew) {
        baseAssignValue(object, key, newValue);
      } else {
        assignValue(object, key, newValue);
      }
    }
    return object;
  }

  /**
   * Creates a function like `_.assign`.
   *
   * @private
   * @param {Function} assigner The function to assign values.
   * @returns {Function} Returns the new assigner function.
   */
  function createAssigner(assigner) {
    return baseRest(function(object, sources) {
      var index = -1,
          length = sources.length,
          customizer = length > 1 ? sources[length - 1] : undefined;

      customizer = (assigner.length > 3 && typeof customizer == 'function')
        ? (length--, customizer)
        : undefined;

      object = Object(object);
      while (++index < length) {
        var source = sources[index];
        if (source) {
          assigner(object, source, index, customizer);
        }
      }
      return object;
    });
  }

  /**
   * Creates a `baseEach` or `baseEachRight` function.
   *
   * @private
   * @param {Function} eachFunc The function to iterate over a collection.
   * @param {boolean} [fromRight] Specify iterating from right to left.
   * @returns {Function} Returns the new base function.
   */
  function createBaseEach(eachFunc, fromRight) {
    return function(collection, iteratee) {
      if (collection == null) {
        return collection;
      }
      if (!isArrayLike(collection)) {
        return eachFunc(collection, iteratee);
      }
      var length = collection.length,
          index = fromRight ? length : -1,
          iterable = Object(collection);

      while ((fromRight ? index-- : ++index < length)) {
        if (iteratee(iterable[index], index, iterable) === false) {
          break;
        }
      }
      return collection;
    };
  }

  /**
   * Creates a base function for methods like `_.forIn` and `_.forOwn`.
   *
   * @private
   * @param {boolean} [fromRight] Specify iterating from right to left.
   * @returns {Function} Returns the new base function.
   */
  function createBaseFor(fromRight) {
    return function(object, iteratee, keysFunc) {
      var index = -1,
          iterable = Object(object),
          props = keysFunc(object),
          length = props.length;

      while (length--) {
        var key = props[fromRight ? length : ++index];
        if (iteratee(iterable[key], key, iterable) === false) {
          break;
        }
      }
      return object;
    };
  }

  /**
   * Creates a function that produces an instance of `Ctor` regardless of
   * whether it was invoked as part of a `new` expression or by `call` or `apply`.
   *
   * @private
   * @param {Function} Ctor The constructor to wrap.
   * @returns {Function} Returns the new wrapped function.
   */
  function createCtor(Ctor) {
    return function() {
      // Use a `switch` statement to work with class constructors. See
      // http://ecma-international.org/ecma-262/7.0/#sec-ecmascript-function-objects-call-thisargument-argumentslist
      // for more details.
      var args = arguments;
      var thisBinding = baseCreate(Ctor.prototype),
          result = Ctor.apply(thisBinding, args);

      // Mimic the constructor's `return` behavior.
      // See https://es5.github.io/#x13.2.2 for more details.
      return isObject(result) ? result : thisBinding;
    };
  }

  /**
   * Creates a `_.find` or `_.findLast` function.
   *
   * @private
   * @param {Function} findIndexFunc The function to find the collection index.
   * @returns {Function} Returns the new find function.
   */
  function createFind(findIndexFunc) {
    return function(collection, predicate, fromIndex) {
      var iterable = Object(collection);
      if (!isArrayLike(collection)) {
        var iteratee = baseIteratee(predicate, 3);
        collection = keys(collection);
        predicate = function(key) { return iteratee(iterable[key], key, iterable); };
      }
      var index = findIndexFunc(collection, predicate, fromIndex);
      return index > -1 ? iterable[iteratee ? collection[index] : index] : undefined;
    };
  }

  /**
   * Creates a function that wraps `func` to invoke it with the `this` binding
   * of `thisArg` and `partials` prepended to the arguments it receives.
   *
   * @private
   * @param {Function} func The function to wrap.
   * @param {number} bitmask The bitmask flags. See `createWrap` for more details.
   * @param {*} thisArg The `this` binding of `func`.
   * @param {Array} partials The arguments to prepend to those provided to
   *  the new function.
   * @returns {Function} Returns the new wrapped function.
   */
  function createPartial(func, bitmask, thisArg, partials) {
    if (typeof func != 'function') {
      throw new TypeError(FUNC_ERROR_TEXT);
    }
    var isBind = bitmask & WRAP_BIND_FLAG,
        Ctor = createCtor(func);

    function wrapper() {
      var argsIndex = -1,
          argsLength = arguments.length,
          leftIndex = -1,
          leftLength = partials.length,
          args = Array(leftLength + argsLength),
          fn = (this && this !== root && this instanceof wrapper) ? Ctor : func;

      while (++leftIndex < leftLength) {
        args[leftIndex] = partials[leftIndex];
      }
      while (argsLength--) {
        args[leftIndex++] = arguments[++argsIndex];
      }
      return fn.apply(isBind ? thisArg : this, args);
    }
    return wrapper;
  }

  /**
   * A specialized version of `baseIsEqualDeep` for arrays with support for
   * partial deep comparisons.
   *
   * @private
   * @param {Array} array The array to compare.
   * @param {Array} other The other array to compare.
   * @param {number} bitmask The bitmask flags. See `baseIsEqual` for more details.
   * @param {Function} customizer The function to customize comparisons.
   * @param {Function} equalFunc The function to determine equivalents of values.
   * @param {Object} stack Tracks traversed `array` and `other` objects.
   * @returns {boolean} Returns `true` if the arrays are equivalent, else `false`.
   */
  function equalArrays(array, other, bitmask, customizer, equalFunc, stack) {
    var isPartial = bitmask & COMPARE_PARTIAL_FLAG,
        arrLength = array.length,
        othLength = other.length;

    if (arrLength != othLength && !(isPartial && othLength > arrLength)) {
      return false;
    }
    var index = -1,
        result = true,
        seen = (bitmask & COMPARE_UNORDERED_FLAG) ? [] : undefined;

    // Ignore non-index properties.
    while (++index < arrLength) {
      var arrValue = array[index],
          othValue = other[index];

      var compared;
      if (compared !== undefined) {
        if (compared) {
          continue;
        }
        result = false;
        break;
      }
      // Recursively compare arrays (susceptible to call stack limits).
      if (seen) {
        if (!baseSome(other, function(othValue, othIndex) {
              if (!indexOf(seen, othIndex) &&
                  (arrValue === othValue || equalFunc(arrValue, othValue, bitmask, customizer, stack))) {
                return seen.push(othIndex);
              }
            })) {
          result = false;
          break;
        }
      } else if (!(
            arrValue === othValue ||
              equalFunc(arrValue, othValue, bitmask, customizer, stack)
          )) {
        result = false;
        break;
      }
    }
    return result;
  }

  /**
   * A specialized version of `baseIsEqualDeep` for comparing objects of
   * the same `toStringTag`.
   *
   * **Note:** This function only supports comparing values with tags of
   * `Boolean`, `Date`, `Error`, `Number`, `RegExp`, or `String`.
   *
   * @private
   * @param {Object} object The object to compare.
   * @param {Object} other The other object to compare.
   * @param {string} tag The `toStringTag` of the objects to compare.
   * @param {number} bitmask The bitmask flags. See `baseIsEqual` for more details.
   * @param {Function} customizer The function to customize comparisons.
   * @param {Function} equalFunc The function to determine equivalents of values.
   * @param {Object} stack Tracks traversed `object` and `other` objects.
   * @returns {boolean} Returns `true` if the objects are equivalent, else `false`.
   */
  function equalByTag(object, other, tag, bitmask, customizer, equalFunc, stack) {
    switch (tag) {

      case boolTag:
      case dateTag:
      case numberTag:
        // Coerce booleans to `1` or `0` and dates to milliseconds.
        // Invalid dates are coerced to `NaN`.
        return eq(+object, +other);

      case errorTag:
        return object.name == other.name && object.message == other.message;

      case regexpTag:
      case stringTag:
        // Coerce regexes to strings and treat strings, primitives and objects,
        // as equal. See http://www.ecma-international.org/ecma-262/7.0/#sec-regexp.prototype.tostring
        // for more details.
        return object == (other + '');

    }
    return false;
  }

  /**
   * A specialized version of `baseIsEqualDeep` for objects with support for
   * partial deep comparisons.
   *
   * @private
   * @param {Object} object The object to compare.
   * @param {Object} other The other object to compare.
   * @param {number} bitmask The bitmask flags. See `baseIsEqual` for more details.
   * @param {Function} customizer The function to customize comparisons.
   * @param {Function} equalFunc The function to determine equivalents of values.
   * @param {Object} stack Tracks traversed `object` and `other` objects.
   * @returns {boolean} Returns `true` if the objects are equivalent, else `false`.
   */
  function equalObjects(object, other, bitmask, customizer, equalFunc, stack) {
    var isPartial = bitmask & COMPARE_PARTIAL_FLAG,
        objProps = keys(object),
        objLength = objProps.length,
        othProps = keys(other),
        othLength = othProps.length;

    if (objLength != othLength && !isPartial) {
      return false;
    }
    var index = objLength;
    while (index--) {
      var key = objProps[index];
      if (!(isPartial ? key in other : hasOwnProperty.call(other, key))) {
        return false;
      }
    }
    var result = true;

    var skipCtor = isPartial;
    while (++index < objLength) {
      key = objProps[index];
      var objValue = object[key],
          othValue = other[key];

      var compared;
      // Recursively compare objects (susceptible to call stack limits).
      if (!(compared === undefined
            ? (objValue === othValue || equalFunc(objValue, othValue, bitmask, customizer, stack))
            : compared
          )) {
        result = false;
        break;
      }
      skipCtor || (skipCtor = key == 'constructor');
    }
    if (result && !skipCtor) {
      var objCtor = object.constructor,
          othCtor = other.constructor;

      // Non `Object` object instances with different constructors are not equal.
      if (objCtor != othCtor &&
          ('constructor' in object && 'constructor' in other) &&
          !(typeof objCtor == 'function' && objCtor instanceof objCtor &&
            typeof othCtor == 'function' && othCtor instanceof othCtor)) {
        result = false;
      }
    }
    return result;
  }

  /**
   * A specialized version of `baseRest` which flattens the rest array.
   *
   * @private
   * @param {Function} func The function to apply a rest parameter to.
   * @returns {Function} Returns the new function.
   */
  function flatRest(func) {
    return setToString(overRest(func, undefined, flatten), func + '');
  }

  /**
   * Checks if `value` is a flattenable `arguments` object or array.
   *
   * @private
   * @param {*} value The value to check.
   * @returns {boolean} Returns `true` if `value` is flattenable, else `false`.
   */
  function isFlattenable(value) {
    return isArray(value) || isArguments(value);
  }

  /**
   * Checks if `value` is a valid array-like index.
   *
   * @private
   * @param {*} value The value to check.
   * @param {number} [length=MAX_SAFE_INTEGER] The upper bounds of a valid index.
   * @returns {boolean} Returns `true` if `value` is a valid index, else `false`.
   */
  function isIndex(value, length) {
    var type = typeof value;
    length = length == null ? MAX_SAFE_INTEGER : length;

    return !!length &&
      (type == 'number' ||
        (type != 'symbol' && reIsUint.test(value))) &&
          (value > -1 && value % 1 == 0 && value < length);
  }

  /**
   * Checks if the given arguments are from an iteratee call.
   *
   * @private
   * @param {*} value The potential iteratee value argument.
   * @param {*} index The potential iteratee index or key argument.
   * @param {*} object The potential iteratee object argument.
   * @returns {boolean} Returns `true` if the arguments are from an iteratee call,
   *  else `false`.
   */
  function isIterateeCall(value, index, object) {
    if (!isObject(object)) {
      return false;
    }
    var type = typeof index;
    if (type == 'number'
          ? (isArrayLike(object) && isIndex(index, object.length))
          : (type == 'string' && index in object)
        ) {
      return eq(object[index], value);
    }
    return false;
  }

  /**
   * This function is like
   * [`Object.keys`](http://ecma-international.org/ecma-262/7.0/#sec-object.keys)
   * except that it includes inherited enumerable properties.
   *
   * @private
   * @param {Object} object The object to query.
   * @returns {Array} Returns the array of property names.
   */
  function nativeKeysIn(object) {
    var result = [];
    if (object != null) {
      for (var key in Object(object)) {
        result.push(key);
      }
    }
    return result;
  }

  /**
   * Converts `value` to a string using `Object.prototype.toString`.
   *
   * @private
   * @param {*} value The value to convert.
   * @returns {string} Returns the converted string.
   */
  function objectToString(value) {
    return nativeObjectToString.call(value);
  }

  /**
   * A specialized version of `baseRest` which transforms the rest array.
   *
   * @private
   * @param {Function} func The function to apply a rest parameter to.
   * @param {number} [start=func.length-1] The start position of the rest parameter.
   * @param {Function} transform The rest array transform.
   * @returns {Function} Returns the new function.
   */
  function overRest(func, start, transform) {
    start = nativeMax(start === undefined ? (func.length - 1) : start, 0);
    return function() {
      var args = arguments,
          index = -1,
          length = nativeMax(args.length - start, 0),
          array = Array(length);

      while (++index < length) {
        array[index] = args[start + index];
      }
      index = -1;
      var otherArgs = Array(start + 1);
      while (++index < start) {
        otherArgs[index] = args[index];
      }
      otherArgs[start] = transform(array);
      return func.apply(this, otherArgs);
    };
  }

  /**
   * Sets the `toString` method of `func` to return `string`.
   *
   * @private
   * @param {Function} func The function to modify.
   * @param {Function} string The `toString` result.
   * @returns {Function} Returns `func`.
   */
  var setToString = identity;

  /*------------------------------------------------------------------------*/

  /**
   * Creates an array with all falsey values removed. The values `false`, `null`,
   * `0`, `""`, `undefined`, and `NaN` are falsey.
   *
   * @static
   * @memberOf _
   * @since 0.1.0
   * @category Array
   * @param {Array} array The array to compact.
   * @returns {Array} Returns the new array of filtered values.
   * @example
   *
   * _.compact([0, 1, false, 2, '', 3]);
   * // => [1, 2, 3]
   */
  function compact(array) {
    return baseFilter(array, Boolean);
  }

  /**
   * Creates a new array concatenating `array` with any additional arrays
   * and/or values.
   *
   * @static
   * @memberOf _
   * @since 4.0.0
   * @category Array
   * @param {Array} array The array to concatenate.
   * @param {...*} [values] The values to concatenate.
   * @returns {Array} Returns the new concatenated array.
   * @example
   *
   * var array = [1];
   * var other = _.concat(array, 2, [3], [[4]]);
   *
   * console.log(other);
   * // => [1, 2, 3, [4]]
   *
   * console.log(array);
   * // => [1]
   */
  function concat() {
    var length = arguments.length;
    if (!length) {
      return [];
    }
    var args = Array(length - 1),
        array = arguments[0],
        index = length;

    while (index--) {
      args[index - 1] = arguments[index];
    }
    return arrayPush(isArray(array) ? copyArray(array) : [array], baseFlatten(args, 1));
  }

  /**
   * This method is like `_.find` except that it returns the index of the first
   * element `predicate` returns truthy for instead of the element itself.
   *
   * @static
   * @memberOf _
   * @since 1.1.0
   * @category Array
   * @param {Array} array The array to inspect.
   * @param {Function} [predicate=_.identity] The function invoked per iteration.
   * @param {number} [fromIndex=0] The index to search from.
   * @returns {number} Returns the index of the found element, else `-1`.
   * @example
   *
   * var users = [
   *   { 'user': 'barney',  'active': false },
   *   { 'user': 'fred',    'active': false },
   *   { 'user': 'pebbles', 'active': true }
   * ];
   *
   * _.findIndex(users, function(o) { return o.user == 'barney'; });
   * // => 0
   *
   * // The `_.matches` iteratee shorthand.
   * _.findIndex(users, { 'user': 'fred', 'active': false });
   * // => 1
   *
   * // The `_.matchesProperty` iteratee shorthand.
   * _.findIndex(users, ['active', false]);
   * // => 0
   *
   * // The `_.property` iteratee shorthand.
   * _.findIndex(users, 'active');
   * // => 2
   */
  function findIndex(array, predicate, fromIndex) {
    var length = array == null ? 0 : array.length;
    if (!length) {
      return -1;
    }
    var index = fromIndex == null ? 0 : toInteger(fromIndex);
    if (index < 0) {
      index = nativeMax(length + index, 0);
    }
    return baseFindIndex(array, baseIteratee(predicate, 3), index);
  }

  /**
   * Flattens `array` a single level deep.
   *
   * @static
   * @memberOf _
   * @since 0.1.0
   * @category Array
   * @param {Array} array The array to flatten.
   * @returns {Array} Returns the new flattened array.
   * @example
   *
   * _.flatten([1, [2, [3, [4]], 5]]);
   * // => [1, 2, [3, [4]], 5]
   */
  function flatten(array) {
    var length = array == null ? 0 : array.length;
    return length ? baseFlatten(array, 1) : [];
  }

  /**
   * Recursively flattens `array`.
   *
   * @static
   * @memberOf _
   * @since 3.0.0
   * @category Array
   * @param {Array} array The array to flatten.
   * @returns {Array} Returns the new flattened array.
   * @example
   *
   * _.flattenDeep([1, [2, [3, [4]], 5]]);
   * // => [1, 2, 3, 4, 5]
   */
  function flattenDeep(array) {
    var length = array == null ? 0 : array.length;
    return length ? baseFlatten(array, INFINITY) : [];
  }

  /**
   * Gets the first element of `array`.
   *
   * @static
   * @memberOf _
   * @since 0.1.0
   * @alias first
   * @category Array
   * @param {Array} array The array to query.
   * @returns {*} Returns the first element of `array`.
   * @example
   *
   * _.head([1, 2, 3]);
   * // => 1
   *
   * _.head([]);
   * // => undefined
   */
  function head(array) {
    return (array && array.length) ? array[0] : undefined;
  }

  /**
   * Gets the index at which the first occurrence of `value` is found in `array`
   * using [`SameValueZero`](http://ecma-international.org/ecma-262/7.0/#sec-samevaluezero)
   * for equality comparisons. If `fromIndex` is negative, it's used as the
   * offset from the end of `array`.
   *
   * @static
   * @memberOf _
   * @since 0.1.0
   * @category Array
   * @param {Array} array The array to inspect.
   * @param {*} value The value to search for.
   * @param {number} [fromIndex=0] The index to search from.
   * @returns {number} Returns the index of the matched value, else `-1`.
   * @example
   *
   * _.indexOf([1, 2, 1, 2], 2);
   * // => 1
   *
   * // Search from the `fromIndex`.
   * _.indexOf([1, 2, 1, 2], 2, 2);
   * // => 3
   */
  function indexOf(array, value, fromIndex) {
    var length = array == null ? 0 : array.length;
    if (typeof fromIndex == 'number') {
      fromIndex = fromIndex < 0 ? nativeMax(length + fromIndex, 0) : fromIndex;
    } else {
      fromIndex = 0;
    }
    var index = (fromIndex || 0) - 1,
        isReflexive = value === value;

    while (++index < length) {
      var other = array[index];
      if ((isReflexive ? other === value : other !== other)) {
        return index;
      }
    }
    return -1;
  }

  /**
   * Gets the last element of `array`.
   *
   * @static
   * @memberOf _
   * @since 0.1.0
   * @category Array
   * @param {Array} array The array to query.
   * @returns {*} Returns the last element of `array`.
   * @example
   *
   * _.last([1, 2, 3]);
   * // => 3
   */
  function last(array) {
    var length = array == null ? 0 : array.length;
    return length ? array[length - 1] : undefined;
  }

  /**
   * Creates a slice of `array` from `start` up to, but not including, `end`.
   *
   * **Note:** This method is used instead of
   * [`Array#slice`](https://mdn.io/Array/slice) to ensure dense arrays are
   * returned.
   *
   * @static
   * @memberOf _
   * @since 3.0.0
   * @category Array
   * @param {Array} array The array to slice.
   * @param {number} [start=0] The start position.
   * @param {number} [end=array.length] The end position.
   * @returns {Array} Returns the slice of `array`.
   */
  function slice(array, start, end) {
    var length = array == null ? 0 : array.length;
    start = start == null ? 0 : +start;
    end = end === undefined ? length : +end;
    return length ? baseSlice(array, start, end) : [];
  }

  /*------------------------------------------------------------------------*/

  /**
   * Creates a `lodash` wrapper instance that wraps `value` with explicit method
   * chain sequences enabled. The result of such sequences must be unwrapped
   * with `_#value`.
   *
   * @static
   * @memberOf _
   * @since 1.3.0
   * @category Seq
   * @param {*} value The value to wrap.
   * @returns {Object} Returns the new `lodash` wrapper instance.
   * @example
   *
   * var users = [
   *   { 'user': 'barney',  'age': 36 },
   *   { 'user': 'fred',    'age': 40 },
   *   { 'user': 'pebbles', 'age': 1 }
   * ];
   *
   * var youngest = _
   *   .chain(users)
   *   .sortBy('age')
   *   .map(function(o) {
   *     return o.user + ' is ' + o.age;
   *   })
   *   .head()
   *   .value();
   * // => 'pebbles is 1'
   */
  function chain(value) {
    var result = lodash(value);
    result.__chain__ = true;
    return result;
  }

  /**
   * This method invokes `interceptor` and returns `value`. The interceptor
   * is invoked with one argument; (value). The purpose of this method is to
   * "tap into" a method chain sequence in order to modify intermediate results.
   *
   * @static
   * @memberOf _
   * @since 0.1.0
   * @category Seq
   * @param {*} value The value to provide to `interceptor`.
   * @param {Function} interceptor The function to invoke.
   * @returns {*} Returns `value`.
   * @example
   *
   * _([1, 2, 3])
   *  .tap(function(array) {
   *    // Mutate input array.
   *    array.pop();
   *  })
   *  .reverse()
   *  .value();
   * // => [2, 1]
   */
  function tap(value, interceptor) {
    interceptor(value);
    return value;
  }

  /**
   * This method is like `_.tap` except that it returns the result of `interceptor`.
   * The purpose of this method is to "pass thru" values replacing intermediate
   * results in a method chain sequence.
   *
   * @static
   * @memberOf _
   * @since 3.0.0
   * @category Seq
   * @param {*} value The value to provide to `interceptor`.
   * @param {Function} interceptor The function to invoke.
   * @returns {*} Returns the result of `interceptor`.
   * @example
   *
   * _('  abc  ')
   *  .chain()
   *  .trim()
   *  .thru(function(value) {
   *    return [value];
   *  })
   *  .value();
   * // => ['abc']
   */
  function thru(value, interceptor) {
    return interceptor(value);
  }

  /**
   * Creates a `lodash` wrapper instance with explicit method chain sequences enabled.
   *
   * @name chain
   * @memberOf _
   * @since 0.1.0
   * @category Seq
   * @returns {Object} Returns the new `lodash` wrapper instance.
   * @example
   *
   * var users = [
   *   { 'user': 'barney', 'age': 36 },
   *   { 'user': 'fred',   'age': 40 }
   * ];
   *
   * // A sequence without explicit chaining.
   * _(users).head();
   * // => { 'user': 'barney', 'age': 36 }
   *
   * // A sequence with explicit chaining.
   * _(users)
   *   .chain()
   *   .head()
   *   .pick('user')
   *   .value();
   * // => { 'user': 'barney' }
   */
  function wrapperChain() {
    return chain(this);
  }

  /**
   * Executes the chain sequence to resolve the unwrapped value.
   *
   * @name value
   * @memberOf _
   * @since 0.1.0
   * @alias toJSON, valueOf
   * @category Seq
   * @returns {*} Returns the resolved unwrapped value.
   * @example
   *
   * _([1, 2, 3]).value();
   * // => [1, 2, 3]
   */
  function wrapperValue() {
    return baseWrapperValue(this.__wrapped__, this.__actions__);
  }

  /*------------------------------------------------------------------------*/

  /**
   * Checks if `predicate` returns truthy for **all** elements of `collection`.
   * Iteration is stopped once `predicate` returns falsey. The predicate is
   * invoked with three arguments: (value, index|key, collection).
   *
   * **Note:** This method returns `true` for
   * [empty collections](https://en.wikipedia.org/wiki/Empty_set) because
   * [everything is true](https://en.wikipedia.org/wiki/Vacuous_truth) of
   * elements of empty collections.
   *
   * @static
   * @memberOf _
   * @since 0.1.0
   * @category Collection
   * @param {Array|Object} collection The collection to iterate over.
   * @param {Function} [predicate=_.identity] The function invoked per iteration.
   * @param- {Object} [guard] Enables use as an iteratee for methods like `_.map`.
   * @returns {boolean} Returns `true` if all elements pass the predicate check,
   *  else `false`.
   * @example
   *
   * _.every([true, 1, null, 'yes'], Boolean);
   * // => false
   *
   * var users = [
   *   { 'user': 'barney', 'age': 36, 'active': false },
   *   { 'user': 'fred',   'age': 40, 'active': false }
   * ];
   *
   * // The `_.matches` iteratee shorthand.
   * _.every(users, { 'user': 'barney', 'active': false });
   * // => false
   *
   * // The `_.matchesProperty` iteratee shorthand.
   * _.every(users, ['active', false]);
   * // => true
   *
   * // The `_.property` iteratee shorthand.
   * _.every(users, 'active');
   * // => false
   */
  function every(collection, predicate, guard) {
    predicate = guard ? undefined : predicate;
    return baseEvery(collection, baseIteratee(predicate));
  }

  /**
   * Iterates over elements of `collection`, returning an array of all elements
   * `predicate` returns truthy for. The predicate is invoked with three
   * arguments: (value, index|key, collection).
   *
   * **Note:** Unlike `_.remove`, this method returns a new array.
   *
   * @static
   * @memberOf _
   * @since 0.1.0
   * @category Collection
   * @param {Array|Object} collection The collection to iterate over.
   * @param {Function} [predicate=_.identity] The function invoked per iteration.
   * @returns {Array} Returns the new filtered array.
   * @see _.reject
   * @example
   *
   * var users = [
   *   { 'user': 'barney', 'age': 36, 'active': true },
   *   { 'user': 'fred',   'age': 40, 'active': false }
   * ];
   *
   * _.filter(users, function(o) { return !o.active; });
   * // => objects for ['fred']
   *
   * // The `_.matches` iteratee shorthand.
   * _.filter(users, { 'age': 36, 'active': true });
   * // => objects for ['barney']
   *
   * // The `_.matchesProperty` iteratee shorthand.
   * _.filter(users, ['active', false]);
   * // => objects for ['fred']
   *
   * // The `_.property` iteratee shorthand.
   * _.filter(users, 'active');
   * // => objects for ['barney']
   */
  function filter(collection, predicate) {
    return baseFilter(collection, baseIteratee(predicate));
  }

  /**
   * Iterates over elements of `collection`, returning the first element
   * `predicate` returns truthy for. The predicate is invoked with three
   * arguments: (value, index|key, collection).
   *
   * @static
   * @memberOf _
   * @since 0.1.0
   * @category Collection
   * @param {Array|Object} collection The collection to inspect.
   * @param {Function} [predicate=_.identity] The function invoked per iteration.
   * @param {number} [fromIndex=0] The index to search from.
   * @returns {*} Returns the matched element, else `undefined`.
   * @example
   *
   * var users = [
   *   { 'user': 'barney',  'age': 36, 'active': true },
   *   { 'user': 'fred',    'age': 40, 'active': false },
   *   { 'user': 'pebbles', 'age': 1,  'active': true }
   * ];
   *
   * _.find(users, function(o) { return o.age < 40; });
   * // => object for 'barney'
   *
   * // The `_.matches` iteratee shorthand.
   * _.find(users, { 'age': 1, 'active': true });
   * // => object for 'pebbles'
   *
   * // The `_.matchesProperty` iteratee shorthand.
   * _.find(users, ['active', false]);
   * // => object for 'fred'
   *
   * // The `_.property` iteratee shorthand.
   * _.find(users, 'active');
   * // => object for 'barney'
   */
  var find = createFind(findIndex);

  /**
   * Iterates over elements of `collection` and invokes `iteratee` for each element.
   * The iteratee is invoked with three arguments: (value, index|key, collection).
   * Iteratee functions may exit iteration early by explicitly returning `false`.
   *
   * **Note:** As with other "Collections" methods, objects with a "length"
   * property are iterated like arrays. To avoid this behavior use `_.forIn`
   * or `_.forOwn` for object iteration.
   *
   * @static
   * @memberOf _
   * @since 0.1.0
   * @alias each
   * @category Collection
   * @param {Array|Object} collection The collection to iterate over.
   * @param {Function} [iteratee=_.identity] The function invoked per iteration.
   * @returns {Array|Object} Returns `collection`.
   * @see _.forEachRight
   * @example
   *
   * _.forEach([1, 2], function(value) {
   *   console.log(value);
   * });
   * // => Logs `1` then `2`.
   *
   * _.forEach({ 'a': 1, 'b': 2 }, function(value, key) {
   *   console.log(key);
   * });
   * // => Logs 'a' then 'b' (iteration order is not guaranteed).
   */
  function forEach(collection, iteratee) {
    return baseEach(collection, baseIteratee(iteratee));
  }

  /**
   * Creates an array of values by running each element in `collection` thru
   * `iteratee`. The iteratee is invoked with three arguments:
   * (value, index|key, collection).
   *
   * Many lodash methods are guarded to work as iteratees for methods like
   * `_.every`, `_.filter`, `_.map`, `_.mapValues`, `_.reject`, and `_.some`.
   *
   * The guarded methods are:
   * `ary`, `chunk`, `curry`, `curryRight`, `drop`, `dropRight`, `every`,
   * `fill`, `invert`, `parseInt`, `random`, `range`, `rangeRight`, `repeat`,
   * `sampleSize`, `slice`, `some`, `sortBy`, `split`, `take`, `takeRight`,
   * `template`, `trim`, `trimEnd`, `trimStart`, and `words`
   *
   * @static
   * @memberOf _
   * @since 0.1.0
   * @category Collection
   * @param {Array|Object} collection The collection to iterate over.
   * @param {Function} [iteratee=_.identity] The function invoked per iteration.
   * @returns {Array} Returns the new mapped array.
   * @example
   *
   * function square(n) {
   *   return n * n;
   * }
   *
   * _.map([4, 8], square);
   * // => [16, 64]
   *
   * _.map({ 'a': 4, 'b': 8 }, square);
   * // => [16, 64] (iteration order is not guaranteed)
   *
   * var users = [
   *   { 'user': 'barney' },
   *   { 'user': 'fred' }
   * ];
   *
   * // The `_.property` iteratee shorthand.
   * _.map(users, 'user');
   * // => ['barney', 'fred']
   */
  function map(collection, iteratee) {
    return baseMap(collection, baseIteratee(iteratee));
  }

  /**
   * Reduces `collection` to a value which is the accumulated result of running
   * each element in `collection` thru `iteratee`, where each successive
   * invocation is supplied the return value of the previous. If `accumulator`
   * is not given, the first element of `collection` is used as the initial
   * value. The iteratee is invoked with four arguments:
   * (accumulator, value, index|key, collection).
   *
   * Many lodash methods are guarded to work as iteratees for methods like
   * `_.reduce`, `_.reduceRight`, and `_.transform`.
   *
   * The guarded methods are:
   * `assign`, `defaults`, `defaultsDeep`, `includes`, `merge`, `orderBy`,
   * and `sortBy`
   *
   * @static
   * @memberOf _
   * @since 0.1.0
   * @category Collection
   * @param {Array|Object} collection The collection to iterate over.
   * @param {Function} [iteratee=_.identity] The function invoked per iteration.
   * @param {*} [accumulator] The initial value.
   * @returns {*} Returns the accumulated value.
   * @see _.reduceRight
   * @example
   *
   * _.reduce([1, 2], function(sum, n) {
   *   return sum + n;
   * }, 0);
   * // => 3
   *
   * _.reduce({ 'a': 1, 'b': 2, 'c': 1 }, function(result, value, key) {
   *   (result[value] || (result[value] = [])).push(key);
   *   return result;
   * }, {});
   * // => { '1': ['a', 'c'], '2': ['b'] } (iteration order is not guaranteed)
   */
  function reduce(collection, iteratee, accumulator) {
    return baseReduce(collection, baseIteratee(iteratee), accumulator, arguments.length < 3, baseEach);
  }

  /**
   * Gets the size of `collection` by returning its length for array-like
   * values or the number of own enumerable string keyed properties for objects.
   *
   * @static
   * @memberOf _
   * @since 0.1.0
   * @category Collection
   * @param {Array|Object|string} collection The collection to inspect.
   * @returns {number} Returns the collection size.
   * @example
   *
   * _.size([1, 2, 3]);
   * // => 3
   *
   * _.size({ 'a': 1, 'b': 2 });
   * // => 2
   *
   * _.size('pebbles');
   * // => 7
   */
  function size(collection) {
    if (collection == null) {
      return 0;
    }
    collection = isArrayLike(collection) ? collection : nativeKeys(collection);
    return collection.length;
  }

  /**
   * Checks if `predicate` returns truthy for **any** element of `collection`.
   * Iteration is stopped once `predicate` returns truthy. The predicate is
   * invoked with three arguments: (value, index|key, collection).
   *
   * @static
   * @memberOf _
   * @since 0.1.0
   * @category Collection
   * @param {Array|Object} collection The collection to iterate over.
   * @param {Function} [predicate=_.identity] The function invoked per iteration.
   * @param- {Object} [guard] Enables use as an iteratee for methods like `_.map`.
   * @returns {boolean} Returns `true` if any element passes the predicate check,
   *  else `false`.
   * @example
   *
   * _.some([null, 0, 'yes', false], Boolean);
   * // => true
   *
   * var users = [
   *   { 'user': 'barney', 'active': true },
   *   { 'user': 'fred',   'active': false }
   * ];
   *
   * // The `_.matches` iteratee shorthand.
   * _.some(users, { 'user': 'barney', 'active': false });
   * // => false
   *
   * // The `_.matchesProperty` iteratee shorthand.
   * _.some(users, ['active', false]);
   * // => true
   *
   * // The `_.property` iteratee shorthand.
   * _.some(users, 'active');
   * // => true
   */
  function some(collection, predicate, guard) {
    predicate = guard ? undefined : predicate;
    return baseSome(collection, baseIteratee(predicate));
  }

  /**
   * Creates an array of elements, sorted in ascending order by the results of
   * running each element in a collection thru each iteratee. This method
   * performs a stable sort, that is, it preserves the original sort order of
   * equal elements. The iteratees are invoked with one argument: (value).
   *
   * @static
   * @memberOf _
   * @since 0.1.0
   * @category Collection
   * @param {Array|Object} collection The collection to iterate over.
   * @param {...(Function|Function[])} [iteratees=[_.identity]]
   *  The iteratees to sort by.
   * @returns {Array} Returns the new sorted array.
   * @example
   *
   * var users = [
   *   { 'user': 'fred',   'age': 48 },
   *   { 'user': 'barney', 'age': 36 },
   *   { 'user': 'fred',   'age': 40 },
   *   { 'user': 'barney', 'age': 34 }
   * ];
   *
   * _.sortBy(users, [function(o) { return o.user; }]);
   * // => objects for [['barney', 36], ['barney', 34], ['fred', 48], ['fred', 40]]
   *
   * _.sortBy(users, ['user', 'age']);
   * // => objects for [['barney', 34], ['barney', 36], ['fred', 40], ['fred', 48]]
   */
  function sortBy(collection, iteratee) {
    var index = 0;
    iteratee = baseIteratee(iteratee);

    return baseMap(baseMap(collection, function(value, key, collection) {
      return { 'value': value, 'index': index++, 'criteria': iteratee(value, key, collection) };
    }).sort(function(object, other) {
      return compareAscending(object.criteria, other.criteria) || (object.index - other.index);
    }), baseProperty('value'));
  }

  /*------------------------------------------------------------------------*/

  /**
   * Creates a function that invokes `func`, with the `this` binding and arguments
   * of the created function, while it's called less than `n` times. Subsequent
   * calls to the created function return the result of the last `func` invocation.
   *
   * @static
   * @memberOf _
   * @since 3.0.0
   * @category Function
   * @param {number} n The number of calls at which `func` is no longer invoked.
   * @param {Function} func The function to restrict.
   * @returns {Function} Returns the new restricted function.
   * @example
   *
   * jQuery(element).on('click', _.before(5, addContactToList));
   * // => Allows adding up to 4 contacts to the list.
   */
  function before(n, func) {
    var result;
    if (typeof func != 'function') {
      throw new TypeError(FUNC_ERROR_TEXT);
    }
    n = toInteger(n);
    return function() {
      if (--n > 0) {
        result = func.apply(this, arguments);
      }
      if (n <= 1) {
        func = undefined;
      }
      return result;
    };
  }

  /**
   * Creates a function that invokes `func` with the `this` binding of `thisArg`
   * and `partials` prepended to the arguments it receives.
   *
   * The `_.bind.placeholder` value, which defaults to `_` in monolithic builds,
   * may be used as a placeholder for partially applied arguments.
   *
   * **Note:** Unlike native `Function#bind`, this method doesn't set the "length"
   * property of bound functions.
   *
   * @static
   * @memberOf _
   * @since 0.1.0
   * @category Function
   * @param {Function} func The function to bind.
   * @param {*} thisArg The `this` binding of `func`.
   * @param {...*} [partials] The arguments to be partially applied.
   * @returns {Function} Returns the new bound function.
   * @example
   *
   * function greet(greeting, punctuation) {
   *   return greeting + ' ' + this.user + punctuation;
   * }
   *
   * var object = { 'user': 'fred' };
   *
   * var bound = _.bind(greet, object, 'hi');
   * bound('!');
   * // => 'hi fred!'
   *
   * // Bound with placeholders.
   * var bound = _.bind(greet, object, _, '!');
   * bound('hi');
   * // => 'hi fred!'
   */
  var bind = baseRest(function(func, thisArg, partials) {
    return createPartial(func, WRAP_BIND_FLAG | WRAP_PARTIAL_FLAG, thisArg, partials);
  });

  /**
   * Defers invoking the `func` until the current call stack has cleared. Any
   * additional arguments are provided to `func` when it's invoked.
   *
   * @static
   * @memberOf _
   * @since 0.1.0
   * @category Function
   * @param {Function} func The function to defer.
   * @param {...*} [args] The arguments to invoke `func` with.
   * @returns {number} Returns the timer id.
   * @example
   *
   * _.defer(function(text) {
   *   console.log(text);
   * }, 'deferred');
   * // => Logs 'deferred' after one millisecond.
   */
  var defer = baseRest(function(func, args) {
    return baseDelay(func, 1, args);
  });

  /**
   * Invokes `func` after `wait` milliseconds. Any additional arguments are
   * provided to `func` when it's invoked.
   *
   * @static
   * @memberOf _
   * @since 0.1.0
   * @category Function
   * @param {Function} func The function to delay.
   * @param {number} wait The number of milliseconds to delay invocation.
   * @param {...*} [args] The arguments to invoke `func` with.
   * @returns {number} Returns the timer id.
   * @example
   *
   * _.delay(function(text) {
   *   console.log(text);
   * }, 1000, 'later');
   * // => Logs 'later' after one second.
   */
  var delay = baseRest(function(func, wait, args) {
    return baseDelay(func, toNumber(wait) || 0, args);
  });

  /**
   * Creates a function that negates the result of the predicate `func`. The
   * `func` predicate is invoked with the `this` binding and arguments of the
   * created function.
   *
   * @static
   * @memberOf _
   * @since 3.0.0
   * @category Function
   * @param {Function} predicate The predicate to negate.
   * @returns {Function} Returns the new negated function.
   * @example
   *
   * function isEven(n) {
   *   return n % 2 == 0;
   * }
   *
   * _.filter([1, 2, 3, 4, 5, 6], _.negate(isEven));
   * // => [1, 3, 5]
   */
  function negate(predicate) {
    if (typeof predicate != 'function') {
      throw new TypeError(FUNC_ERROR_TEXT);
    }
    return function() {
      var args = arguments;
      return !predicate.apply(this, args);
    };
  }

  /**
   * Creates a function that is restricted to invoking `func` once. Repeat calls
   * to the function return the value of the first invocation. The `func` is
   * invoked with the `this` binding and arguments of the created function.
   *
   * @static
   * @memberOf _
   * @since 0.1.0
   * @category Function
   * @param {Function} func The function to restrict.
   * @returns {Function} Returns the new restricted function.
   * @example
   *
   * var initialize = _.once(createApplication);
   * initialize();
   * initialize();
   * // => `createApplication` is invoked once
   */
  function once(func) {
    return before(2, func);
  }

  /*------------------------------------------------------------------------*/

  /**
   * Creates a shallow clone of `value`.
   *
   * **Note:** This method is loosely based on the
   * [structured clone algorithm](https://mdn.io/Structured_clone_algorithm)
   * and supports cloning arrays, array buffers, booleans, date objects, maps,
   * numbers, `Object` objects, regexes, sets, strings, symbols, and typed
   * arrays. The own enumerable properties of `arguments` objects are cloned
   * as plain objects. An empty object is returned for uncloneable values such
   * as error objects, functions, DOM nodes, and WeakMaps.
   *
   * @static
   * @memberOf _
   * @since 0.1.0
   * @category Lang
   * @param {*} value The value to clone.
   * @returns {*} Returns the cloned value.
   * @see _.cloneDeep
   * @example
   *
   * var objects = [{ 'a': 1 }, { 'b': 2 }];
   *
   * var shallow = _.clone(objects);
   * console.log(shallow[0] === objects[0]);
   * // => true
   */
  function clone(value) {
    if (!isObject(value)) {
      return value;
    }
    return isArray(value) ? copyArray(value) : copyObject(value, nativeKeys(value));
  }

  /**
   * Performs a
   * [`SameValueZero`](http://ecma-international.org/ecma-262/7.0/#sec-samevaluezero)
   * comparison between two values to determine if they are equivalent.
   *
   * @static
   * @memberOf _
   * @since 4.0.0
   * @category Lang
   * @param {*} value The value to compare.
   * @param {*} other The other value to compare.
   * @returns {boolean} Returns `true` if the values are equivalent, else `false`.
   * @example
   *
   * var object = { 'a': 1 };
   * var other = { 'a': 1 };
   *
   * _.eq(object, object);
   * // => true
   *
   * _.eq(object, other);
   * // => false
   *
   * _.eq('a', 'a');
   * // => true
   *
   * _.eq('a', Object('a'));
   * // => false
   *
   * _.eq(NaN, NaN);
   * // => true
   */
  function eq(value, other) {
    return value === other || (value !== value && other !== other);
  }

  /**
   * Checks if `value` is likely an `arguments` object.
   *
   * @static
   * @memberOf _
   * @since 0.1.0
   * @category Lang
   * @param {*} value The value to check.
   * @returns {boolean} Returns `true` if `value` is an `arguments` object,
   *  else `false`.
   * @example
   *
   * _.isArguments(function() { return arguments; }());
   * // => true
   *
   * _.isArguments([1, 2, 3]);
   * // => false
   */
  var isArguments = baseIsArguments(function() { return arguments; }()) ? baseIsArguments : function(value) {
    return isObjectLike(value) && hasOwnProperty.call(value, 'callee') &&
      !propertyIsEnumerable.call(value, 'callee');
  };

  /**
   * Checks if `value` is classified as an `Array` object.
   *
   * @static
   * @memberOf _
   * @since 0.1.0
   * @category Lang
   * @param {*} value The value to check.
   * @returns {boolean} Returns `true` if `value` is an array, else `false`.
   * @example
   *
   * _.isArray([1, 2, 3]);
   * // => true
   *
   * _.isArray(document.body.children);
   * // => false
   *
   * _.isArray('abc');
   * // => false
   *
   * _.isArray(_.noop);
   * // => false
   */
  var isArray = Array.isArray;

  /**
   * Checks if `value` is array-like. A value is considered array-like if it's
   * not a function and has a `value.length` that's an integer greater than or
   * equal to `0` and less than or equal to `Number.MAX_SAFE_INTEGER`.
   *
   * @static
   * @memberOf _
   * @since 4.0.0
   * @category Lang
   * @param {*} value The value to check.
   * @returns {boolean} Returns `true` if `value` is array-like, else `false`.
   * @example
   *
   * _.isArrayLike([1, 2, 3]);
   * // => true
   *
   * _.isArrayLike(document.body.children);
   * // => true
   *
   * _.isArrayLike('abc');
   * // => true
   *
   * _.isArrayLike(_.noop);
   * // => false
   */
  function isArrayLike(value) {
    return value != null && isLength(value.length) && !isFunction(value);
  }

  /**
   * Checks if `value` is classified as a boolean primitive or object.
   *
   * @static
   * @memberOf _
   * @since 0.1.0
   * @category Lang
   * @param {*} value The value to check.
   * @returns {boolean} Returns `true` if `value` is a boolean, else `false`.
   * @example
   *
   * _.isBoolean(false);
   * // => true
   *
   * _.isBoolean(null);
   * // => false
   */
  function isBoolean(value) {
    return value === true || value === false ||
      (isObjectLike(value) && baseGetTag(value) == boolTag);
  }

  /**
   * Checks if `value` is classified as a `Date` object.
   *
   * @static
   * @memberOf _
   * @since 0.1.0
   * @category Lang
   * @param {*} value The value to check.
   * @returns {boolean} Returns `true` if `value` is a date object, else `false`.
   * @example
   *
   * _.isDate(new Date);
   * // => true
   *
   * _.isDate('Mon April 23 2012');
   * // => false
   */
  var isDate = baseIsDate;

  /**
   * Checks if `value` is an empty object, collection, map, or set.
   *
   * Objects are considered empty if they have no own enumerable string keyed
   * properties.
   *
   * Array-like values such as `arguments` objects, arrays, buffers, strings, or
   * jQuery-like collections are considered empty if they have a `length` of `0`.
   * Similarly, maps and sets are considered empty if they have a `size` of `0`.
   *
   * @static
   * @memberOf _
   * @since 0.1.0
   * @category Lang
   * @param {*} value The value to check.
   * @returns {boolean} Returns `true` if `value` is empty, else `false`.
   * @example
   *
   * _.isEmpty(null);
   * // => true
   *
   * _.isEmpty(true);
   * // => true
   *
   * _.isEmpty(1);
   * // => true
   *
   * _.isEmpty([1, 2, 3]);
   * // => false
   *
   * _.isEmpty({ 'a': 1 });
   * // => false
   */
  function isEmpty(value) {
    if (isArrayLike(value) &&
        (isArray(value) || isString(value) ||
          isFunction(value.splice) || isArguments(value))) {
      return !value.length;
    }
    return !nativeKeys(value).length;
  }

  /**
   * Performs a deep comparison between two values to determine if they are
   * equivalent.
   *
   * **Note:** This method supports comparing arrays, array buffers, booleans,
   * date objects, error objects, maps, numbers, `Object` objects, regexes,
   * sets, strings, symbols, and typed arrays. `Object` objects are compared
   * by their own, not inherited, enumerable properties. Functions and DOM
   * nodes are compared by strict equality, i.e. `===`.
   *
   * @static
   * @memberOf _
   * @since 0.1.0
   * @category Lang
   * @param {*} value The value to compare.
   * @param {*} other The other value to compare.
   * @returns {boolean} Returns `true` if the values are equivalent, else `false`.
   * @example
   *
   * var object = { 'a': 1 };
   * var other = { 'a': 1 };
   *
   * _.isEqual(object, other);
   * // => true
   *
   * object === other;
   * // => false
   */
  function isEqual(value, other) {
    return baseIsEqual(value, other);
  }

  /**
   * Checks if `value` is a finite primitive number.
   *
   * **Note:** This method is based on
   * [`Number.isFinite`](https://mdn.io/Number/isFinite).
   *
   * @static
   * @memberOf _
   * @since 0.1.0
   * @category Lang
   * @param {*} value The value to check.
   * @returns {boolean} Returns `true` if `value` is a finite number, else `false`.
   * @example
   *
   * _.isFinite(3);
   * // => true
   *
   * _.isFinite(Number.MIN_VALUE);
   * // => true
   *
   * _.isFinite(Infinity);
   * // => false
   *
   * _.isFinite('3');
   * // => false
   */
  function isFinite(value) {
    return typeof value == 'number' && nativeIsFinite(value);
  }

  /**
   * Checks if `value` is classified as a `Function` object.
   *
   * @static
   * @memberOf _
   * @since 0.1.0
   * @category Lang
   * @param {*} value The value to check.
   * @returns {boolean} Returns `true` if `value` is a function, else `false`.
   * @example
   *
   * _.isFunction(_);
   * // => true
   *
   * _.isFunction(/abc/);
   * // => false
   */
  function isFunction(value) {
    if (!isObject(value)) {
      return false;
    }
    // The use of `Object#toString` avoids issues with the `typeof` operator
    // in Safari 9 which returns 'object' for typed arrays and other constructors.
    var tag = baseGetTag(value);
    return tag == funcTag || tag == genTag || tag == asyncTag || tag == proxyTag;
  }

  /**
   * Checks if `value` is a valid array-like length.
   *
   * **Note:** This method is loosely based on
   * [`ToLength`](http://ecma-international.org/ecma-262/7.0/#sec-tolength).
   *
   * @static
   * @memberOf _
   * @since 4.0.0
   * @category Lang
   * @param {*} value The value to check.
   * @returns {boolean} Returns `true` if `value` is a valid length, else `false`.
   * @example
   *
   * _.isLength(3);
   * // => true
   *
   * _.isLength(Number.MIN_VALUE);
   * // => false
   *
   * _.isLength(Infinity);
   * // => false
   *
   * _.isLength('3');
   * // => false
   */
  function isLength(value) {
    return typeof value == 'number' &&
      value > -1 && value % 1 == 0 && value <= MAX_SAFE_INTEGER;
  }

  /**
   * Checks if `value` is the
   * [language type](http://www.ecma-international.org/ecma-262/7.0/#sec-ecmascript-language-types)
   * of `Object`. (e.g. arrays, functions, objects, regexes, `new Number(0)`, and `new String('')`)
   *
   * @static
   * @memberOf _
   * @since 0.1.0
   * @category Lang
   * @param {*} value The value to check.
   * @returns {boolean} Returns `true` if `value` is an object, else `false`.
   * @example
   *
   * _.isObject({});
   * // => true
   *
   * _.isObject([1, 2, 3]);
   * // => true
   *
   * _.isObject(_.noop);
   * // => true
   *
   * _.isObject(null);
   * // => false
   */
  function isObject(value) {
    var type = typeof value;
    return value != null && (type == 'object' || type == 'function');
  }

  /**
   * Checks if `value` is object-like. A value is object-like if it's not `null`
   * and has a `typeof` result of "object".
   *
   * @static
   * @memberOf _
   * @since 4.0.0
   * @category Lang
   * @param {*} value The value to check.
   * @returns {boolean} Returns `true` if `value` is object-like, else `false`.
   * @example
   *
   * _.isObjectLike({});
   * // => true
   *
   * _.isObjectLike([1, 2, 3]);
   * // => true
   *
   * _.isObjectLike(_.noop);
   * // => false
   *
   * _.isObjectLike(null);
   * // => false
   */
  function isObjectLike(value) {
    return value != null && typeof value == 'object';
  }

  /**
   * Checks if `value` is `NaN`.
   *
   * **Note:** This method is based on
   * [`Number.isNaN`](https://mdn.io/Number/isNaN) and is not the same as
   * global [`isNaN`](https://mdn.io/isNaN) which returns `true` for
   * `undefined` and other non-number values.
   *
   * @static
   * @memberOf _
   * @since 0.1.0
   * @category Lang
   * @param {*} value The value to check.
   * @returns {boolean} Returns `true` if `value` is `NaN`, else `false`.
   * @example
   *
   * _.isNaN(NaN);
   * // => true
   *
   * _.isNaN(new Number(NaN));
   * // => true
   *
   * isNaN(undefined);
   * // => true
   *
   * _.isNaN(undefined);
   * // => false
   */
  function isNaN(value) {
    // An `NaN` primitive is the only value that is not equal to itself.
    // Perform the `toStringTag` check first to avoid errors with some
    // ActiveX objects in IE.
    return isNumber(value) && value != +value;
  }

  /**
   * Checks if `value` is `null`.
   *
   * @static
   * @memberOf _
   * @since 0.1.0
   * @category Lang
   * @param {*} value The value to check.
   * @returns {boolean} Returns `true` if `value` is `null`, else `false`.
   * @example
   *
   * _.isNull(null);
   * // => true
   *
   * _.isNull(void 0);
   * // => false
   */
  function isNull(value) {
    return value === null;
  }

  /**
   * Checks if `value` is classified as a `Number` primitive or object.
   *
   * **Note:** To exclude `Infinity`, `-Infinity`, and `NaN`, which are
   * classified as numbers, use the `_.isFinite` method.
   *
   * @static
   * @memberOf _
   * @since 0.1.0
   * @category Lang
   * @param {*} value The value to check.
   * @returns {boolean} Returns `true` if `value` is a number, else `false`.
   * @example
   *
   * _.isNumber(3);
   * // => true
   *
   * _.isNumber(Number.MIN_VALUE);
   * // => true
   *
   * _.isNumber(Infinity);
   * // => true
   *
   * _.isNumber('3');
   * // => false
   */
  function isNumber(value) {
    return typeof value == 'number' ||
      (isObjectLike(value) && baseGetTag(value) == numberTag);
  }

  /**
   * Checks if `value` is classified as a `RegExp` object.
   *
   * @static
   * @memberOf _
   * @since 0.1.0
   * @category Lang
   * @param {*} value The value to check.
   * @returns {boolean} Returns `true` if `value` is a regexp, else `false`.
   * @example
   *
   * _.isRegExp(/abc/);
   * // => true
   *
   * _.isRegExp('/abc/');
   * // => false
   */
  var isRegExp = baseIsRegExp;

  /**
   * Checks if `value` is classified as a `String` primitive or object.
   *
   * @static
   * @since 0.1.0
   * @memberOf _
   * @category Lang
   * @param {*} value The value to check.
   * @returns {boolean} Returns `true` if `value` is a string, else `false`.
   * @example
   *
   * _.isString('abc');
   * // => true
   *
   * _.isString(1);
   * // => false
   */
  function isString(value) {
    return typeof value == 'string' ||
      (!isArray(value) && isObjectLike(value) && baseGetTag(value) == stringTag);
  }

  /**
   * Checks if `value` is `undefined`.
   *
   * @static
   * @since 0.1.0
   * @memberOf _
   * @category Lang
   * @param {*} value The value to check.
   * @returns {boolean} Returns `true` if `value` is `undefined`, else `false`.
   * @example
   *
   * _.isUndefined(void 0);
   * // => true
   *
   * _.isUndefined(null);
   * // => false
   */
  function isUndefined(value) {
    return value === undefined;
  }

  /**
   * Converts `value` to an array.
   *
   * @static
   * @since 0.1.0
   * @memberOf _
   * @category Lang
   * @param {*} value The value to convert.
   * @returns {Array} Returns the converted array.
   * @example
   *
   * _.toArray({ 'a': 1, 'b': 2 });
   * // => [1, 2]
   *
   * _.toArray('abc');
   * // => ['a', 'b', 'c']
   *
   * _.toArray(1);
   * // => []
   *
   * _.toArray(null);
   * // => []
   */
  function toArray(value) {
    if (!isArrayLike(value)) {
      return values(value);
    }
    return value.length ? copyArray(value) : [];
  }

  /**
   * Converts `value` to an integer.
   *
   * **Note:** This method is loosely based on
   * [`ToInteger`](http://www.ecma-international.org/ecma-262/7.0/#sec-tointeger).
   *
   * @static
   * @memberOf _
   * @since 4.0.0
   * @category Lang
   * @param {*} value The value to convert.
   * @returns {number} Returns the converted integer.
   * @example
   *
   * _.toInteger(3.2);
   * // => 3
   *
   * _.toInteger(Number.MIN_VALUE);
   * // => 0
   *
   * _.toInteger(Infinity);
   * // => 1.7976931348623157e+308
   *
   * _.toInteger('3.2');
   * // => 3
   */
  var toInteger = Number;

  /**
   * Converts `value` to a number.
   *
   * @static
   * @memberOf _
   * @since 4.0.0
   * @category Lang
   * @param {*} value The value to process.
   * @returns {number} Returns the number.
   * @example
   *
   * _.toNumber(3.2);
   * // => 3.2
   *
   * _.toNumber(Number.MIN_VALUE);
   * // => 5e-324
   *
   * _.toNumber(Infinity);
   * // => Infinity
   *
   * _.toNumber('3.2');
   * // => 3.2
   */
  var toNumber = Number;

  /**
   * Converts `value` to a string. An empty string is returned for `null`
   * and `undefined` values. The sign of `-0` is preserved.
   *
   * @static
   * @memberOf _
   * @since 4.0.0
   * @category Lang
   * @param {*} value The value to convert.
   * @returns {string} Returns the converted string.
   * @example
   *
   * _.toString(null);
   * // => ''
   *
   * _.toString(-0);
   * // => '-0'
   *
   * _.toString([1, 2, 3]);
   * // => '1,2,3'
   */
  function toString(value) {
    if (typeof value == 'string') {
      return value;
    }
    return value == null ? '' : (value + '');
  }

  /*------------------------------------------------------------------------*/

  /**
   * Assigns own enumerable string keyed properties of source objects to the
   * destination object. Source objects are applied from left to right.
   * Subsequent sources overwrite property assignments of previous sources.
   *
   * **Note:** This method mutates `object` and is loosely based on
   * [`Object.assign`](https://mdn.io/Object/assign).
   *
   * @static
   * @memberOf _
   * @since 0.10.0
   * @category Object
   * @param {Object} object The destination object.
   * @param {...Object} [sources] The source objects.
   * @returns {Object} Returns `object`.
   * @see _.assignIn
   * @example
   *
   * function Foo() {
   *   this.a = 1;
   * }
   *
   * function Bar() {
   *   this.c = 3;
   * }
   *
   * Foo.prototype.b = 2;
   * Bar.prototype.d = 4;
   *
   * _.assign({ 'a': 0 }, new Foo, new Bar);
   * // => { 'a': 1, 'c': 3 }
   */
  var assign = createAssigner(function(object, source) {
    copyObject(source, nativeKeys(source), object);
  });

  /**
   * This method is like `_.assign` except that it iterates over own and
   * inherited source properties.
   *
   * **Note:** This method mutates `object`.
   *
   * @static
   * @memberOf _
   * @since 4.0.0
   * @alias extend
   * @category Object
   * @param {Object} object The destination object.
   * @param {...Object} [sources] The source objects.
   * @returns {Object} Returns `object`.
   * @see _.assign
   * @example
   *
   * function Foo() {
   *   this.a = 1;
   * }
   *
   * function Bar() {
   *   this.c = 3;
   * }
   *
   * Foo.prototype.b = 2;
   * Bar.prototype.d = 4;
   *
   * _.assignIn({ 'a': 0 }, new Foo, new Bar);
   * // => { 'a': 1, 'b': 2, 'c': 3, 'd': 4 }
   */
  var assignIn = createAssigner(function(object, source) {
    copyObject(source, nativeKeysIn(source), object);
  });

  /**
   * Creates an object that inherits from the `prototype` object. If a
   * `properties` object is given, its own enumerable string keyed properties
   * are assigned to the created object.
   *
   * @static
   * @memberOf _
   * @since 2.3.0
   * @category Object
   * @param {Object} prototype The object to inherit from.
   * @param {Object} [properties] The properties to assign to the object.
   * @returns {Object} Returns the new object.
   * @example
   *
   * function Shape() {
   *   this.x = 0;
   *   this.y = 0;
   * }
   *
   * function Circle() {
   *   Shape.call(this);
   * }
   *
   * Circle.prototype = _.create(Shape.prototype, {
   *   'constructor': Circle
   * });
   *
   * var circle = new Circle;
   * circle instanceof Circle;
   * // => true
   *
   * circle instanceof Shape;
   * // => true
   */
  function create(prototype, properties) {
    var result = baseCreate(prototype);
    return properties == null ? result : assign(result, properties);
  }

  /**
   * Assigns own and inherited enumerable string keyed properties of source
   * objects to the destination object for all destination properties that
   * resolve to `undefined`. Source objects are applied from left to right.
   * Once a property is set, additional values of the same property are ignored.
   *
   * **Note:** This method mutates `object`.
   *
   * @static
   * @since 0.1.0
   * @memberOf _
   * @category Object
   * @param {Object} object The destination object.
   * @param {...Object} [sources] The source objects.
   * @returns {Object} Returns `object`.
   * @see _.defaultsDeep
   * @example
   *
   * _.defaults({ 'a': 1 }, { 'b': 2 }, { 'a': 3 });
   * // => { 'a': 1, 'b': 2 }
   */
  var defaults = baseRest(function(object, sources) {
    object = Object(object);

    var index = -1;
    var length = sources.length;
    var guard = length > 2 ? sources[2] : undefined;

    if (guard && isIterateeCall(sources[0], sources[1], guard)) {
      length = 1;
    }

    while (++index < length) {
      var source = sources[index];
      var props = keysIn(source);
      var propsIndex = -1;
      var propsLength = props.length;

      while (++propsIndex < propsLength) {
        var key = props[propsIndex];
        var value = object[key];

        if (value === undefined ||
            (eq(value, objectProto[key]) && !hasOwnProperty.call(object, key))) {
          object[key] = source[key];
        }
      }
    }

    return object;
  });

  /**
   * Checks if `path` is a direct property of `object`.
   *
   * @static
   * @since 0.1.0
   * @memberOf _
   * @category Object
   * @param {Object} object The object to query.
   * @param {Array|string} path The path to check.
   * @returns {boolean} Returns `true` if `path` exists, else `false`.
   * @example
   *
   * var object = { 'a': { 'b': 2 } };
   * var other = _.create({ 'a': _.create({ 'b': 2 }) });
   *
   * _.has(object, 'a');
   * // => true
   *
   * _.has(object, 'a.b');
   * // => true
   *
   * _.has(object, ['a', 'b']);
   * // => true
   *
   * _.has(other, 'a');
   * // => false
   */
  function has(object, path) {
    return object != null && hasOwnProperty.call(object, path);
  }

  /**
   * Creates an array of the own enumerable property names of `object`.
   *
   * **Note:** Non-object values are coerced to objects. See the
   * [ES spec](http://ecma-international.org/ecma-262/7.0/#sec-object.keys)
   * for more details.
   *
   * @static
   * @since 0.1.0
   * @memberOf _
   * @category Object
   * @param {Object} object The object to query.
   * @returns {Array} Returns the array of property names.
   * @example
   *
   * function Foo() {
   *   this.a = 1;
   *   this.b = 2;
   * }
   *
   * Foo.prototype.c = 3;
   *
   * _.keys(new Foo);
   * // => ['a', 'b'] (iteration order is not guaranteed)
   *
   * _.keys('hi');
   * // => ['0', '1']
   */
  var keys = nativeKeys;

  /**
   * Creates an array of the own and inherited enumerable property names of `object`.
   *
   * **Note:** Non-object values are coerced to objects.
   *
   * @static
   * @memberOf _
   * @since 3.0.0
   * @category Object
   * @param {Object} object The object to query.
   * @returns {Array} Returns the array of property names.
   * @example
   *
   * function Foo() {
   *   this.a = 1;
   *   this.b = 2;
   * }
   *
   * Foo.prototype.c = 3;
   *
   * _.keysIn(new Foo);
   * // => ['a', 'b', 'c'] (iteration order is not guaranteed)
   */
  var keysIn = nativeKeysIn;

  /**
   * Creates an object composed of the picked `object` properties.
   *
   * @static
   * @since 0.1.0
   * @memberOf _
   * @category Object
   * @param {Object} object The source object.
   * @param {...(string|string[])} [paths] The property paths to pick.
   * @returns {Object} Returns the new object.
   * @example
   *
   * var object = { 'a': 1, 'b': '2', 'c': 3 };
   *
   * _.pick(object, ['a', 'c']);
   * // => { 'a': 1, 'c': 3 }
   */
  var pick = flatRest(function(object, paths) {
    return object == null ? {} : basePick(object, paths);
  });

  /**
   * This method is like `_.get` except that if the resolved value is a
   * function it's invoked with the `this` binding of its parent object and
   * its result is returned.
   *
   * @static
   * @since 0.1.0
   * @memberOf _
   * @category Object
   * @param {Object} object The object to query.
   * @param {Array|string} path The path of the property to resolve.
   * @param {*} [defaultValue] The value returned for `undefined` resolved values.
   * @returns {*} Returns the resolved value.
   * @example
   *
   * var object = { 'a': [{ 'b': { 'c1': 3, 'c2': _.constant(4) } }] };
   *
   * _.result(object, 'a[0].b.c1');
   * // => 3
   *
   * _.result(object, 'a[0].b.c2');
   * // => 4
   *
   * _.result(object, 'a[0].b.c3', 'default');
   * // => 'default'
   *
   * _.result(object, 'a[0].b.c3', _.constant('default'));
   * // => 'default'
   */
  function result(object, path, defaultValue) {
    var value = object == null ? undefined : object[path];
    if (value === undefined) {
      value = defaultValue;
    }
    return isFunction(value) ? value.call(object) : value;
  }

  /**
   * Creates an array of the own enumerable string keyed property values of `object`.
   *
   * **Note:** Non-object values are coerced to objects.
   *
   * @static
   * @since 0.1.0
   * @memberOf _
   * @category Object
   * @param {Object} object The object to query.
   * @returns {Array} Returns the array of property values.
   * @example
   *
   * function Foo() {
   *   this.a = 1;
   *   this.b = 2;
   * }
   *
   * Foo.prototype.c = 3;
   *
   * _.values(new Foo);
   * // => [1, 2] (iteration order is not guaranteed)
   *
   * _.values('hi');
   * // => ['h', 'i']
   */
  function values(object) {
    return object == null ? [] : baseValues(object, keys(object));
  }

  /*------------------------------------------------------------------------*/

  /**
   * Converts the characters "&", "<", ">", '"', and "'" in `string` to their
   * corresponding HTML entities.
   *
   * **Note:** No other characters are escaped. To escape additional
   * characters use a third-party library like [_he_](https://mths.be/he).
   *
   * Though the ">" character is escaped for symmetry, characters like
   * ">" and "/" don't need escaping in HTML and have no special meaning
   * unless they're part of a tag or unquoted attribute value. See
   * [Mathias Bynens's article](https://mathiasbynens.be/notes/ambiguous-ampersands)
   * (under "semi-related fun fact") for more details.
   *
   * When working with HTML you should always
   * [quote attribute values](http://wonko.com/post/html-escaping) to reduce
   * XSS vectors.
   *
   * @static
   * @since 0.1.0
   * @memberOf _
   * @category String
   * @param {string} [string=''] The string to escape.
   * @returns {string} Returns the escaped string.
   * @example
   *
   * _.escape('fred, barney, & pebbles');
   * // => 'fred, barney, &amp; pebbles'
   */
  function escape(string) {
    string = toString(string);
    return (string && reHasUnescapedHtml.test(string))
      ? string.replace(reUnescapedHtml, escapeHtmlChar)
      : string;
  }

  /*------------------------------------------------------------------------*/

  /**
   * This method returns the first argument it receives.
   *
   * @static
   * @since 0.1.0
   * @memberOf _
   * @category Util
   * @param {*} value Any value.
   * @returns {*} Returns `value`.
   * @example
   *
   * var object = { 'a': 1 };
   *
   * console.log(_.identity(object) === object);
   * // => true
   */
  function identity(value) {
    return value;
  }

  /**
   * Creates a function that invokes `func` with the arguments of the created
   * function. If `func` is a property name, the created function returns the
   * property value for a given element. If `func` is an array or object, the
   * created function returns `true` for elements that contain the equivalent
   * source properties, otherwise it returns `false`.
   *
   * @static
   * @since 4.0.0
   * @memberOf _
   * @category Util
   * @param {*} [func=_.identity] The value to convert to a callback.
   * @returns {Function} Returns the callback.
   * @example
   *
   * var users = [
   *   { 'user': 'barney', 'age': 36, 'active': true },
   *   { 'user': 'fred',   'age': 40, 'active': false }
   * ];
   *
   * // The `_.matches` iteratee shorthand.
   * _.filter(users, _.iteratee({ 'user': 'barney', 'active': true }));
   * // => [{ 'user': 'barney', 'age': 36, 'active': true }]
   *
   * // The `_.matchesProperty` iteratee shorthand.
   * _.filter(users, _.iteratee(['user', 'fred']));
   * // => [{ 'user': 'fred', 'age': 40 }]
   *
   * // The `_.property` iteratee shorthand.
   * _.map(users, _.iteratee('user'));
   * // => ['barney', 'fred']
   *
   * // Create custom iteratee shorthands.
   * _.iteratee = _.wrap(_.iteratee, function(iteratee, func) {
   *   return !_.isRegExp(func) ? iteratee(func) : function(string) {
   *     return func.test(string);
   *   };
   * });
   *
   * _.filter(['abc', 'def'], /ef/);
   * // => ['def']
   */
  var iteratee = baseIteratee;

  /**
   * Creates a function that performs a partial deep comparison between a given
   * object and `source`, returning `true` if the given object has equivalent
   * property values, else `false`.
   *
   * **Note:** The created function is equivalent to `_.isMatch` with `source`
   * partially applied.
   *
   * Partial comparisons will match empty array and empty object `source`
   * values against any array or object value, respectively. See `_.isEqual`
   * for a list of supported value comparisons.
   *
   * @static
   * @memberOf _
   * @since 3.0.0
   * @category Util
   * @param {Object} source The object of property values to match.
   * @returns {Function} Returns the new spec function.
   * @example
   *
   * var objects = [
   *   { 'a': 1, 'b': 2, 'c': 3 },
   *   { 'a': 4, 'b': 5, 'c': 6 }
   * ];
   *
   * _.filter(objects, _.matches({ 'a': 4, 'c': 6 }));
   * // => [{ 'a': 4, 'b': 5, 'c': 6 }]
   */
  function matches(source) {
    return baseMatches(assign({}, source));
  }

  /**
   * Adds all own enumerable string keyed function properties of a source
   * object to the destination object. If `object` is a function, then methods
   * are added to its prototype as well.
   *
   * **Note:** Use `_.runInContext` to create a pristine `lodash` function to
   * avoid conflicts caused by modifying the original.
   *
   * @static
   * @since 0.1.0
   * @memberOf _
   * @category Util
   * @param {Function|Object} [object=lodash] The destination object.
   * @param {Object} source The object of functions to add.
   * @param {Object} [options={}] The options object.
   * @param {boolean} [options.chain=true] Specify whether mixins are chainable.
   * @returns {Function|Object} Returns `object`.
   * @example
   *
   * function vowels(string) {
   *   return _.filter(string, function(v) {
   *     return /[aeiou]/i.test(v);
   *   });
   * }
   *
   * _.mixin({ 'vowels': vowels });
   * _.vowels('fred');
   * // => ['e']
   *
   * _('fred').vowels().value();
   * // => ['e']
   *
   * _.mixin({ 'vowels': vowels }, { 'chain': false });
   * _('fred').vowels();
   * // => ['e']
   */
  function mixin(object, source, options) {
    var props = keys(source),
        methodNames = baseFunctions(source, props);

    if (options == null &&
        !(isObject(source) && (methodNames.length || !props.length))) {
      options = source;
      source = object;
      object = this;
      methodNames = baseFunctions(source, keys(source));
    }
    var chain = !(isObject(options) && 'chain' in options) || !!options.chain,
        isFunc = isFunction(object);

    baseEach(methodNames, function(methodName) {
      var func = source[methodName];
      object[methodName] = func;
      if (isFunc) {
        object.prototype[methodName] = function() {
          var chainAll = this.__chain__;
          if (chain || chainAll) {
            var result = object(this.__wrapped__),
                actions = result.__actions__ = copyArray(this.__actions__);

            actions.push({ 'func': func, 'args': arguments, 'thisArg': object });
            result.__chain__ = chainAll;
            return result;
          }
          return func.apply(object, arrayPush([this.value()], arguments));
        };
      }
    });

    return object;
  }

  /**
   * Reverts the `_` variable to its previous value and returns a reference to
   * the `lodash` function.
   *
   * @static
   * @since 0.1.0
   * @memberOf _
   * @category Util
   * @returns {Function} Returns the `lodash` function.
   * @example
   *
   * var lodash = _.noConflict();
   */
  function noConflict() {
    if (root._ === this) {
      root._ = oldDash;
    }
    return this;
  }

  /**
   * This method returns `undefined`.
   *
   * @static
   * @memberOf _
   * @since 2.3.0
   * @category Util
   * @example
   *
   * _.times(2, _.noop);
   * // => [undefined, undefined]
   */
  function noop() {
    // No operation performed.
  }

  /**
   * Generates a unique ID. If `prefix` is given, the ID is appended to it.
   *
   * @static
   * @since 0.1.0
   * @memberOf _
   * @category Util
   * @param {string} [prefix=''] The value to prefix the ID with.
   * @returns {string} Returns the unique ID.
   * @example
   *
   * _.uniqueId('contact_');
   * // => 'contact_104'
   *
   * _.uniqueId();
   * // => '105'
   */
  function uniqueId(prefix) {
    var id = ++idCounter;
    return toString(prefix) + id;
  }

  /*------------------------------------------------------------------------*/

  /**
   * Computes the maximum value of `array`. If `array` is empty or falsey,
   * `undefined` is returned.
   *
   * @static
   * @since 0.1.0
   * @memberOf _
   * @category Math
   * @param {Array} array The array to iterate over.
   * @returns {*} Returns the maximum value.
   * @example
   *
   * _.max([4, 2, 8, 6]);
   * // => 8
   *
   * _.max([]);
   * // => undefined
   */
  function max(array) {
    return (array && array.length)
      ? baseExtremum(array, identity, baseGt)
      : undefined;
  }

  /**
   * Computes the minimum value of `array`. If `array` is empty or falsey,
   * `undefined` is returned.
   *
   * @static
   * @since 0.1.0
   * @memberOf _
   * @category Math
   * @param {Array} array The array to iterate over.
   * @returns {*} Returns the minimum value.
   * @example
   *
   * _.min([4, 2, 8, 6]);
   * // => 2
   *
   * _.min([]);
   * // => undefined
   */
  function min(array) {
    return (array && array.length)
      ? baseExtremum(array, identity, baseLt)
      : undefined;
  }

  /*------------------------------------------------------------------------*/

  // Add methods that return wrapped values in chain sequences.
  lodash.assignIn = assignIn;
  lodash.before = before;
  lodash.bind = bind;
  lodash.chain = chain;
  lodash.compact = compact;
  lodash.concat = concat;
  lodash.create = create;
  lodash.defaults = defaults;
  lodash.defer = defer;
  lodash.delay = delay;
  lodash.filter = filter;
  lodash.flatten = flatten;
  lodash.flattenDeep = flattenDeep;
  lodash.iteratee = iteratee;
  lodash.keys = keys;
  lodash.map = map;
  lodash.matches = matches;
  lodash.mixin = mixin;
  lodash.negate = negate;
  lodash.once = once;
  lodash.pick = pick;
  lodash.slice = slice;
  lodash.sortBy = sortBy;
  lodash.tap = tap;
  lodash.thru = thru;
  lodash.toArray = toArray;
  lodash.values = values;

  // Add aliases.
  lodash.extend = assignIn;

  // Add methods to `lodash.prototype`.
  mixin(lodash, lodash);

  /*------------------------------------------------------------------------*/

  // Add methods that return unwrapped values in chain sequences.
  lodash.clone = clone;
  lodash.escape = escape;
  lodash.every = every;
  lodash.find = find;
  lodash.forEach = forEach;
  lodash.has = has;
  lodash.head = head;
  lodash.identity = identity;
  lodash.indexOf = indexOf;
  lodash.isArguments = isArguments;
  lodash.isArray = isArray;
  lodash.isBoolean = isBoolean;
  lodash.isDate = isDate;
  lodash.isEmpty = isEmpty;
  lodash.isEqual = isEqual;
  lodash.isFinite = isFinite;
  lodash.isFunction = isFunction;
  lodash.isNaN = isNaN;
  lodash.isNull = isNull;
  lodash.isNumber = isNumber;
  lodash.isObject = isObject;
  lodash.isRegExp = isRegExp;
  lodash.isString = isString;
  lodash.isUndefined = isUndefined;
  lodash.last = last;
  lodash.max = max;
  lodash.min = min;
  lodash.noConflict = noConflict;
  lodash.noop = noop;
  lodash.reduce = reduce;
  lodash.result = result;
  lodash.size = size;
  lodash.some = some;
  lodash.uniqueId = uniqueId;

  // Add aliases.
  lodash.each = forEach;
  lodash.first = head;

  mixin(lodash, (function() {
    var source = {};
    baseForOwn(lodash, function(func, methodName) {
      if (!hasOwnProperty.call(lodash.prototype, methodName)) {
        source[methodName] = func;
      }
    });
    return source;
  }()), { 'chain': false });

  /*------------------------------------------------------------------------*/

  /**
   * The semantic version number.
   *
   * @static
   * @memberOf _
   * @type {string}
   */
  lodash.VERSION = VERSION;

  // Add `Array` methods to `lodash.prototype`.
  baseEach(['pop', 'join', 'replace', 'reverse', 'split', 'push', 'shift', 'sort', 'splice', 'unshift'], function(methodName) {
    var func = (/^(?:replace|split)$/.test(methodName) ? String.prototype : arrayProto)[methodName],
        chainName = /^(?:push|sort|unshift)$/.test(methodName) ? 'tap' : 'thru',
        retUnwrapped = /^(?:pop|join|replace|shift)$/.test(methodName);

    lodash.prototype[methodName] = function() {
      var args = arguments;
      if (retUnwrapped && !this.__chain__) {
        var value = this.value();
        return func.apply(isArray(value) ? value : [], args);
      }
      return this[chainName](function(value) {
        return func.apply(isArray(value) ? value : [], args);
      });
    };
  });

  // Add chain sequence methods to the `lodash` wrapper.
  lodash.prototype.toJSON = lodash.prototype.valueOf = lodash.prototype.value = wrapperValue;

  /*--------------------------------------------------------------------------*/

  // Some AMD build optimizers, like r.js, check for condition patterns like:
  if (true) {
    // Expose Lodash on the global object to prevent errors when Lodash is
    // loaded by a script tag in the presence of an AMD loader.
    // See http://requirejs.org/docs/errors.html#mismatch for more details.
    // Use `_.noConflict` to remove Lodash from the global object.
    root._ = lodash;

    // Define as an anonymous module so, through path mapping, it can be
    // referenced as the "underscore" module.
    !(__WEBPACK_AMD_DEFINE_RESULT__ = (function() {
      return lodash;
    }).call(exports, __webpack_require__, exports, module),
				__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));
  }
  // Check for `exports` after `define` in case a build optimizer adds it.
  else if (freeModule) {
    // Export for Node.js.
    (freeModule.exports = lodash)._ = lodash;
    // Export for CommonJS support.
    freeExports._ = lodash;
  }
  else {
    // Export to the global object.
    root._ = lodash;
  }
}.call(this));

/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(0), __webpack_require__(45)(module)))

/***/ }),
/* 45 */
/***/ (function(module, exports) {

module.exports = function(module) {
	if(!module.webpackPolyfill) {
		module.deprecate = function() {};
		module.paths = [];
		// module.parent = undefined by default
		if(!module.children) module.children = [];
		Object.defineProperty(module, "loaded", {
			enumerable: true,
			get: function() {
				return module.l;
			}
		});
		Object.defineProperty(module, "id", {
			enumerable: true,
			get: function() {
				return module.i;
			}
		});
		module.webpackPolyfill = 1;
	}
	return module;
};


/***/ }),
/* 46 */
/***/ (function(module, exports, __webpack_require__) {

var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;/**
 * @preserve jquery-param (c) 2015 KNOWLEDGECODE | MIT
 */
(function (global) {
    'use strict';

    var param = function (a) {
        var s = [];
        var add = function (k, v) {
            v = typeof v === 'function' ? v() : v;
            v = v === null ? '' : v === undefined ? '' : v;
            s[s.length] = encodeURIComponent(k) + '=' + encodeURIComponent(v);
        };
        var buildParams = function (prefix, obj) {
            var i, len, key;

            if (prefix) {
                if (Array.isArray(obj)) {
                    for (i = 0, len = obj.length; i < len; i++) {
                        buildParams(
                            prefix + '[' + (typeof obj[i] === 'object' && obj[i] ? i : '') + ']',
                            obj[i]
                        );
                    }
                } else if (String(obj) === '[object Object]') {
                    for (key in obj) {
                        buildParams(prefix + '[' + key + ']', obj[key]);
                    }
                } else {
                    add(prefix, obj);
                }
            } else if (Array.isArray(obj)) {
                for (i = 0, len = obj.length; i < len; i++) {
                    add(obj[i].name, obj[i].value);
                }
            } else {
                for (key in obj) {
                    buildParams(key, obj[key]);
                }
            }
            return s;
        };

        return buildParams('', a).join('&');
    };

    if (typeof module === 'object' && typeof module.exports === 'object') {
        module.exports = param;
    } else if (true) {
        !(__WEBPACK_AMD_DEFINE_ARRAY__ = [], __WEBPACK_AMD_DEFINE_RESULT__ = (function () {
            return param;
        }).apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__),
				__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));
    } else {
        global.param = param;
    }

}(this));


/***/ }),
/* 47 */
/***/ (function(module, exports) {

// Sound meter is used to detect speaker
function SoundMeter(opts) {
    this.context =  new AudioContext();
    this.volume = 0.0;
    this.slow_volume = 0.0;
    this.clip = 0.0;
    // Legal values are (256, 512, 1024, 2048, 4096, 8192, 16384)
    this.script = this.context.createScriptProcessor(256, 1, 1);
    that = this;
    this.script.onaudioprocess = function(event) {
        if( !opts.onprocess ) return;
        var input = event.inputBuffer.getChannelData(0);
        var i;
        var sum = 0.0;
        var clipcount = 0;
        for (i = 0; i < input.length; ++i) {
            sum += input[i] * input[i];
            if (Math.abs(input[i]) > 0.99) {
                clipcount += 1;
            }
        }
        that.volume = Math.sqrt(sum / input.length);

        var volume = that.volume.toFixed(2);

        if (opts.onprocess) {
            opts.onprocess({
                volume: volume,
                status: volume >= .1 ? "speaking" : "silence",
                event: event
            });
        }
    };
    this.connectToSource( opts.stream );
}

SoundMeter.prototype.connectToSource = function(stream) {
    this.mic = this.context.createMediaStreamSource(stream);
    this.mic.connect(this.script);
    this.script.connect(this.context.destination);
};

SoundMeter.prototype.stop = function() {
    this.mic.disconnect();
    this.script.disconnect();
};



module.exports = SoundMeter;

/***/ }),
/* 48 */
/***/ (function(module, exports, __webpack_require__) {

var __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;/**
 * isMobile.js v0.4.1
 *
 * A simple library to detect Apple phones and tablets,
 * Android phones and tablets, other mobile devices (like blackberry, mini-opera and windows phone),
 * and any kind of seven inch device, via user agent sniffing.
 *
 * @author: Kai Mallea (kmallea@gmail.com)
 *
 * @license: http://creativecommons.org/publicdomain/zero/1.0/
 */
(function (global) {

    var apple_phone         = /iPhone/i,
        apple_ipod          = /iPod/i,
        apple_tablet        = /iPad/i,
        android_phone       = /(?=.*\bAndroid\b)(?=.*\bMobile\b)/i, // Match 'Android' AND 'Mobile'
        android_tablet      = /Android/i,
        amazon_phone        = /(?=.*\bAndroid\b)(?=.*\bSD4930UR\b)/i,
        amazon_tablet       = /(?=.*\bAndroid\b)(?=.*\b(?:KFOT|KFTT|KFJWI|KFJWA|KFSOWI|KFTHWI|KFTHWA|KFAPWI|KFAPWA|KFARWI|KFASWI|KFSAWI|KFSAWA)\b)/i,
        windows_phone       = /Windows Phone/i,
        windows_tablet      = /(?=.*\bWindows\b)(?=.*\bARM\b)/i, // Match 'Windows' AND 'ARM'
        other_blackberry    = /BlackBerry/i,
        other_blackberry_10 = /BB10/i,
        other_opera         = /Opera Mini/i,
        other_chrome        = /(CriOS|Chrome)(?=.*\bMobile\b)/i,
        other_firefox       = /(?=.*\bFirefox\b)(?=.*\bMobile\b)/i, // Match 'Firefox' AND 'Mobile'
        seven_inch = new RegExp(
            '(?:' +         // Non-capturing group

            'Nexus 7' +     // Nexus 7

            '|' +           // OR

            'BNTV250' +     // B&N Nook Tablet 7 inch

            '|' +           // OR

            'Kindle Fire' + // Kindle Fire

            '|' +           // OR

            'Silk' +        // Kindle Fire, Silk Accelerated

            '|' +           // OR

            'GT-P1000' +    // Galaxy Tab 7 inch

            ')',            // End non-capturing group

            'i');           // Case-insensitive matching

    var match = function(regex, userAgent) {
        return regex.test(userAgent);
    };

    var IsMobileClass = function(userAgent) {
        var ua = userAgent || navigator.userAgent;

        // Facebook mobile app's integrated browser adds a bunch of strings that
        // match everything. Strip it out if it exists.
        var tmp = ua.split('[FBAN');
        if (typeof tmp[1] !== 'undefined') {
            ua = tmp[0];
        }

        // Twitter mobile app's integrated browser on iPad adds a "Twitter for
        // iPhone" string. Same probable happens on other tablet platforms.
        // This will confuse detection so strip it out if it exists.
        tmp = ua.split('Twitter');
        if (typeof tmp[1] !== 'undefined') {
            ua = tmp[0];
        }

        this.apple = {
            phone:  match(apple_phone, ua),
            ipod:   match(apple_ipod, ua),
            tablet: !match(apple_phone, ua) && match(apple_tablet, ua),
            device: match(apple_phone, ua) || match(apple_ipod, ua) || match(apple_tablet, ua)
        };
        this.amazon = {
            phone:  match(amazon_phone, ua),
            tablet: !match(amazon_phone, ua) && match(amazon_tablet, ua),
            device: match(amazon_phone, ua) || match(amazon_tablet, ua)
        };
        this.android = {
            phone:  match(amazon_phone, ua) || match(android_phone, ua),
            tablet: !match(amazon_phone, ua) && !match(android_phone, ua) && (match(amazon_tablet, ua) || match(android_tablet, ua)),
            device: match(amazon_phone, ua) || match(amazon_tablet, ua) || match(android_phone, ua) || match(android_tablet, ua)
        };
        this.windows = {
            phone:  match(windows_phone, ua),
            tablet: match(windows_tablet, ua),
            device: match(windows_phone, ua) || match(windows_tablet, ua)
        };
        this.other = {
            blackberry:   match(other_blackberry, ua),
            blackberry10: match(other_blackberry_10, ua),
            opera:        match(other_opera, ua),
            firefox:      match(other_firefox, ua),
            chrome:       match(other_chrome, ua),
            device:       match(other_blackberry, ua) || match(other_blackberry_10, ua) || match(other_opera, ua) || match(other_firefox, ua) || match(other_chrome, ua)
        };
        this.seven_inch = match(seven_inch, ua);
        this.any = this.apple.device || this.android.device || this.windows.device || this.other.device || this.seven_inch;

        // excludes 'other' devices and ipods, targeting touchscreen phones
        this.phone = this.apple.phone || this.android.phone || this.windows.phone;

        // excludes 7 inch devices, classifying as phone or tablet is left to the user
        this.tablet = this.apple.tablet || this.android.tablet || this.windows.tablet;

        if (typeof window === 'undefined') {
            return this;
        }
    };

    var instantiate = function() {
        var IM = new IsMobileClass();
        IM.Class = IsMobileClass;
        return IM;
    };

    if (typeof module !== 'undefined' && module.exports && typeof window === 'undefined') {
        //node
        module.exports = IsMobileClass;
    } else if (typeof module !== 'undefined' && module.exports && typeof window !== 'undefined') {
        //browserify
        module.exports = instantiate();
    } else if (true) {
        //AMD
        !(__WEBPACK_AMD_DEFINE_ARRAY__ = [], __WEBPACK_AMD_DEFINE_FACTORY__ = (global.isMobile = instantiate()),
				__WEBPACK_AMD_DEFINE_RESULT__ = (typeof __WEBPACK_AMD_DEFINE_FACTORY__ === 'function' ?
				(__WEBPACK_AMD_DEFINE_FACTORY__.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__)) : __WEBPACK_AMD_DEFINE_FACTORY__),
				__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));
    } else {
        global.isMobile = instantiate();
    }

})(this);


/***/ })
/******/ ]);